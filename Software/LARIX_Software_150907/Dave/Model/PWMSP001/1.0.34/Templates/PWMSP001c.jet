<%@ jet package="CodeGenerator" class="pwmsp001c_template"
imports="java.util.* com.ifx.davex.appjetinteract.App2JetInterface" %>
<% App2JetInterface app = (App2JetInterface) argument; %>


/*CODE_BLOCK_BEGIN[PWMSP001.c]*/


/*******************************************************************************
 Copyright (c) 2014, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
********************************************************************************
**                                                                            **
**                                                                            **
** PLATFORM : Infineon XMC4000/XMC1000 Series                                 **
**                                                                            **
** COMPILER : Compiler Independent                                            **
**                                                                            **
** AUTHOR   : App Developer                                                   **
**                                                                            **
** MAY BE CHANGED BY USER [yes/no]: Yes                                       **
**                                                                            **
** MODIFICATION DATE : April 28, 2014                                         **
**                                                                            **
*******************************************************************************/
/*******************************************************************************
**                      Author(s) Identity                                    **
********************************************************************************
**                                                                            **
** Initials     Name                                                          **
** ---------------------------------------------------------------------------**
** KS           App Developer                                                 **
**                                                                            **
*******************************************************************************/

/**
 * @file  PWMSP001.c
 *
 * @brief This file contains implementations of all Public and Private functions
 *        of Single Phase PWM without dead time APP.
 *        This app generates the single PWM waveform without dead time. 
 *        Duty cycle can be changed at runtime. And PWM frequency can be changed
 *        when timer is not running.
 */

/* Revision History															  
 * 21 Nov 2012   v1.0.16   coding guidelines  
 * 10 Dec 2012   v1.0.18   DBG002 Macros are added
 * 1  Feb 2013   v1.0.20   PDR register constraints are added
 * 26 Mar 2013   v1.0.22   DAVE3.H inclusion
 * 22 Apr 2013   v1.0.24   MCSW300000628 utp w.r.t open drain port configuration
 *                         is fixed
 * 						   MCSW300000629 utp w.r.t SetCompare API is fixed by 
 *                         fetching period value from register instead from UI 
 *                         parameter
 * 						   Removed the inclusion of other header files
 *                                                  (PWMSP001.h,PWMSP001_Conf.c)
 * 30 Aug 2013   v1.0.26   Defect 32385 fix: Duty cycle updation issue when not 
 *                         using timer concatenation in 
 *                         PWMSP001_SetPwmFreqAndDutyCycle() API is fixed.
 * 17 Feb 2014   v1.0.32   1.Trap enabling is shifted from PWMSP001_Start() to
 *                           PWMSP001_Init()
 *                         2.In PWMSP001_lSetDutyEdgeAlignTimerConcat()compare
 *                          value calculation is updated.
 *                         3.During Timer concatenation if single shot mode is 
 *                          enabled lower timer is made as free running.
 * 28 Apr 2014   v1.0.34   Removed the DBG002_FUNCTION_ENTRY() and 
 *                         DBG002_FUNCTION_EXIT() from all the APIs.
 *                         In PWMSP001_SetCompare() period value checks are 
 *                         removed.
 */

/*******************************************************************************
**                      Include Files                                         **
*******************************************************************************/
#include <DAVE3.h>

<% String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } %>

<% if (!DBGApp) { %>  
/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/ 
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e) 
#define DBG002_IG(e,g) 
#define DBG002_IH(e,h) 
#define DBG002_IP(e,p) 
#define DBG002_IGH(e,g,h) 
#define DBG002_IGP(e,g,p) 
#define DBG002_IHP(e,h,p) 
#define DBG002_IGHP(e,g,h,p) 
#define DBG002_N(e) 
#define DBG002_NG(e,g) 
#define DBG002_NH(e,h) 
#define DBG002_NP(e,p) 
#define DBG002_NGH(e,g,h) 
#define DBG002_NGP(e,g,p) 
#define DBG002_NHP(e,h,p) 
#define DBG002_NGHP(e,g,h,p) 
#define DBG002_ID(e) 
#define DBG002_IS(e) 
#define DBG002_ISG(e,g) 
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status) 
#define DBG002_FUNCTION_EXIT(GID, Status) 
#define DBG002_MESSAGEID_LITERAL
#endif/* End of definitions of dummy Debug Log macros*/
<% } %>   
#define APP_GID DBG002_GID_PWMSP001

#define PWMSP001_STATUS_LEN 4U
/*******************************************************************************
 **                 Private Function declarations                              **
 *******************************************************************************/
/**
 * @cond INTERNAL_DOCS
 */
/**
 * @ingroup PWMSP001_privatefunc
 * @{
 */

/**
 * @brief This function will initialize second slice registers (in case of timer
 * concatenation) with user configured value
 * @param[in]   HandlePtr Pointer to PWMSP001_HandleType structure
 * @return void
 */
void PWMSP001_lConfigureSecondSlice
(
    const PWMSP001_HandleType* HandlePtr
);

/**
 * @brief This function will set duty cycle if center aligned mode is selected.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Duty This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetDutyCenterAlign
(
    void* Handle,
    float Duty
);

/**
 * @brief This function will set duty cycle if edge aligned mode without timer concatenation is selected.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Duty This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetDutyEdgeAlign
(
    void* Handle,
    float Duty
);

/**
 * @brief This function will set duty cycle if edge aligned mode with timer concatenation is supported.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Duty This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetDutyEdgeAlignTimerConcat
(
    void* Handle,
    float Duty
);

/**
 * @brief This function will set duty cycle if center aligned mode is selected.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Compare This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetCompareCenterAlign
(
    void* Handle,
    uint32_t Compare
);

/**
 * @brief This function will set duty cycle if edge aligned mode without timer concatenation is selected.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Compare This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetCompareEdgeAlign
(
    void* Handle,
    uint32_t Compare
);

/**
 * @brief This function will set duty cycle if edge aligned mode with timer concatenation is supported.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  Compare This is duty cycle in percentage
 * @return status_t void
 */
void PWMSP001_lSetCompareEdgeAlignTimerConcat
(
    void* Handle,
    uint32_t Compare
);

/**
 * @brief This function will set pwm frequency if timer concatenation is selected
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @param[in]  PwmTime This is PWM frequency in hertz.
 * @return status_t status
 */
status_t PWMSP001_lSetPwmFreqTimerConcat
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t PwmTime
);

/**
 * @brief This function initializes CCU4 slice as per GUI configurations.
 * @param[in]  HandlePtr Pointer to PWMSP001_HandleType structure
 * @return status_t status
 */
status_t PWMSP001_lInit(const PWMSP001_HandleType* HandlePtr);

/**
 * @}
 */

/*******************************************************************************
 **                 Function definitions                                       **
 *******************************************************************************/

<% String AppBaseuri = "app/pwmsp001/"; %>
<% String appInst  = null; %>
<% String pinUri ;%>
<% String portNo ;%>
<% String pinNo ;%>   
<% int PDR_PD1 ;%>
<% int PDR_PO ;%>
<% int Pin ;%>
<% int Is1xDevice = -1; %>
/* This function initializes the app */
void PWMSP001_Init(void)
{
  status_t Error = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  CCU4GLOBAL_Init();
<% ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/pwmsp001/"));
for (String appIns : appsList ) {
    appInst = appIns.substring(appIns.lastIndexOf("/")+1);%>
  Error = PWMSP001_lInit((PWMSP001_HandleType*) &PWMSP001_Handle<%= appInst%>);
  /* Start the app if "Start after initialization" is checked */
  if(Error == (uint32_t)DAVEApp_SUCCESS)
  {   
    if (PWMSP001_Handle<%= appInst%>.StartControl == (uint8_t)SET)
    {
      Error = PWMSP001_Start((PWMSP001_HandleType*) &PWMSP001_Handle<%= appInst%>);
      DBG002_N(Error != DAVEApp_SUCCESS);
    }
  }
  <% if(app.getIntegerValue(AppBaseuri + appInst +"/pwmsp001_erwdirectoutputpadenable/0")==1)%>
  <% { %>
    <% pinUri = app.getMappedUri(AppBaseuri + appInst +"/pin_directoutput"); %>
    <% if ((pinUri != null) && (pinUri.trim() != "")) %>
    <% { %>
      <% portNo = pinUri.substring(pinUri.indexOf("port/p/")+7,pinUri.indexOf("/pad/")); %>
      <% pinNo = pinUri.substring(pinUri.indexOf("/pad/")+5,pinUri.length()); %>
      <% PDR_PD1 = app.getIntegerValue(AppBaseuri + appInst +"/pin_directoutput/pdr_pd"); %>
      <% PDR_PO = app.getIntegerValue(AppBaseuri + appInst +"/pwmsp001_erwdirectoutputpadchar/1");%>
      <% Pin = Integer.parseInt(pinNo);%>
    
      <% Is1xDevice = ((app.getSoftwareId().substring(0,1).compareTo("1")==0)?1:0); %>
      <% if(Is1xDevice==0) %>
      <% { %>
      /* Configuration of Direct Output Pin <%=portNo%>.<%=pinNo%> based on User configuration */
      <% if(Pin < 8) %>
      <% { %>
      PORT<%=portNo%>->PDR0  &= (uint32_t)(~(PORT<%=portNo%>_PDR0_PD<%=Pin%>_Msk));
      PORT<%=portNo%>->PDR0  |= (((uint32_t)<%=PDR_PD1%> << (uint32_t)PORT<%=portNo%>_PDR0_PD<%=Pin%>_Pos) & \
                               (uint32_t)PORT<%=portNo%>_PDR0_PD<%=Pin%>_Msk);
      <% } else { %>
      PORT<%=portNo%>->PDR1 &= (uint32_t)(~(PORT<%=portNo%>_PDR1_PD<%=Pin%>_Msk));
      PORT<%=portNo%>->PDR1 |= (((uint32_t)<%=PDR_PD1%> << (uint32_t)PORT<%=portNo%>_PDR1_PD<%=Pin%>_Pos) & \
                               (uint32_t)PORT<%=portNo%>_PDR1_PD<%=Pin%>_Msk);
      <% } %>
    <% } %>
    <% if(Pin < 4) %>
          <% { %>
      PORT<%=portNo%>->IOCR0  &= (uint32_t)(~(PORT_IOCR_PC<%=Pin%>_PO_Msk));
      PORT<%=portNo%>->IOCR0  |= (((uint32_t)<%=PDR_PO%> << (uint32_t)PORT_IOCR_PC<%=Pin%>_PO_Pos) & \
                                   (uint32_t)PORT_IOCR_PC<%=Pin%>_PO_Msk);
          <% } else  if(Pin < 8){ %>
      PORT<%=portNo%>->IOCR4  &= (uint32_t)(~(PORT_IOCR_PC<%=Pin - 4%>_PO_Msk));
      PORT<%=portNo%>->IOCR4  |= (((uint32_t)<%=PDR_PO%> << (uint32_t)PORT_IOCR_PC<%=Pin -4%>_PO_Pos) & \
                                   (uint32_t)PORT_IOCR_PC<%=Pin -4 %>_PO_Msk);
          <% } else  if(Pin < 12){ %>
      PORT<%=portNo%>->IOCR8  &= (uint32_t)(~(PORT_IOCR_PC<%=Pin - 8%>_PO_Msk));
      PORT<%=portNo%>->IOCR8  |= (((uint32_t)<%=PDR_PO%> << (uint32_t)PORT_IOCR_PC<%=Pin -8%>_PO_Pos) & \
                                   (uint32_t)PORT_IOCR_PC<%=Pin - 8 %>_PO_Msk);
          <% } else { %>
      PORT<%=portNo%>->IOCR12  &= (uint32_t)(~(PORT_IOCR_PC<%=Pin - 12%>_PO_Msk));
      PORT<%=portNo%>->IOCR12  |= (((uint32_t)<%=PDR_PO%> << (uint32_t)PORT_IOCR_PC<%=Pin -12%>_PO_Pos) & \
                                   (uint32_t)PORT_IOCR_PC<%=Pin - 12 %>_PO_Msk);
     <% } %>
    <% }else { %>
      /* Direct Output Pin instance (no.<%= appInst %>) is not mapped to any port pin. */
    <% } %>
  <% } %>
<%}%>
}

/*<<<DD_PWMSP001_API_1>>>*/
/* This function initializes an instance of the app */
status_t PWMSP001_lInit(const PWMSP001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  do
  {
    /*<<<DD_PWMSP001_API_1_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
    {
      break;
    }
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;

    /*<<<DD_PWMSP001_API_1_3>>>*/
    /* If external stop trigger is setelected */
    if (HandlePtr->kExtStopTrig == (uint8_t)SET)
    {
      HandlePtr->CC4yRegsPtr->INS &= (uint32_t)~((uint32_t)CCU4_CC4_INS_EV1EM_Msk | CCU4_CC4_INS_LPF1M_Msk);
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_ENDS_Msk;
      HandlePtr->CC4yRegsPtr->INS |= ((((uint32_t)HandlePtr->kStopEdge << (uint32_t)CCU4_CC4_INS_EV1EM_Pos)\
	    & (uint32_t)CCU4_CC4_INS_EV1EM_Msk)| (((uint32_t)PWMSP001_LPF  << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)\
		  & (uint32_t)CCU4_CC4_INS_LPF1M_Msk));

      HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<
          (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);
    }/*End of if (HandlePtr->kExtStopTrig == SET)*/

    /*<<<DD_PWMSP001_API_1_4>>>*/
    /* Trap configurations if trap is enabled */
    if ((HandlePtr->kTrapEnable == (uint8_t)SET) &&\
        ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
    )
    {
      HandlePtr->CC4yRegsPtr -> INS &= ~((uint32_t)CCU4_CC4_INS_EV2EM_Msk | \
	    (uint32_t)CCU4_CC4_INS_EV2LM_Msk | (uint32_t)CCU4_CC4_INS_LPF2M_Msk);
      HandlePtr->CC4yRegsPtr->CMC &= (uint32_t)~CCU4_CC4_CMC_TS_Msk;
      HandlePtr->CC4yRegsPtr -> INS |= ((((uint32_t)0 << (uint32_t)CCU4_CC4_INS_EV2EM_Pos)\
	    &(uint32_t)CCU4_CC4_INS_EV2EM_Msk) | (((uint32_t)HandlePtr->kTrapLevel  <<	\
		  (uint32_t)CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk ) | \
		    (((uint32_t)0 << (uint32_t)CCU4_CC4_INS_LPF2M_Pos)& \
			  (uint32_t)CCU4_CC4_INS_LPF2M_Msk));

      HandlePtr->CC4yRegsPtr->CMC |= ((uint32_t)1 << (uint32_t)CCU4_CC4_CMC_TS_Pos);
    }/* End of  if (HandlePtr->kTrapEnable == (uint8_t)SET)*/
    
    HandlePtr->CC4yRegsPtr->TC &= ~((uint32_t)CCU4_CC4_TC_TCM_Msk | \
	   (uint32_t)CCU4_CC4_TC_CMOD_Msk | (uint32_t)CCU4_CC4_TC_STRM_Msk | \
	   (uint32_t)CCU4_CC4_TC_ENDM_Msk | (uint32_t)CCU4_CC4_TC_DITHE_Msk);
    
    HandlePtr->CC4yRegsPtr->TC |= (((uint32_t)HandlePtr->CountingModeType << \
	  (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|\
		  (((uint32_t)PWMSP001_COMPARE_MODE  << \
		    (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
			  (((uint32_t)HandlePtr->ExtStartConfigType  << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			    &(uint32_t)CCU4_CC4_TC_STRM_Msk)|(((uint32_t)HandlePtr->ExtStopConfigType <<\
				  (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);
    /*
     * If timer concatenation is enabled during single shot mode lower timer 
     * should be free running
     */
	if (HandlePtr->kTimerConcatenation != (uint8_t)SET)
	{
		WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TSSM_Msk, \
			  		  (uint32_t)CCU4_CC4_TC_TSSM_Pos, HandlePtr->kTimerMode);
	} 
    
    /*Set the dither mode setting*/
    HandlePtr->CC4yRegsPtr->TC |= ((uint32_t)HandlePtr->kDitherSetting << \
	  (uint32_t)CCU4_CC4_TC_DITHE_Pos) & (uint32_t)CCU4_CC4_TC_DITHE_Msk ;
    
    WR_REG(HandlePtr->CC4yRegsPtr->DITS,(uint32_t)CCU4_CC4_DITS_DCVS_Msk,\
      (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

    /*Configure Trap mode as per GUI*/
    if(HandlePtr->kTimerConcatenation != (uint8_t)SET)
    {
      /*<<<DD_PWMSP001_API_1_6>>>*/
      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,
          (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

      WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,
          (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);
      
	  WR_REG(HandlePtr->CC4yRegsPtr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk, \
		  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);
    }
    /*Set the prescalar divider and passive level of the o/p signal.*/
    WR_REG(HandlePtr->CC4yRegsPtr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk,\
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);
    HandlePtr->CC4yRegsPtr->PSL = HandlePtr->kPassiveLevel;

    /*<<<DD_PWMSP001_API_1_7>>>*/
    /*Setting period register's value*/
    HandlePtr->CC4yRegsPtr->PRS = (uint32_t)(HandlePtr->kPeriodVal & 0xFFFFU);
    /*Setting compare register's value*/
    HandlePtr->CC4yRegsPtr->CRS = (uint32_t)(HandlePtr->kCompareValue & 0xFFFFU);
    HandlePtr->CC4yRegsPtr->SWR |= PWMSP001_ALL_CCU4_INTR_CLEAR;

    /*Applying register's settings for the second slice if timer concatenation
     * is set */
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      PWMSP001_lConfigureSecondSlice(HandlePtr);
      HandlePtr->CC4yRegs1Ptr->INTE |= HandlePtr->InterruptControl;

    } /*End of if (HandlePtr->kTimerConcatenation == SET)*/
    else
    {
      HandlePtr->CC4yRegsPtr->INTE |= HandlePtr->InterruptControl;
    }
    
    
    /*Request SW shadow transfer for period, compare, dither and prescalar level*/
    HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)1 << ((uint32_t)4 * \
	  (uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 <<(((uint32_t)4 * \
	    (uint32_t)HandlePtr->FirstSlice) + (uint32_t)1))| ((uint32_t)1 << \
		  (((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice) + (uint32_t)2)));

    Status = (uint32_t)DAVEApp_SUCCESS;
    HandlePtr->DynamicDataType->StateType = PWMSP001_INITIALIZED;
  } while (0);

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
}

/*<<<DD_PWMSP001_API_2>>>*/
/* This function de-initializes the app */
status_t PWMSP001_Deinit(const PWMSP001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp1;
  uint32_t Temp2;
  uint32_t Temp3;
  uint32_t Temp4;

     /*<<<DD_PWMSP001_API_2_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
    {
    /*<<<DD_PWMSP001_API_2_3>>>*/
    HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
    HandlePtr->CC4yRegsPtr->INTE = 0x00U;

    /*Set IDLE mode for selected slice*/
    HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)1<< ((uint32_t)CCU4_GIDLS_SS0I_Pos \
	  +(uint32_t)HandlePtr->FirstSlice)) | ((uint32_t)1 << (uint32_t)CCU4_GIDLS_CPRB_Pos)\
	    |((uint32_t)1 << (uint32_t)CCU4_GIDLS_PSIC_Pos));

    /*Clear all the registers*/
    HandlePtr->CC4yRegsPtr->INS = 0x00U;
    HandlePtr->CC4yRegsPtr->CMC = 0x00U;
    HandlePtr->CC4yRegsPtr->TC = 0x00U;
    HandlePtr->CC4yRegsPtr->PSC = 0x00U;
    HandlePtr->CC4yRegsPtr->PSL = 0x00U;
    HandlePtr->CC4yRegsPtr->DITS = 0x00U;
    HandlePtr->CC4yRegsPtr->CRS = 0x00U;
    HandlePtr->CC4yRegsPtr->PRS = 0x00U;

    /*<<<DD_PWMSP001_API_2_2>>>*/
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      /*<<<DD_PWMSP001_API_2_3>>>*/
      HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;
      HandlePtr->CC4yRegs1Ptr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
      HandlePtr->CC4yRegs1Ptr->INTE = 0x00U;

      /*Set IDLE mode for selected slice*/
      Temp4 = ((uint32_t)0x01 << (uint32_t)CCU4_GIDLS_PSIC_Pos);
      Temp3 = ((uint32_t)0x01 << CCU4_GIDLS_CPRB_Pos);
      Temp2 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);
      Temp1 = Temp3 | Temp4;
      HandlePtr->CC4yKernRegsPtr->GIDLS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | Temp1);
      /*   Temp3 | Temp4 ); */

      /*Clear all the registers*/
      HandlePtr->CC4yRegs1Ptr->INS = 0x00U;
      HandlePtr->CC4yRegs1Ptr->CMC = 0x00U;
      HandlePtr->CC4yRegs1Ptr->TC = 0x00U;
      HandlePtr->CC4yRegs1Ptr->PSC = 0x00U;
      HandlePtr->CC4yRegs1Ptr->PSL = 0x00U;
      HandlePtr->CC4yRegs1Ptr->DITS = 0x00U;
      HandlePtr->CC4yRegs1Ptr->CRS = 0x00U;
      HandlePtr->CC4yRegs1Ptr->PRS = 0x00U;
    }/*End of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/

    HandlePtr->DynamicDataType->StateType = PWMSP001_UNINITIALIZED;

    Status = (uint32_t)DAVEApp_SUCCESS;
  }

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
}

/*<<<DD_PWMSP001_API_3>>>*/
/* This function starts the app. 
 * This needs to be called even if external start is configured.*/
status_t PWMSP001_Start(const PWMSP001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  do
  {
    /*<<<DD_PWMSP001_API_3_1>>>*/
    if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
        (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))
    {
      DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
      break;
    }

    HandlePtr->CC4yRegsPtr->SWR = PWMSP001_ALL_CCU4_INTR_CLEAR;
    
    /*<<<DD_PWMSP001_API_3_2>>>*/
	HandlePtr->CC4yKernRegsPtr->GIDLC |=
		(((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->FirstSlice)) );
	if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
	{
	  HandlePtr->CC4yKernRegsPtr->GIDLC |=
		  ((uint32_t)1 << ((uint32_t)CCU4_GIDLC_CS0I_Pos + \
			(uint32_t)HandlePtr->SecondSlice));
	} /*End if (HandlePtr->kTimerConcatenation == SET)*/
	
    /*Set run bit of slices if external start is not configured*/
    if (HandlePtr->kExtStartTrig == (uint8_t)RESET)
    {
      HandlePtr->CC4yRegsPtr->TCSET |= (uint32_t)1;
      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      {
        HandlePtr->CC4yRegs1Ptr->TCSET |= (uint32_t)1;
      }
    }/*End of  if (HandlePtr->kExtStartTrig == (uint8_t)RESET)*/
    else
    {
      /*<<<DD_PWMSP001_API_1_2>>>*/
      if (HandlePtr->kExtStartTrig == (uint8_t)SET)
      {
        HandlePtr->CC4yRegsPtr->INS &= ~((uint32_t)CCU4_CC4_INS_EV0EM_Msk | \
		  (uint32_t)CCU4_CC4_INS_LPF0M_Msk);
        HandlePtr->CC4yRegsPtr->CMC &= ~(uint32_t)CCU4_CC4_CMC_STRTS_Msk;
        HandlePtr->CC4yRegsPtr->INS |=
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF   << \
                (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));
        HandlePtr->CC4yRegsPtr->CMC |= (((uint32_t)PWMSP001_EVENT_0  <<
            (uint32_t)CCU4_CC4_CMC_STRTS_Pos)& (uint32_t)CCU4_CC4_CMC_STRTS_Msk);
      }/*End of if (HandlePtr->kExtStartTrig == (uint8_t)SET)*/
      /*<<<DD_PWMSP001_nonAPI_1_2>>>*/
      if ((HandlePtr->kExtStartTrig == (uint8_t)SET) &&\
          (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      )
      {
        HandlePtr->CC4yRegs1Ptr->INS &= (uint32_t)~(CCU4_CC4_INS_EV0EM_Msk | CCU4_CC4_INS_LPF0M_Msk);
        HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_STRTS_Msk);
        HandlePtr->CC4yRegs1Ptr->INS |=
            ((((uint32_t)HandlePtr->kStartEdge  << (uint32_t)CCU4_CC4_INS_EV0EM_Pos)& \
			  (uint32_t)CCU4_CC4_INS_EV0EM_Msk) | (((uint32_t)PWMSP001_LPF  <<
                    (uint32_t)CCU4_CC4_INS_LPF0M_Pos)& (uint32_t)CCU4_CC4_INS_LPF0M_Msk));
        HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_0  << \
		  (uint32_t)CCU4_CC4_CMC_STRTS_Pos) & (uint32_t)CCU4_CC4_CMC_STRTS_Msk);
      }/*End of if (HandlePtr->kExtStartTrig == SET)*/
    }

    HandlePtr->DynamicDataType->StateType = PWMSP001_RUNNING;
    Status = (uint32_t)DAVEApp_SUCCESS;
  } while (0);
  return Status;
}

/*<<<DD_PWMSP001_API_4>>>*/
/* This function stops the app */
status_t PWMSP001_Stop(const PWMSP001_HandleType* HandlePtr)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp1;
  uint32_t Temp2;
  
  do
  {
    /*<<<DD_PWMSP001_API_4_1>>>*/
    if (HandlePtr->DynamicDataType->StateType != PWMSP001_RUNNING)
    {
      break;
    }
    else
    {
      Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->FirstSlice);
      Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);
      HandlePtr->CC4yRegsPtr->TCCLR = PWMSP001_SLICE_CLEAR;
      HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1 ) | Temp2 );

      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      {
        HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;
        Temp1 = ((uint32_t)CCU4_GIDLS_SS0I_Pos + (uint32_t)HandlePtr->SecondSlice);
        Temp2 = ((uint32_t)0x01 << CCU4_GIDLS_PSIC_Pos);
        HandlePtr->CC4yKernRegsPtr->GIDLS |= (((uint32_t)0x01 << Temp1) | Temp2 );
      }/*End of  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/

      HandlePtr->DynamicDataType->StateType = PWMSP001_STOPPED;
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
  } while (0);

  if (Status != (uint32_t)DAVEApp_SUCCESS)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  return Status;
}

/*<<<DD_PWMSP001_API_5>>>*/
/* This function changes the duty cycle of the PWM by changing the compare register value. */
status_t PWMSP001_SetCompare
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Compare
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t period;

  if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
	  period=(uint32_t)(((uint32_t)HandlePtr->CC4yRegs1Ptr->PRS<<16U)|(uint32_t)HandlePtr->CC4yRegsPtr->PRS);
  else
	  period=(uint32_t)HandlePtr->CC4yRegsPtr->PRS;

  /*<<<DD_PWMSP001_API_5_1>>>*/
  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
  {
    if ((Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
        (HandlePtr->kTimerConcatenation == (uint8_t)RESET))
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    else
    {
      /*if compare value is greater or equal to the period value, output should be with 0% dutycycle.
	  Since setting exact period value will create the spikes,we are adding 1 and setting to the register*/
	  if (Compare >= (uint32_t)period)
	  {
		  Compare = (uint32_t)period + 1U;
	  }
      /* Call function as per the configured mode */
      HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);
      Status = (uint32_t)DAVEApp_SUCCESS;
    }
  }
  return Status;
}

/*
 * This function is used to change the compare register value 
 * in edge-aligned mode.
 */
void PWMSP001_lSetCompareEdgeAlign
(
    void* Handle,
    uint32_t Compare
)
{
  uint32_t Temp1;
  uint32_t Temp2;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);
  
  /* Request shadow transfer */
  Temp2 = (4U*(uint32_t)HandlePtr->FirstSlice);
  Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + Temp2;
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
}

/*
 * This function is used to change the compare register value 
 * in edge-aligned timer concatenation mode.
 */
void PWMSP001_lSetCompareEdgeAlignTimerConcat
(
    void* Handle,
    uint32_t Compare
)
{
  uint32_t FirstSliceCompareVal = 0x00U;
  uint32_t SecondSliceCompareVal = 0x00U;
  uint32_t Temp1;
  uint32_t Temp2;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  /**
   * In case of timer concatenation, compare register value is divided by
   * period register value of the first slice. Remainder is written in
   * compare register of first slice and quotient is written in compare
   * register of second slice.
   * This is done to achieve compare register value of first slice
   * to be less than period register value.
   */
  FirstSliceCompareVal = (uint32_t)Compare % \
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
  SecondSliceCompareVal = (uint32_t)Compare /
      (uint16_t)HandlePtr->CC4yRegsPtr->PRS;
  
  HandlePtr->CC4yRegsPtr->CRS = (FirstSliceCompareVal & 0xFFFFU);
  HandlePtr->CC4yRegs1Ptr->CRS = (SecondSliceCompareVal & 0xFFFFU);
  /* Request shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));
  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 << Temp2 ) | ((uint32_t)0x01 << Temp1));
}

/*
 * This function is used to change the compare register value 
 * in center-aligned mode.
 */
void PWMSP001_lSetCompareCenterAlign
(
    void* Handle,
    uint32_t Compare
)
{
  uint32_t Temp1;
  /*<<<DD_PWMSP001_API_5_3>>>*/
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  HandlePtr->CC4yRegsPtr->CRS = (Compare & 0xFFFFU);
  
  /* Request shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U*(uint32_t)HandlePtr->FirstSlice));
  HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
}


/*
 * This function is used to change the duty cycle of the PWM waveform
 */
/*<<<DD_PWMSP001_API_15>>>*/
status_t PWMSP001_SetDutyCycle
(
    const PWMSP001_HandleType* HandlePtr,
    float Duty
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if ( HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED)
  {
  if((Duty > (float)100) || ((float)Duty < (float)0))
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
  }
  else
  {
    /* Call the function as per configured mode */
    HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  }
  return (Status);
}

/*
 * This function is used to change the duty cycle of the PWM waveform
 * in edge-aligned mode
 */
void PWMSP001_lSetDutyEdgeAlign
(
    void* Handle,
    float Duty
)
{
  uint32_t FirstSliceCompareVal = (uint32_t)0;
  uint32_t Temp1;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  fDuty = Duty;
  
  /*<<<DD_PWMSP001_API_15_3>>>*/
  
  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)((uint32_t)HandlePtr->CC4yRegsPtr->PRS + 1U);
  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);
  HandlePtr->CC4yRegsPtr->CRS = FirstSliceCompareVal  & 0xFFFFU;
  
  /*Shadow transfer */
  Temp1 =  ((uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 *(uint32_t)HandlePtr->FirstSlice));
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
  /*Update dynamic handle */
}

/*
 * This function is used to change the duty cycle of the PWM waveform
 * in edge-aligned timer concatenation mode
 */
void PWMSP001_lSetDutyEdgeAlignTimerConcat
(
    void* Handle,
    float Duty
)
{
  uint32_t Compare = (uint32_t)0;
  uint32_t FirstSliceCompareVal = (uint32_t)0;
  uint32_t SecondSliceCompareVal = (uint32_t)0;
  uint32_t Temp2;
  uint32_t Temp3;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  
  fDuty = Duty;
  /*<<<DD_PWMSP001_API_15_4>>>*/
  /* Find the compare register value from the duty cycle and period register value */
  Compare =(uint32_t)HandlePtr->CC4yRegs1Ptr->PRS + 1U;
  Compare *= ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U); 
  Compare +=  (uint32_t)1;
  
  fDuty = ((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)(Compare);
  Compare = (uint32_t)( fPRS * fDuty);

  FirstSliceCompareVal =(uint32_t)
                    ((uint32_t)Compare % ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;
  SecondSliceCompareVal = (uint32_t)
                    ((uint32_t)Compare / ((uint32_t)((uint32_t)HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU)));
  HandlePtr->CC4yRegs1Ptr->CRS = (uint32_t)SecondSliceCompareVal  & 0xFFFFU;

  /** shadow transfer */
  Temp2 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
  Temp3 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice));
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)1 << (uint32_t)Temp2 ) | ((uint32_t)1 << (uint32_t)Temp3));
}

/*
 * This function is used to change the duty cycle of the PWM waveform
 * in center-aligned mode
 */
void PWMSP001_lSetDutyCenterAlign
(
    void* Handle,
    float Duty
)
{
  /*<<<DD_PWMSP001_API_15_5>>>*/
  uint32_t FirstSliceCompareVal = (uint32_t)0x00;
  uint32_t Temp1;
  float fDuty, fPRS ;
  PWMSP001_HandleType* HandlePtr = (PWMSP001_HandleType*)Handle;
  fDuty = Duty;

  fDuty = (float)((float)100.00 - (float)fDuty)/(float)100.00;
  fPRS = (float)HandlePtr->CC4yRegsPtr->PRS;
  FirstSliceCompareVal = (uint32_t)( fPRS * fDuty);
  HandlePtr->CC4yRegsPtr->CRS = (uint32_t)FirstSliceCompareVal  & 0xFFFFU;

  /*shadow transfer */
  Temp1 = ((uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice));
  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)((uint32_t)0x01 << (uint32_t)Temp1);
}


/*
 * This function changes the PWM frequency and duty cycle. 
 * Input parameters are in terms of period and compare register
 */
status_t PWMSP001_SetPeriodAndCompare
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Period,
    uint32_t Compare
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t PeriodVal = 0UL;
  /*<<<DD_PWMSP001_API_6_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
  {
   if((Period == (uint32_t)0) || (((uint32_t)Compare > (uint32_t)HandlePtr->kMaxPeriodVal) &&
       (HandlePtr->kTimerConcatenation == (uint8_t)RESET)))
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    else
    {
      if ((Period > (uint32_t)HandlePtr->kMaxPeriodVal)&&\
          ((HandlePtr->kTimerConcatenation != (uint8_t)SET))
          )
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
      }
      else
      {
        PeriodVal = Period;
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
        {
          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);
        }
        /*<<<DD_PWMSP001_API_6_3>>>*/
        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);
        /* Call function as per the configured mode */
        HandlePtr->SetCompareFuncPtr((const void*)HandlePtr, Compare);
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
    }
  }
  return Status;
}

/*<<<DD_PWMSP001_API_6>>>*/
/*
 * This function changes the PWM frequency. Input parameter is the period register value
 */
status_t PWMSP001_SetPeriod
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t Period
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t PeriodVal = 0X00U;
  uint32_t Temp1;
  
  /*<<<DD_PWMSP001_API_6_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
  {
    if(Period == (uint32_t)0)
    {
      Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    else
    {
      if((Period > (uint32_t)HandlePtr->kMaxPeriodVal) &&\
         (HandlePtr->kTimerConcatenation != (uint8_t)SET))
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
      }
      else
      {
        PeriodVal = Period;
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
        {
          HandlePtr->CC4yRegs1Ptr->PRS = ((PeriodVal & 0xFFFF0000U) >> 16U);
        }
        HandlePtr->CC4yRegsPtr->PRS = (PeriodVal & 0xFFFFU);
        /*Request shadow transfer for the First slice*/
        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);
        HandlePtr->CC4yKernRegsPtr->GCSS |=	((uint32_t)0x01 << Temp1);
        if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
        {
          /*Request shadow transfer for the First slice*/
          Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);
          HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1);
        }/*End Of if (HandlePtr->kTimerConcatenation == (uint8_t)SET)*/
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
    }
  }
  return Status;
}


/*
 * This function changes the PWM frequency and duty cycle. 
 * Input parameters are in terms of the frequency in hertz and duty in %.
 */
status_t PWMSP001_SetPwmFreqAndDutyCycle
(
    const PWMSP001_HandleType* HandlePtr,
    float PwmFreq,
    float Duty
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t PwmTime = 0UL;
  float fPwmFreq ;
  /*<<<DD_PWMSP001_API_16_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
  {
  if((PwmFreq == (float)0) || (Duty > (float)100) || (Duty < (float)0))
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
  }
  else
  {
      fPwmFreq=(float)HandlePtr->kResolution;
	  fPwmFreq=(float)fPwmFreq*PwmFreq;
	  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);
    /*<<<DD_PWMSP001_API_16_2>>>*/
    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)
    {
      if(PwmTime > PWMSP001_MAX_VALUE)
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
      }
      else
      {
        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)
        {
          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;
        }
        else
        {
          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;
        }
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
    }
    else if((HandlePtr->kTimerConcatenation == (uint8_t)SET) &&\
    		                                   (PwmTime <= PWMSP001_MAX_VALUE))
    {
    	Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
    }
    /*<<<DD_PWMSP001_API_16_3>>>*/
    else
    {
      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);
    }
    if(Status == (uint32_t)DAVEApp_SUCCESS)
    {
     /* Call the function as per configured mode */
     HandlePtr->SetDutyFuncPtr((const void*)HandlePtr, Duty);
    }
   }
  }
  return (Status);
}


/*<<<DD_PWMSP001_API_16>>>*/
/*
 * This function changes the PWM frequency. Input parameter is the frequency value
 */
status_t PWMSP001_SetPwmFreq
(
    const PWMSP001_HandleType* HandlePtr,
    float PwmFreq
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t PwmTime = 0x00U;
  uint32_t Temp1;
  uint32_t Temp2;
  uint32_t Temp3;
  float fPwmFreq ;
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_UNINITIALIZED))
  {
  if(PwmFreq == (float)0)
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
  }
  else
  {
	  fPwmFreq=(float)HandlePtr->kResolution;
	  fPwmFreq=(float)fPwmFreq*PwmFreq;
	  PwmTime = (uint32_t)((float)1000000000.00 / fPwmFreq);
    /*<<<DD_PWMSP001_API_16_2>>>*/
    if(HandlePtr->kTimerConcatenation == (uint8_t)RESET)
    {
      if(PwmTime > PWMSP001_MAX_VALUE)
      {
        Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
      }
      else
      {
        if(HandlePtr->CountingModeType == PWMSP001_EDGE_ALIGNED)
        {
          HandlePtr->CC4yRegsPtr->PRS = PwmTime -(uint32_t)1;
        }
        else
        {
          HandlePtr->CC4yRegsPtr->PRS = (PwmTime - (uint32_t)1) >> (uint32_t)1;
        }
        /** Update dynamic handle*/
        Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->FirstSlice); 
        HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp1 );
        Status = (uint32_t)DAVEApp_SUCCESS;
      }
    }
    /*<<<DD_PWMSP001_API_16_3>>>*/
    else
    {
      Status = PWMSP001_lSetPwmFreqTimerConcat(HandlePtr, PwmTime);
      if(Status == (uint32_t)DAVEApp_SUCCESS)
      {
        Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);
        Temp3 = (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->SecondSlice);
        HandlePtr->CC4yKernRegsPtr->GCSS |= (((uint32_t)0x01 << Temp2) | \
            ((uint32_t)0x01 << Temp3));
      }
    }
  }
 }
  return (Status);
}

/*
 * This function is used to set the PWM frequency in case of timer concatenation mode.
 */
status_t PWMSP001_lSetPwmFreqTimerConcat
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t PwmTime
)
{
  uint32_t PeriodVal = PwmTime;
  uint32_t MsbPeriodVal, LsbPeriodVal;
  uint8_t Count = 0x00U;
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if(PwmTime >= PWMSP001_TC_MAX_VALUE)
  {
    Status = (uint32_t)PWMSP001_INVALID_PARAM_ERROR;
  }

  else
  {

    if(PwmTime > PWMSP001_MAX_VALUE)
    {
      do
      {
        PeriodVal = PeriodVal >> 1;
        Count++;
      }while(PeriodVal >= PWMSP001_MAX_VALUE);

      MsbPeriodVal = ((uint32_t)1 << Count) -(uint32_t)1;
      LsbPeriodVal = PeriodVal;
    }
    else
    {
      LsbPeriodVal = PwmTime;
      MsbPeriodVal = (uint32_t)0x00;
    }

    /*<<<DD_PWMSP001_API_16_4>>>*/
    if(HandlePtr->CountingModeType == PWMSP001_CENTER_ALIGNED)
    {
      MsbPeriodVal = MsbPeriodVal >> (uint32_t)1;
      LsbPeriodVal = LsbPeriodVal >> (uint32_t)1;
    }

    HandlePtr->CC4yRegsPtr->PRS = LsbPeriodVal & 0xFFFFU;
    HandlePtr->CC4yRegs1Ptr->PRS =MsbPeriodVal & 0xFFFFU;

    /*<<<DD_PWMSP001_API_16_5>>>*/
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}



/*<<<DD_PWMSP001_API_7>>>*/
/*
 * This function sets the timer value.
 */
status_t PWMSP001_SetTimerVal
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t TimerVal
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  /*<<<DD_PWMSP001_API_7_1>>>*/
  if ((HandlePtr->DynamicDataType->StateType != PWMSP001_INITIALIZED) &&
      (HandlePtr->DynamicDataType->StateType != PWMSP001_STOPPED))
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_7_1>>>*/
  else
  {
    HandlePtr->CC4yRegsPtr->TIMER = (uint32_t)TimerVal&0xFFFFU;
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      HandlePtr->CC4yRegs1Ptr->TIMER = (uint32_t)((uint32_t)TimerVal>>16U)&0xFFFFU;
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return Status;
}

/*<<<DD_PWMSP001_API_8>>>*/
/*
 * This function returns the timer status - Running or Idle
 */
status_t PWMSP001_GetTimerStatus
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t* TimerStatus
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t SecondTimerStatus = (uint32_t)0;
  /*<<<DD_PWMSP001_API_8_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_8_2>>>*/
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      SecondTimerStatus = (uint32_t)(RD_REG(HandlePtr->CC4yRegs1Ptr->TCST,
          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos));
      *TimerStatus = (uint32_t)((RD_REG(HandlePtr->CC4yRegsPtr->TCST,
          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos)) &
          SecondTimerStatus
      );
    }
    else
    {
      *TimerStatus = (uint32_t) RD_REG(HandlePtr->CC4yRegsPtr->TCST,
          CCU4_CC4_TCST_TRB_Msk, CCU4_CC4_TCST_TRB_Pos);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return Status; 
}

/*<<<DD_PWMSP001_API_9>>>*/
/*
 * This function returns the timer registers.
 */
status_t PWMSP001_GetTimerRegsVal
(
    const PWMSP001_HandleType* HandlePtr,
    PWMSP001_TimerRegsType* TimerRegs
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t ScndSlTMRVal = 0UL;

  /*<<<DD_PWMSP001_API_9_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_9_2>>>*/
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      ScndSlTMRVal = (RD_REG(HandlePtr->CC4yRegs1Ptr->TIMER,
          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos) << 16UL);

      TimerRegs->TimerReg = (uint32_t)(ScndSlTMRVal |
          (RD_REG(HandlePtr->CC4yRegsPtr->TIMER,
              CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos)));

      TimerRegs->CompReg = HandlePtr->CC4yRegs1Ptr->CRS; 
      TimerRegs->CompReg*= HandlePtr->CC4yRegsPtr->PRS;
      TimerRegs->CompReg += HandlePtr->CC4yRegsPtr->CRS;
      TimerRegs->PeriodReg = HandlePtr->CC4yRegs1Ptr->PRS+ 1U;
      TimerRegs->PeriodReg *= (uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);
      TimerRegs->PeriodReg += 1U ;
    }

    else
    {
      TimerRegs->TimerReg = (uint32_t)RD_REG(HandlePtr->CC4yRegsPtr->TIMER,
          CCU4_CC4_TIMER_TVAL_Msk, CCU4_CC4_TIMER_TVAL_Pos);

      TimerRegs->CompReg = HandlePtr->CC4yRegsPtr->CRS;
      TimerRegs->PeriodReg = HandlePtr->CC4yRegsPtr->PRS;

    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return Status;
}

/*<<<DD_PWMSP001_API_15>>>*/
/*
 * This function returns the period register value
 */
status_t PWMSP001_GetPeriodReg
(
    const PWMSP001_HandleType* HandlePtr,
    uint32_t* PeriodReg
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  /*<<<DD_PWMSP001_API_15_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
	DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      *PeriodReg = (HandlePtr->CC4yRegs1Ptr->PRS + 1U);
      *PeriodReg  *=(uint32_t)((HandlePtr->CC4yRegsPtr->PRS & 0xFFFFU) +1U);
      *PeriodReg  += 1U;
    }
    else
    {
      *PeriodReg = HandlePtr->CC4yRegsPtr->PRS;
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return Status;
}

/*<<<DD_PWMSP001_API_10>>>*/
/*
 * This functions enables the shadow transfer of compare and period register values
 */
status_t PWMSP001_SWRequestShadowTransfer
(
    const PWMSP001_HandleType* HandlePtr
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
  uint32_t Temp1;
  uint32_t Temp2;
  uint32_t Temp3;

  /*<<<DD_PWMSP001_API_10_1>>>*/
  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  /*<<<DD_PWMSP001_API_10_2>>>*/
  else
  {
    /*Request shadow transfer for the First Slice*/
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      /*Request shadow transfer for the Second Slice*/
      Temp1 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4 * (uint32_t)HandlePtr->FirstSlice);
      Temp2 = (uint32_t)CCU4_GCSS_S0SE_Pos + ((uint32_t)4*(uint32_t)HandlePtr->SecondSlice);
      HandlePtr->CC4yKernRegsPtr->GCSS |=  ((uint32_t)0x01 << Temp1) | ((uint32_t)0x01 << Temp2);
    }
    else
    {
      Temp3 =  (uint32_t)CCU4_GCSS_S0SE_Pos + (4U * (uint32_t)HandlePtr->FirstSlice);
      HandlePtr->CC4yKernRegsPtr->GCSS |= ((uint32_t)0x01 << Temp3);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return Status;
}

/*<<<DD_PWMSP001_API_13>>>*/
/*
 * This function resets the trap flag if trap condition is inactive
 */
void PWMSP001_ResetTrapFlag(const PWMSP001_HandleType* HandlePtr)
{
   if (HandlePtr->kTrapExitControl == (uint8_t)SET)
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_EVENT2_INTERRUPT);
      if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
      {
        SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_EVENT2_INTERRUPT);
      }
    }
    SET_BIT(HandlePtr->CC4yRegsPtr->SWR, PWMSP001_TRAP_FLAG_CLEAR);
    if (HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR, PWMSP001_TRAP_FLAG_CLEAR);
    }
}

/*<<<DD_PWMSP001_nonAPI_1>>>*/
/*
 * This function configures second slice.
 */

void PWMSP001_lConfigureSecondSlice(const PWMSP001_HandleType* HandlePtr)
{
  HandlePtr->CC4yRegs1Ptr->TCCLR = PWMSP001_SLICE_CLEAR;

  /*Set period and compare values for second slice*/
  HandlePtr->CC4yRegs1Ptr->PRS = (uint32_t)((HandlePtr->kPeriodVal & 0xFFFF0000U)
      >> 16U);
  HandlePtr->CC4yRegs1Ptr->CRS =(uint32_t)((HandlePtr->kCompareValue & 0xFFFF0000U)
      >> 16U);

  HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TCE_Pos);

  /*<<<DD_PWMSP001_nonAPI_1_3>>>*/
  if (HandlePtr->kExtStopTrig == (uint8_t)SET)
  {
    HandlePtr->CC4yRegs1Ptr->INS &=(uint32_t) ~(CCU4_CC4_INS_EV1EM_Msk | (uint32_t)CCU4_CC4_INS_LPF1M_Msk);
    HandlePtr->CC4yRegs1Ptr->CMC &=(uint32_t) ~(CCU4_CC4_CMC_ENDS_Msk);
    HandlePtr->CC4yRegs1Ptr->INS |=(uint32_t)((((uint32_t)HandlePtr->kStopEdge  <<   \
      (uint32_t)CCU4_CC4_INS_EV1EM_Pos)& (uint32_t)CCU4_CC4_INS_EV1EM_Msk) | \
	    (((uint32_t)PWMSP001_LPF << (uint32_t)CCU4_CC4_INS_LPF1M_Pos)& \
		  (uint32_t)CCU4_CC4_INS_LPF1M_Msk));
    HandlePtr->CC4yRegs1Ptr->CMC |= (((uint32_t)PWMSP001_EVENT_1  <<  \
      (uint32_t)CCU4_CC4_CMC_ENDS_Pos)& (uint32_t)CCU4_CC4_CMC_ENDS_Msk);
  }/*End of if (HandlePtr->kExtStopTrig == SET)*/

  /*<<<DD_PWMSP001_nonAPI_1_4>>>*/
  if (HandlePtr->kTrapEnable == (uint8_t)SET)
  {
    HandlePtr->CC4yRegs1Ptr -> INS &=(uint32_t) ~(CCU4_CC4_INS_EV2EM_Msk | CCU4_CC4_INS_EV2LM_Msk 
        | CCU4_CC4_INS_LPF2M_Msk);
    HandlePtr->CC4yRegs1Ptr->CMC &= (uint32_t)~(CCU4_CC4_CMC_TS_Msk);
    HandlePtr->CC4yRegs1Ptr -> INS |= (uint32_t) \
        ((((uint32_t)0x00 << CCU4_CC4_INS_EV2EM_Pos)& (uint32_t)CCU4_CC4_INS_EV2EM_Msk) | \
            ((((uint32_t)HandlePtr->kTrapLevel  <<	\
                CCU4_CC4_INS_EV2LM_Pos)& (uint32_t)CCU4_CC4_INS_EV2LM_Msk) | (((uint32_t)0x00  << \
                    CCU4_CC4_INS_LPF2M_Pos)& (uint32_t)CCU4_CC4_INS_LPF2M_Msk)));
    HandlePtr->CC4yRegs1Ptr->CMC |= ((uint32_t)0x01 << (uint32_t)CCU4_CC4_CMC_TS_Pos);
  }/*End of if (HandlePtr->kTrapEnable == SET)*/

  HandlePtr->CC4yRegs1Ptr->TC &=(uint32_t) ~(CCU4_CC4_TC_TCM_Msk | CCU4_CC4_TC_TSSM_Msk
      | CCU4_CC4_TC_CMOD_Msk | CCU4_CC4_TC_STRM_Msk | CCU4_CC4_TC_ENDM_Msk
      | CCU4_CC4_TC_DITHE_Msk);
  HandlePtr->CC4yRegs1Ptr->TC =	(((uint32_t)HandlePtr->CountingModeType  << \
    (uint32_t)CCU4_CC4_TC_TCM_Pos)& (uint32_t)CCU4_CC4_TC_TCM_Msk)|	\
      (((uint32_t)HandlePtr->kTimerMode  << (uint32_t)CCU4_CC4_TC_TSSM_Pos)& \
	    (uint32_t)CCU4_CC4_TC_TSSM_Msk)|(((uint32_t)PWMSP001_COMPARE_MODE  << \
		  (uint32_t)CCU4_CC4_TC_CMOD_Pos)& (uint32_t)CCU4_CC4_TC_CMOD_Msk)| \
            (((uint32_t)HandlePtr->ExtStartConfigType << (uint32_t)CCU4_CC4_TC_STRM_Pos)\
			  &(uint32_t)CCU4_CC4_TC_STRM_Msk)| (((uint32_t)HandlePtr->ExtStopConfigType <<	\
                (uint32_t)CCU4_CC4_TC_ENDM_Pos)& (uint32_t)CCU4_CC4_TC_ENDM_Msk);

  /*<<<DD_PWMSP001_API_non1_5>>>*/
  HandlePtr->CC4yRegs1Ptr->TC |= ((uint32_t)HandlePtr->kDitherSetting << (uint32_t)CCU4_CC4_TC_DITHE_Pos)\
    &(uint32_t)CCU4_CC4_TC_DITHE_Msk;
  WR_REG(HandlePtr->CC4yRegs1Ptr->DITS, (uint32_t)CCU4_CC4_DITS_DCVS_Msk, \
    (uint32_t)CCU4_CC4_DITS_DCVS_Pos, HandlePtr->kDitherCompare);

  /*<<<DD_PWMSP001_API_non1_6>>>*/
  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSE_Msk,
      (uint32_t)CCU4_CC4_TC_TRPSE_Pos, HandlePtr->kTrapSync);

  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRPSW_Msk,
      (uint32_t)CCU4_CC4_TC_TRPSW_Pos, HandlePtr->kTrapExitControl);

  WR_REG(HandlePtr->CC4yRegs1Ptr->TC, (uint32_t)CCU4_CC4_TC_TRAPE_Msk,\
	  (uint32_t)CCU4_CC4_TC_TRAPE_Pos, HandlePtr->kTrapEnable);
  
  WR_REG(HandlePtr->CC4yRegs1Ptr->PSC, (uint32_t)CCU4_CC4_PSC_PSIV_Msk, 
      (uint32_t)CCU4_CC4_PSC_PSIV_Pos, HandlePtr->kCCUPrescalar);

  HandlePtr->CC4yRegs1Ptr->PSL = HandlePtr->kPassiveLevel;

  HandlePtr->CC4yKernRegsPtr->GCSS |= (uint32_t)(((uint32_t)0x01 <<	\
      ((uint32_t)4 * (uint32_t)HandlePtr->SecondSlice)) |	\
      ((uint32_t)0x01 << (((uint32_t)4 * \
	    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)1)) |\
          (uint32_t)((uint32_t)0x01 << (((uint32_t)4 * \
		    (uint32_t)HandlePtr->SecondSlice) + (uint32_t)2)));
}

/**
 * This function sets the enable event bit for the event given in the argument.
 */
status_t PWMSP001_EnableEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}

/**
 * This function clears the enable event bit for the event given in the argument.
 */
status_t PWMSP001_DisableEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      CLR_BIT(HandlePtr->CC4yRegs1Ptr->INTE,(uint8_t) Event);
    }
    else
    {
      CLR_BIT(HandlePtr->CC4yRegsPtr->INTE,(uint8_t) Event);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}

/**
 * This function clears the interrupt by software.
 */
status_t PWMSP001_ClearPendingEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
  status_t Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWR,(uint8_t) Event);
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWR, (uint8_t)Event);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}

/**
 * This function sets the interrupt by software Interrupt pulse is generated
 * if source is enabled.
 */
status_t PWMSP001_SetPendingEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {
      SET_BIT(HandlePtr->CC4yRegs1Ptr->SWS,(uint8_t)Event);
    }
    else
    {
      SET_BIT(HandlePtr->CC4yRegsPtr->SWS, (uint8_t)Event);
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}

/**
 * This function check whether given interrupt is set
 */
status_t PWMSP001_GetPendingEvent
(
    const PWMSP001_HandleType * HandlePtr,
    const PWMSP001_EventNameType Event,
    uint8_t*EvtStatus
)
{
  status_t Status = (uint32_t)PWMSP001_OPER_NOT_ALLOWED_ERROR;

  if (HandlePtr->DynamicDataType->StateType == PWMSP001_UNINITIALIZED)
  {
    Status =(uint32_t) PWMSP001_OPER_NOT_ALLOWED_ERROR;
    DBG002_INFO(APP_GID, DBG002_MESSAGEID_LITERAL, PWMSP001_STATUS_LEN, &Status);
  }
  else
  {
    if(HandlePtr->kTimerConcatenation == (uint8_t)SET)
    {

      if(RD_REG(HandlePtr->CC4yRegs1Ptr->INTS, ((uint32_t)0x01 <<(uint32_t)Event), (uint32_t)Event))
	  {
	      *EvtStatus = (uint8_t)SET;
	  }
	  else
	  {
	      *EvtStatus = (uint8_t)RESET;
	  }
    }
    else
    {
      if(RD_REG(HandlePtr->CC4yRegsPtr->INTS, ((uint32_t)0x01 << (uint32_t)Event),(uint32_t)Event))
      {
        *EvtStatus = (uint8_t)SET;
      }
      else
      {
        *EvtStatus = (uint8_t)RESET;
      }
      /* *EvtStatus = RD_REG(HandlePtr->CC4yRegsPtr->INTS, (0x01 << (uint8_t)Event),(uint8_t) Event)\
	   ? (uint8_t)SET : (uint8_t)RESET;	*/
    }
    Status = (uint32_t)DAVEApp_SUCCESS;
  }
  return (Status);
}

/**
 * @endcond
 */
/*CODE_BLOCK_END*/





