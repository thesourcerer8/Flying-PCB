   1              		.syntax unified
   2              		.cpu cortex-m4
   3              		.eabi_attribute 27, 3
   4              		.fpu fpv4-sp-d16
   5              		.eabi_attribute 20, 1
   6              		.eabi_attribute 21, 1
   7              		.eabi_attribute 23, 3
   8              		.eabi_attribute 24, 1
   9              		.eabi_attribute 25, 1
  10              		.eabi_attribute 26, 1
  11              		.eabi_attribute 30, 6
  12              		.eabi_attribute 34, 1
  13              		.eabi_attribute 18, 4
  14              		.thumb
  15              		.file	"LMM001.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.LMM001_lblocks,"ax",%progbits
  20              		.align	2
  21              		.thumb
  22              		.thumb_func
  24              	LMM001_lblocks:
  25              	.LFB120:
  26              		.file 1 "../Dave/Generated/src/LMM001/LMM001.c"
   1:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
   2:../Dave/Generated/src/LMM001/LMM001.c **** // umm_malloc.c - a memory allocator for embedded systems (microcontrollers)
   3:../Dave/Generated/src/LMM001/LMM001.c **** //
   4:../Dave/Generated/src/LMM001/LMM001.c **** // See copyright notice in LICENSE.TXT
   5:../Dave/Generated/src/LMM001/LMM001.c **** /*******************************************************************************
   6:../Dave/Generated/src/LMM001/LMM001.c ****  Copyright (c) 2011, Infineon Technologies AG                                 **
   7:../Dave/Generated/src/LMM001/LMM001.c ****  All rights reserved.                                                         **
   8:../Dave/Generated/src/LMM001/LMM001.c ****                                                                               **
   9:../Dave/Generated/src/LMM001/LMM001.c ****  Redistribution and use in source and binary forms, with or without           **
  10:../Dave/Generated/src/LMM001/LMM001.c ****  modification,are permitted provided that the following conditions are met:   **
  11:../Dave/Generated/src/LMM001/LMM001.c ****                                                                               **
  12:../Dave/Generated/src/LMM001/LMM001.c ****  *Redistributions of source code must retain the above copyright notice,      **
  13:../Dave/Generated/src/LMM001/LMM001.c ****  this list of conditions and the following disclaimer.                        **
  14:../Dave/Generated/src/LMM001/LMM001.c ****  *Redistributions in binary form must reproduce the above copyright notice,   **
  15:../Dave/Generated/src/LMM001/LMM001.c ****  this list of conditions and the following disclaimer in the documentation    **
  16:../Dave/Generated/src/LMM001/LMM001.c ****  and/or other materials provided with the distribution.                       **
  17:../Dave/Generated/src/LMM001/LMM001.c ****  *Neither the name of the copyright holders nor the names of its contributors **
  18:../Dave/Generated/src/LMM001/LMM001.c ****  may be used to endorse or promote products derived from this software without** 
  19:../Dave/Generated/src/LMM001/LMM001.c ****  specific prior written permission.                                           **
  20:../Dave/Generated/src/LMM001/LMM001.c ****                                                                               **
  21:../Dave/Generated/src/LMM001/LMM001.c ****  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
  22:../Dave/Generated/src/LMM001/LMM001.c ****  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
  23:../Dave/Generated/src/LMM001/LMM001.c ****  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
  24:../Dave/Generated/src/LMM001/LMM001.c ****  ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
  25:../Dave/Generated/src/LMM001/LMM001.c ****  LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
  26:../Dave/Generated/src/LMM001/LMM001.c ****  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
  27:../Dave/Generated/src/LMM001/LMM001.c ****  SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
  28:../Dave/Generated/src/LMM001/LMM001.c ****  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
  29:../Dave/Generated/src/LMM001/LMM001.c ****  CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
  30:../Dave/Generated/src/LMM001/LMM001.c ****  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
  31:../Dave/Generated/src/LMM001/LMM001.c ****  POSSIBILITY OF SUCH DAMAGE.                                                  **
  32:../Dave/Generated/src/LMM001/LMM001.c ****                                                                               **
  33:../Dave/Generated/src/LMM001/LMM001.c ****  To improve the quality of the software, users are encouraged to share        **
  34:../Dave/Generated/src/LMM001/LMM001.c ****  modifications, enhancements or bug fixes with Infineon Technologies AG       **
  35:../Dave/Generated/src/LMM001/LMM001.c ****  dave@infineon.com).                                                          **
  36:../Dave/Generated/src/LMM001/LMM001.c ****                                                                               **
  37:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
  38:../Dave/Generated/src/LMM001/LMM001.c **** //
  39:../Dave/Generated/src/LMM001/LMM001.c **** // R.Hempel 2007-09-22 - Original
  40:../Dave/Generated/src/LMM001/LMM001.c **** // R.Hempel 2008-12-11 - Added MIT License biolerplate
  41:../Dave/Generated/src/LMM001/LMM001.c **** //                     - realloc() now looks to see if previous block is free
  42:../Dave/Generated/src/LMM001/LMM001.c **** //                     - made common operations functions            
  43:../Dave/Generated/src/LMM001/LMM001.c **** // R.Hempel 2009-03-02 - Added macros to disable tasking
  44:../Dave/Generated/src/LMM001/LMM001.c **** //                     - Added function to dump heap and check for valid free
  45:../Dave/Generated/src/LMM001/LMM001.c **** //                        pointer
  46:../Dave/Generated/src/LMM001/LMM001.c **** // R.Hempel 2009-03-09 - Changed name to umm_malloc to avoid conflicts with
  47:../Dave/Generated/src/LMM001/LMM001.c **** //                        the mm_malloc() library functions
  48:../Dave/Generated/src/LMM001/LMM001.c **** //                     - Added some test code to assimilate a free block
  49:../Dave/Generated/src/LMM001/LMM001.c **** //                        with the very block if possible. Complicated and
  50:../Dave/Generated/src/LMM001/LMM001.c **** //                        not worth the grief.
  51:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
  52:../Dave/Generated/src/LMM001/LMM001.c **** //
  53:../Dave/Generated/src/LMM001/LMM001.c **** // This is a memory management library specifically designed to work with the
  54:../Dave/Generated/src/LMM001/LMM001.c **** // ARM7 embedded processor, but it should work on many other 32 bit processors,
  55:../Dave/Generated/src/LMM001/LMM001.c **** // as well as 16 and 8 bit devices.
  56:../Dave/Generated/src/LMM001/LMM001.c **** //
  57:../Dave/Generated/src/LMM001/LMM001.c **** // ACKNOWLEDGEMENTS
  58:../Dave/Generated/src/LMM001/LMM001.c **** //
  59:../Dave/Generated/src/LMM001/LMM001.c **** // Joerg Wunsch and the avr-libc provided the first malloc() implementation
  60:../Dave/Generated/src/LMM001/LMM001.c **** // that I examined in detail.
  61:../Dave/Generated/src/LMM001/LMM001.c **** //
  62:../Dave/Generated/src/LMM001/LMM001.c **** // http://www.nongnu.org/avr-libc
  63:../Dave/Generated/src/LMM001/LMM001.c **** //
  64:../Dave/Generated/src/LMM001/LMM001.c **** // Doug Lea's paper on malloc() was another excellent reference and provides
  65:../Dave/Generated/src/LMM001/LMM001.c **** // a lot of detail on advanced memory management techniques such as binning.
  66:../Dave/Generated/src/LMM001/LMM001.c **** // 
  67:../Dave/Generated/src/LMM001/LMM001.c **** // http://g.oswego.edu/dl/html/malloc.html
  68:../Dave/Generated/src/LMM001/LMM001.c **** //
  69:../Dave/Generated/src/LMM001/LMM001.c **** // Bill Dittman provided excellent suggestions, including macros to support
  70:../Dave/Generated/src/LMM001/LMM001.c **** // using these functions in critical sections, and for optimizing realloc()
  71:../Dave/Generated/src/LMM001/LMM001.c **** // further by checking to see if the previous block was free and could be 
  72:../Dave/Generated/src/LMM001/LMM001.c **** // used for the new block size. This can help to reduce heap fragmentation
  73:../Dave/Generated/src/LMM001/LMM001.c **** // significantly. 
  74:../Dave/Generated/src/LMM001/LMM001.c **** //
  75:../Dave/Generated/src/LMM001/LMM001.c **** // Yaniv Ankin suggested that a way to dump the current heap condition
  76:../Dave/Generated/src/LMM001/LMM001.c **** // might be useful. I combined this with an idea from plarroy to also
  77:../Dave/Generated/src/LMM001/LMM001.c **** // allow checking a free pointer to make sure it's valid.
  78:../Dave/Generated/src/LMM001/LMM001.c **** //
  79:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
  80:../Dave/Generated/src/LMM001/LMM001.c **** //
  81:../Dave/Generated/src/LMM001/LMM001.c **** // The memory manager assumes the following things:
  82:../Dave/Generated/src/LMM001/LMM001.c **** //
  83:../Dave/Generated/src/LMM001/LMM001.c **** // 1. The standard POSIX compliant malloc/realloc/free semantics are used
  84:../Dave/Generated/src/LMM001/LMM001.c **** // 2. All memory used by the manager is allocated at link time, it is aligned
  85:../Dave/Generated/src/LMM001/LMM001.c **** //    on a 32 bit boundary, it is contiguous, and its extent (start and end
  86:../Dave/Generated/src/LMM001/LMM001.c **** //    address) is filled in by the linker.
  87:../Dave/Generated/src/LMM001/LMM001.c **** // 3. All memory used by the manager is initialized to 0 as part of the
  88:../Dave/Generated/src/LMM001/LMM001.c **** //    runtime startup routine. No other initialization is required.
  89:../Dave/Generated/src/LMM001/LMM001.c **** //
  90:../Dave/Generated/src/LMM001/LMM001.c **** // The fastest linked list implementations use doubly linked lists so that
  91:../Dave/Generated/src/LMM001/LMM001.c **** // its possible to insert and delete blocks in constant time. This memory
  92:../Dave/Generated/src/LMM001/LMM001.c **** // manager keeps track of both free and used blocks in a doubly linked list.
  93:../Dave/Generated/src/LMM001/LMM001.c **** //
  94:../Dave/Generated/src/LMM001/LMM001.c **** // Most memory managers use some kind of list structure made up of pointers
  95:../Dave/Generated/src/LMM001/LMM001.c **** // to keep track of used - and sometimes free - blocks of memory. In an
  96:../Dave/Generated/src/LMM001/LMM001.c **** // embedded system, this can get pretty expensive as each pointer can use
  97:../Dave/Generated/src/LMM001/LMM001.c **** // up to 32 bits.
  98:../Dave/Generated/src/LMM001/LMM001.c **** //
  99:../Dave/Generated/src/LMM001/LMM001.c **** // In most embedded systems there is no need for managing large blocks
 100:../Dave/Generated/src/LMM001/LMM001.c **** // of memory dynamically, so a full 32 bit pointer based data structure
 101:../Dave/Generated/src/LMM001/LMM001.c **** // for the free and used block lists is wasteful. A block of memory on
 102:../Dave/Generated/src/LMM001/LMM001.c **** // the free list would use 16 bytes just for the pointers!
 103:../Dave/Generated/src/LMM001/LMM001.c **** //
 104:../Dave/Generated/src/LMM001/LMM001.c **** // This memory management library sees the malloc heap as an array of blocks,
 105:../Dave/Generated/src/LMM001/LMM001.c **** // and uses block numbers to keep track of locations. The block numbers are
 106:../Dave/Generated/src/LMM001/LMM001.c **** // 15 bits - which allows for up to 32767 blocks of memory. The high order
 107:../Dave/Generated/src/LMM001/LMM001.c **** // bit marks a block as being either free or in use, which will be explained
 108:../Dave/Generated/src/LMM001/LMM001.c **** // later.
 109:../Dave/Generated/src/LMM001/LMM001.c **** //
 110:../Dave/Generated/src/LMM001/LMM001.c **** // The result is that a block of memory on the free list uses just 8 bytes
 111:../Dave/Generated/src/LMM001/LMM001.c **** // instead of 16.
 112:../Dave/Generated/src/LMM001/LMM001.c **** //
 113:../Dave/Generated/src/LMM001/LMM001.c **** // In fact, we go even one step futher when we realize that the free block
 114:../Dave/Generated/src/LMM001/LMM001.c **** // index values are available to store data when the block is allocated.
 115:../Dave/Generated/src/LMM001/LMM001.c **** //
 116:../Dave/Generated/src/LMM001/LMM001.c **** // The overhead of an allocated block is therefore just 4 bytes.
 117:../Dave/Generated/src/LMM001/LMM001.c **** //
 118:../Dave/Generated/src/LMM001/LMM001.c **** // Each memory block holds 8 bytes, and there are up to 32767 blocks
 119:../Dave/Generated/src/LMM001/LMM001.c **** // available, for about 256K of heap space. If that's not enough, you
 120:../Dave/Generated/src/LMM001/LMM001.c **** // can always add more data bytes to the body of the memory block
 121:../Dave/Generated/src/LMM001/LMM001.c **** // at the expense of free block size overhead.
 122:../Dave/Generated/src/LMM001/LMM001.c **** //
 123:../Dave/Generated/src/LMM001/LMM001.c **** // There are a lot of little features and optimizations in this memory
 124:../Dave/Generated/src/LMM001/LMM001.c **** // management system that makes it especially suited to small embedded, but
 125:../Dave/Generated/src/LMM001/LMM001.c **** // the best way to appreciate them is to review the data structures and
 126:../Dave/Generated/src/LMM001/LMM001.c **** // algorithms used, so let's get started.
 127:../Dave/Generated/src/LMM001/LMM001.c **** //
 128:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 129:../Dave/Generated/src/LMM001/LMM001.c **** //
 130:../Dave/Generated/src/LMM001/LMM001.c **** // We have a general notation for a block that we'll use to describe the
 131:../Dave/Generated/src/LMM001/LMM001.c **** // different scenarios that our memory allocation algorithm must deal with:
 132:../Dave/Generated/src/LMM001/LMM001.c **** //
 133:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 134:../Dave/Generated/src/LMM001/LMM001.c **** // c  |* n |  p | nf | pf |
 135:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 136:../Dave/Generated/src/LMM001/LMM001.c **** //
 137:../Dave/Generated/src/LMM001/LMM001.c **** // Where - c  is the index of this block
 138:../Dave/Generated/src/LMM001/LMM001.c **** //         *  is the indicator for a free block
 139:../Dave/Generated/src/LMM001/LMM001.c **** //         n  is the index of the next block in the heap
 140:../Dave/Generated/src/LMM001/LMM001.c **** //         p  is the index of the previous block in the heap
 141:../Dave/Generated/src/LMM001/LMM001.c **** //         nf is the index of the next block in the free list
 142:../Dave/Generated/src/LMM001/LMM001.c **** //         pf is the index of the previous block in the free list
 143:../Dave/Generated/src/LMM001/LMM001.c **** //
 144:../Dave/Generated/src/LMM001/LMM001.c **** // The fact that we have forward and backward links in the block descriptors
 145:../Dave/Generated/src/LMM001/LMM001.c **** // means that malloc() and free() operations can be very fast. It's easy
 146:../Dave/Generated/src/LMM001/LMM001.c **** // to either allocate the whole free item to a new block or to allocate part
 147:../Dave/Generated/src/LMM001/LMM001.c **** // of the free item and leave the rest on the free list without traversing
 148:../Dave/Generated/src/LMM001/LMM001.c **** // the list from front to back first.
 149:../Dave/Generated/src/LMM001/LMM001.c **** //
 150:../Dave/Generated/src/LMM001/LMM001.c **** // The entire block of memory used by the heap is assumed to be initialized
 151:../Dave/Generated/src/LMM001/LMM001.c **** // to 0. The very first block in the heap is special - it't the head of the
 152:../Dave/Generated/src/LMM001/LMM001.c **** // free block list. It is never assimilated with a free block (more on this
 153:../Dave/Generated/src/LMM001/LMM001.c **** // later).
 154:../Dave/Generated/src/LMM001/LMM001.c **** //
 155:../Dave/Generated/src/LMM001/LMM001.c **** // Once a block has been allocated to the application, it looks like this:
 156:../Dave/Generated/src/LMM001/LMM001.c **** //
 157:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 158:../Dave/Generated/src/LMM001/LMM001.c **** //  c |  n |  p |   ...   |
 159:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 160:../Dave/Generated/src/LMM001/LMM001.c **** //
 161:../Dave/Generated/src/LMM001/LMM001.c **** // Where - c  is the index of this block
 162:../Dave/Generated/src/LMM001/LMM001.c **** //         n  is the index of the next block in the heap
 163:../Dave/Generated/src/LMM001/LMM001.c **** //         p  is the index of the previous block in the heap
 164:../Dave/Generated/src/LMM001/LMM001.c **** //
 165:../Dave/Generated/src/LMM001/LMM001.c **** // Note that the free list information is gone, because it's now being used to
 166:../Dave/Generated/src/LMM001/LMM001.c **** // store actual data for the application. It would have been nice to store
 167:../Dave/Generated/src/LMM001/LMM001.c **** // the next and previous free list indexes as well, but that would be a waste
 168:../Dave/Generated/src/LMM001/LMM001.c **** // of space. If we had even 500 items in use, that would be 2,000 bytes for
 169:../Dave/Generated/src/LMM001/LMM001.c **** // free list information. We simply can't afford to waste that much.
 170:../Dave/Generated/src/LMM001/LMM001.c **** //
 171:../Dave/Generated/src/LMM001/LMM001.c **** // The address of the ... area is what is returned to the application
 172:../Dave/Generated/src/LMM001/LMM001.c **** // for data storage.
 173:../Dave/Generated/src/LMM001/LMM001.c **** //
 174:../Dave/Generated/src/LMM001/LMM001.c **** // The following sections describe the scenarios encountered during the
 175:../Dave/Generated/src/LMM001/LMM001.c **** // operation of the library. There are two additional notation conventions:
 176:../Dave/Generated/src/LMM001/LMM001.c **** //
 177:../Dave/Generated/src/LMM001/LMM001.c **** // ?? inside a pointer block means that the data is irrelevant. We don't care
 178:../Dave/Generated/src/LMM001/LMM001.c **** //    about it because we don't read or modify it in the scenario being
 179:../Dave/Generated/src/LMM001/LMM001.c **** //    described.
 180:../Dave/Generated/src/LMM001/LMM001.c **** //
 181:../Dave/Generated/src/LMM001/LMM001.c **** // ... between memory blocks indicates zero or more additional blocks are
 182:../Dave/Generated/src/LMM001/LMM001.c **** //     allocated for use by the upper block.
 183:../Dave/Generated/src/LMM001/LMM001.c **** //
 184:../Dave/Generated/src/LMM001/LMM001.c **** // And while we're talking about "upper" and "lower" blocks, we should make
 185:../Dave/Generated/src/LMM001/LMM001.c **** // a comment about adresses. In the diagrams, a block higher up in the
 186:../Dave/Generated/src/LMM001/LMM001.c **** // picture is at a lower address. And the blocks grow downwards their
 187:../Dave/Generated/src/LMM001/LMM001.c **** // block index increases as does their physical address.
 188:../Dave/Generated/src/LMM001/LMM001.c **** //
 189:../Dave/Generated/src/LMM001/LMM001.c **** // Finally, there's one very important characteristic of the individual
 190:../Dave/Generated/src/LMM001/LMM001.c **** // blocks that make up the heap - there can never be two consecutive free
 191:../Dave/Generated/src/LMM001/LMM001.c **** // memory blocks, but there can be consecutive used memory blocks.
 192:../Dave/Generated/src/LMM001/LMM001.c **** //
 193:../Dave/Generated/src/LMM001/LMM001.c **** // The reason is that we always want to have a short free list of the
 194:../Dave/Generated/src/LMM001/LMM001.c **** // largest possible block sizes. By always assimilating a newly freed block
 195:../Dave/Generated/src/LMM001/LMM001.c **** // with adjacent free blocks, we maximize the size of each free memory area.
 196:../Dave/Generated/src/LMM001/LMM001.c **** //
 197:../Dave/Generated/src/LMM001/LMM001.c **** //---------------------------------------------------------------------------
 198:../Dave/Generated/src/LMM001/LMM001.c **** //
 199:../Dave/Generated/src/LMM001/LMM001.c **** // Operation of malloc right after system startup
 200:../Dave/Generated/src/LMM001/LMM001.c **** //
 201:../Dave/Generated/src/LMM001/LMM001.c **** // As part of the system startup code, all of the heap has been cleared.
 202:../Dave/Generated/src/LMM001/LMM001.c **** //
 203:../Dave/Generated/src/LMM001/LMM001.c **** // During the very first malloc operation, we start traversing the free list
 204:../Dave/Generated/src/LMM001/LMM001.c **** // starting at index 0. The index of the next free block is 0, which means
 205:../Dave/Generated/src/LMM001/LMM001.c **** // we're at the end of the list!
 206:../Dave/Generated/src/LMM001/LMM001.c **** //
 207:../Dave/Generated/src/LMM001/LMM001.c **** // At this point, the malloc has a special test that checks if the current
 208:../Dave/Generated/src/LMM001/LMM001.c **** // block index is 0, which it is. This special case initializes the free
 209:../Dave/Generated/src/LMM001/LMM001.c **** // list to point at block index 1.
 210:../Dave/Generated/src/LMM001/LMM001.c **** //
 211:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 212:../Dave/Generated/src/LMM001/LMM001.c **** //
 213:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 214:../Dave/Generated/src/LMM001/LMM001.c **** // 0  |  0 |  0 |  0 |  0 |           0  |  1 |  0 |  1 |  0 |
 215:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 216:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+
 217:../Dave/Generated/src/LMM001/LMM001.c **** //                                    1  |  0 |  0 |  0 |  0 |
 218:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+
 219:../Dave/Generated/src/LMM001/LMM001.c **** //
 220:../Dave/Generated/src/LMM001/LMM001.c **** // The heap is now ready to complete the first malloc operation.
 221:../Dave/Generated/src/LMM001/LMM001.c **** //
 222:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 223:../Dave/Generated/src/LMM001/LMM001.c **** //
 224:../Dave/Generated/src/LMM001/LMM001.c **** // Operation of malloc when we have reached the end of the free list and
 225:../Dave/Generated/src/LMM001/LMM001.c **** // there is no block large enough to accommodate the request.
 226:../Dave/Generated/src/LMM001/LMM001.c **** //
 227:../Dave/Generated/src/LMM001/LMM001.c **** // This happens at the very first malloc operation, or any time the free
 228:../Dave/Generated/src/LMM001/LMM001.c **** // list is traversed and no free block large enough for the request is
 229:../Dave/Generated/src/LMM001/LMM001.c **** // found.
 230:../Dave/Generated/src/LMM001/LMM001.c **** //
 231:../Dave/Generated/src/LMM001/LMM001.c **** // The current block pointer will be at the end of the free list, and we
 232:../Dave/Generated/src/LMM001/LMM001.c **** // know we're at the end of the list because the nf index is 0, like this:
 233:../Dave/Generated/src/LMM001/LMM001.c **** //
 234:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 235:../Dave/Generated/src/LMM001/LMM001.c **** //
 236:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 237:../Dave/Generated/src/LMM001/LMM001.c **** // pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | lf | ?? |
 238:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 239:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 240:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 241:../Dave/Generated/src/LMM001/LMM001.c **** //  p | cf | ?? |   ...   |            p | cf | ?? |   ...   |
 242:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 243:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+  
 244:../Dave/Generated/src/LMM001/LMM001.c **** // cf |  0 |  p |  0 | pf |            c | lf |  p |   ...   | 
 245:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 246:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+
 247:../Dave/Generated/src/LMM001/LMM001.c **** //                                    lf |  0 | cf |  0 | pf |
 248:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+
 249:../Dave/Generated/src/LMM001/LMM001.c **** //
 250:../Dave/Generated/src/LMM001/LMM001.c **** // As we walk the free list looking for a block of size b or larger, we get
 251:../Dave/Generated/src/LMM001/LMM001.c **** // to cf, which is the last item in the free list. We know this because the
 252:../Dave/Generated/src/LMM001/LMM001.c **** // next index is 0.
 253:../Dave/Generated/src/LMM001/LMM001.c **** //
 254:../Dave/Generated/src/LMM001/LMM001.c **** // So we're going to turn cf into the new block of memory, and then create
 255:../Dave/Generated/src/LMM001/LMM001.c **** // a new block that represents the last free entry (lf) and adjust the prev
 256:../Dave/Generated/src/LMM001/LMM001.c **** // index of lf to point at the  block we just created. We also need to adjust
 257:../Dave/Generated/src/LMM001/LMM001.c **** // the next index of the new block (c) to point to the last free block.
 258:../Dave/Generated/src/LMM001/LMM001.c **** //
 259:../Dave/Generated/src/LMM001/LMM001.c **** // Note that the next free index of the pf block must point to the new lf
 260:../Dave/Generated/src/LMM001/LMM001.c **** // because cf is no longer a free block!
 261:../Dave/Generated/src/LMM001/LMM001.c **** //
 262:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 263:../Dave/Generated/src/LMM001/LMM001.c **** //
 264:../Dave/Generated/src/LMM001/LMM001.c **** // Operation of malloc when we have found a block (cf) that will fit the
 265:../Dave/Generated/src/LMM001/LMM001.c **** // current request of b units exactly.
 266:../Dave/Generated/src/LMM001/LMM001.c **** //
 267:../Dave/Generated/src/LMM001/LMM001.c **** // This one is pretty easy, just clear the free list bit in the current
 268:../Dave/Generated/src/LMM001/LMM001.c **** // block and unhook it from the free list.
 269:../Dave/Generated/src/LMM001/LMM001.c **** //
 270:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 271:../Dave/Generated/src/LMM001/LMM001.c **** //
 272:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 273:../Dave/Generated/src/LMM001/LMM001.c **** // pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |
 274:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 275:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 276:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 277:../Dave/Generated/src/LMM001/LMM001.c **** //  p | cf | ?? |   ...   |            p | cf | ?? |   ...   |
 278:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 279:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+  Clear the free
 280:../Dave/Generated/src/LMM001/LMM001.c **** // cf |* n |  p | nf | pf |           cf |  n |  p |   ..    |  list bit here
 281:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 282:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 283:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? | cf |   ...   |            n | ?? | cf |   ...   |
 284:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 285:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 286:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 287:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? | cf |           nf | ?? | ?? | ?? | pf |
 288:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 289:../Dave/Generated/src/LMM001/LMM001.c **** //
 290:../Dave/Generated/src/LMM001/LMM001.c **** // Unhooking from the free list is accomplished by adjusting the next and
 291:../Dave/Generated/src/LMM001/LMM001.c **** // prev free list index values in the pf and nf blocks.
 292:../Dave/Generated/src/LMM001/LMM001.c **** //
 293:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 294:../Dave/Generated/src/LMM001/LMM001.c **** //
 295:../Dave/Generated/src/LMM001/LMM001.c **** // Operation of malloc when we have found a block that will fit the current
 296:../Dave/Generated/src/LMM001/LMM001.c **** // request of b units with some left over.
 297:../Dave/Generated/src/LMM001/LMM001.c **** //
 298:../Dave/Generated/src/LMM001/LMM001.c **** // We'll allocate the new block at the END of the current free block so we
 299:../Dave/Generated/src/LMM001/LMM001.c **** // don't have to change ANY free list pointers.
 300:../Dave/Generated/src/LMM001/LMM001.c **** //
 301:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 302:../Dave/Generated/src/LMM001/LMM001.c **** //
 303:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 304:../Dave/Generated/src/LMM001/LMM001.c **** // pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | cf | ?? |
 305:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 306:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 307:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 308:../Dave/Generated/src/LMM001/LMM001.c **** //  p | cf | ?? |   ...   |            p | cf | ?? |   ...   |
 309:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 310:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 311:../Dave/Generated/src/LMM001/LMM001.c **** // cf |* n |  p | nf | pf |           cf |* c |  p | nf | pf |
 312:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 313:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+ This is the new
 314:../Dave/Generated/src/LMM001/LMM001.c **** //                                     c |  n | cf |   ..    | block at cf+b
 315:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+
 316:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 317:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? | cf |   ...   |            n | ?? |  c |   ...   |
 318:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 319:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 320:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 321:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? | cf |           nf | ?? | ?? | ?? | pf |
 322:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 323:../Dave/Generated/src/LMM001/LMM001.c **** //
 324:../Dave/Generated/src/LMM001/LMM001.c **** // This one is prety easy too, except we don't need to mess with the
 325:../Dave/Generated/src/LMM001/LMM001.c **** // free list indexes at all becasue we'll allocate the new block at the
 326:../Dave/Generated/src/LMM001/LMM001.c **** // end of the current free block. We do, however have to adjust the
 327:../Dave/Generated/src/LMM001/LMM001.c **** // indexes in cf, c, and n.
 328:../Dave/Generated/src/LMM001/LMM001.c **** //
 329:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 330:../Dave/Generated/src/LMM001/LMM001.c **** //
 331:../Dave/Generated/src/LMM001/LMM001.c **** // That covers the initialization and all possible malloc scenarios, so now
 332:../Dave/Generated/src/LMM001/LMM001.c **** // we need to cover the free operation possibilities...
 333:../Dave/Generated/src/LMM001/LMM001.c **** //
 334:../Dave/Generated/src/LMM001/LMM001.c **** // The operation of free depends on the position of the current block being
 335:../Dave/Generated/src/LMM001/LMM001.c **** // freed relative to free list items immediately above or below it. The code
 336:../Dave/Generated/src/LMM001/LMM001.c **** // works like this:
 337:../Dave/Generated/src/LMM001/LMM001.c **** //
 338:../Dave/Generated/src/LMM001/LMM001.c **** // if next block is free
 339:../Dave/Generated/src/LMM001/LMM001.c **** //   assimilate with next block already on free list
 340:../Dave/Generated/src/LMM001/LMM001.c **** // if prev block is free
 341:../Dave/Generated/src/LMM001/LMM001.c **** //   assimilate with prev block already on free list
 342:../Dave/Generated/src/LMM001/LMM001.c **** // else
 343:../Dave/Generated/src/LMM001/LMM001.c **** //   put current block at head of free list
 344:../Dave/Generated/src/LMM001/LMM001.c **** //
 345:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 346:../Dave/Generated/src/LMM001/LMM001.c **** //
 347:../Dave/Generated/src/LMM001/LMM001.c **** // Step 1 of the free operation checks if the next block is free, and if it
 348:../Dave/Generated/src/LMM001/LMM001.c **** // is then insert this block into the free list and assimilate the next block
 349:../Dave/Generated/src/LMM001/LMM001.c **** // with this one.
 350:../Dave/Generated/src/LMM001/LMM001.c **** //
 351:../Dave/Generated/src/LMM001/LMM001.c **** // Note that c is the block we are freeing up, cf is the free block that
 352:../Dave/Generated/src/LMM001/LMM001.c **** // follows it.
 353:../Dave/Generated/src/LMM001/LMM001.c **** //
 354:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 355:../Dave/Generated/src/LMM001/LMM001.c **** //
 356:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 357:../Dave/Generated/src/LMM001/LMM001.c **** // pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |
 358:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 359:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 360:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 361:../Dave/Generated/src/LMM001/LMM001.c **** //  p |  c | ?? |   ...   |            p |  c | ?? |   ...   |
 362:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 363:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+ This block is
 364:../Dave/Generated/src/LMM001/LMM001.c **** //  c | cf |  p |   ...   |            c | nn |  p |   ...   | disconnected
 365:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+ from free list,
 366:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+                                    assimilated with
 367:../Dave/Generated/src/LMM001/LMM001.c **** // cf |*nn |  c | nf | pf |                                    the next, and
 368:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+                                    ready for step 2
 369:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 370:../Dave/Generated/src/LMM001/LMM001.c **** // nn | ?? | cf | ?? | ?? |           nn | ?? |  c |   ...   |
 371:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 372:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 373:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 374:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? | cf |           nf |*?? | ?? | ?? | pf |
 375:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 376:../Dave/Generated/src/LMM001/LMM001.c **** //
 377:../Dave/Generated/src/LMM001/LMM001.c **** // Take special note that the newly assimilated block (c) is completely
 378:../Dave/Generated/src/LMM001/LMM001.c **** // disconnected from the free list, and it does not have its free list
 379:../Dave/Generated/src/LMM001/LMM001.c **** // bit set. This is important as we move on to step 2 of the procedure...
 380:../Dave/Generated/src/LMM001/LMM001.c **** //
 381:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 382:../Dave/Generated/src/LMM001/LMM001.c **** //
 383:../Dave/Generated/src/LMM001/LMM001.c **** // Step 2 of the free operation checks if the prev block is free, and if it
 384:../Dave/Generated/src/LMM001/LMM001.c **** // is then assimilate it with this block.
 385:../Dave/Generated/src/LMM001/LMM001.c **** //
 386:../Dave/Generated/src/LMM001/LMM001.c **** // Note that c is the block we are freeing up, pf is the free block that
 387:../Dave/Generated/src/LMM001/LMM001.c **** // precedes it.
 388:../Dave/Generated/src/LMM001/LMM001.c **** //
 389:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 390:../Dave/Generated/src/LMM001/LMM001.c **** //
 391:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+ This block has
 392:../Dave/Generated/src/LMM001/LMM001.c **** // pf |* c | ?? | nf | ?? |           pf |* n | ?? | nf | ?? | assimilated the
 393:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+ current block
 394:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 395:../Dave/Generated/src/LMM001/LMM001.c **** //  c |  n | pf |   ...   |
 396:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+
 397:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 398:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? |  c |   ...   |            n | ?? | pf | ?? | ?? |
 399:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 400:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 401:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 402:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? | pf |           nf |*?? | ?? | ?? | pf |
 403:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 404:../Dave/Generated/src/LMM001/LMM001.c **** //
 405:../Dave/Generated/src/LMM001/LMM001.c **** // Nothing magic here, except that when we're done, the current block (c)
 406:../Dave/Generated/src/LMM001/LMM001.c **** // is gone since it's been absorbed into the previous free block. Note that
 407:../Dave/Generated/src/LMM001/LMM001.c **** // the previous step guarantees that the next block (n) is not free.
 408:../Dave/Generated/src/LMM001/LMM001.c **** //
 409:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 410:../Dave/Generated/src/LMM001/LMM001.c **** //
 411:../Dave/Generated/src/LMM001/LMM001.c **** // Step 3 of the free operation only runs if the previous block is not free.
 412:../Dave/Generated/src/LMM001/LMM001.c **** // it just inserts the current block to the head of the free list.
 413:../Dave/Generated/src/LMM001/LMM001.c **** //
 414:../Dave/Generated/src/LMM001/LMM001.c **** // Remember, 0 is always the first block in the memory heap, and it's always
 415:../Dave/Generated/src/LMM001/LMM001.c **** // head of the free list!
 416:../Dave/Generated/src/LMM001/LMM001.c **** //
 417:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 418:../Dave/Generated/src/LMM001/LMM001.c **** //
 419:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 420:../Dave/Generated/src/LMM001/LMM001.c **** //  0 | ?? | ?? | nf |  0 |            0 | ?? | ?? |  c |  0 |
 421:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 422:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 423:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 424:../Dave/Generated/src/LMM001/LMM001.c **** //  p |  c | ?? |   ...   |            p |  c | ?? |   ...   |
 425:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 426:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 427:../Dave/Generated/src/LMM001/LMM001.c **** //  c |  n |  p |   ..    |            c |* n |  p | nf |  0 |
 428:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 429:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 430:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? |  c |   ...   |            n | ?? |  c |   ...   |
 431:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 432:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 433:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 434:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? |  0 |           nf |*?? | ?? | ?? |  c |
 435:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 436:../Dave/Generated/src/LMM001/LMM001.c **** //
 437:../Dave/Generated/src/LMM001/LMM001.c **** // Again, nothing spectacular here, we're simply adjusting a few pointers
 438:../Dave/Generated/src/LMM001/LMM001.c **** // to make the most recently freed block the first item in the free list.
 439:../Dave/Generated/src/LMM001/LMM001.c **** //
 440:../Dave/Generated/src/LMM001/LMM001.c **** // That's because finding the previous free block would mean a reverse
 441:../Dave/Generated/src/LMM001/LMM001.c **** // traversal of blocks until we found a free one, and it's just easier to
 442:../Dave/Generated/src/LMM001/LMM001.c **** // put it at the head of the list. No traversal is needed.
 443:../Dave/Generated/src/LMM001/LMM001.c **** //
 444:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 445:../Dave/Generated/src/LMM001/LMM001.c **** //
 446:../Dave/Generated/src/LMM001/LMM001.c **** // Finally, we can cover realloc, which has the following basic operation.
 447:../Dave/Generated/src/LMM001/LMM001.c **** //
 448:../Dave/Generated/src/LMM001/LMM001.c **** // The first thing we do is assimilate up with the next free block of
 449:../Dave/Generated/src/LMM001/LMM001.c **** // memory if possible. This step might help if we're resizing to a bigger
 450:../Dave/Generated/src/LMM001/LMM001.c **** // block of memory. It also helps if we're downsizing and creating a new
 451:../Dave/Generated/src/LMM001/LMM001.c **** // free block with the leftover memory.
 452:../Dave/Generated/src/LMM001/LMM001.c **** //
 453:../Dave/Generated/src/LMM001/LMM001.c **** // First we check to see if the next block is free, and we assimilate it
 454:../Dave/Generated/src/LMM001/LMM001.c **** // to this block if it is. If the previous block is also free, and if
 455:../Dave/Generated/src/LMM001/LMM001.c **** // combining it with the current block would satisfy the request, then we
 456:../Dave/Generated/src/LMM001/LMM001.c **** // assimilate with that block and move the current data down to the new
 457:../Dave/Generated/src/LMM001/LMM001.c **** // location.
 458:../Dave/Generated/src/LMM001/LMM001.c **** //
 459:../Dave/Generated/src/LMM001/LMM001.c **** // Assimilating with the previous free block and moving the data works
 460:../Dave/Generated/src/LMM001/LMM001.c **** // like this:
 461:../Dave/Generated/src/LMM001/LMM001.c **** //
 462:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 463:../Dave/Generated/src/LMM001/LMM001.c **** //
 464:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 465:../Dave/Generated/src/LMM001/LMM001.c **** // pf |*?? | ?? | cf | ?? |           pf |*?? | ?? | nf | ?? |
 466:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 467:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 468:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 469:../Dave/Generated/src/LMM001/LMM001.c **** // cf |* c | ?? | nf | pf |            c |  n | ?? |   ...   | The data gets
 470:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+ moved from c to
 471:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+                                    the new data area  
 472:../Dave/Generated/src/LMM001/LMM001.c **** //  c |  n | cf |   ...   |                                    in cf, then c is
 473:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+                                    adjusted to cf
 474:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 475:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? |  c |   ...   |            n | ?? |  c | ?? | ?? |
 476:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 477:../Dave/Generated/src/LMM001/LMM001.c **** //             ...                                ...
 478:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 479:../Dave/Generated/src/LMM001/LMM001.c **** // nf |*?? | ?? | ?? | cf |           nf |*?? | ?? | ?? | pf |
 480:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 481:../Dave/Generated/src/LMM001/LMM001.c **** //
 482:../Dave/Generated/src/LMM001/LMM001.c **** //
 483:../Dave/Generated/src/LMM001/LMM001.c **** // Once we're done that, there are three scenarios to consider:
 484:../Dave/Generated/src/LMM001/LMM001.c **** //
 485:../Dave/Generated/src/LMM001/LMM001.c **** // 1. The current block size is exactly the right size, so no more work is
 486:../Dave/Generated/src/LMM001/LMM001.c **** //    needed.
 487:../Dave/Generated/src/LMM001/LMM001.c **** //
 488:../Dave/Generated/src/LMM001/LMM001.c **** // 2. The current block is bigger than the new required size, so carve off
 489:../Dave/Generated/src/LMM001/LMM001.c **** //    the excess and add it to the free list.
 490:../Dave/Generated/src/LMM001/LMM001.c **** //
 491:../Dave/Generated/src/LMM001/LMM001.c **** // 3. The current block is still smaller than the required size, so malloc
 492:../Dave/Generated/src/LMM001/LMM001.c **** //    a new block of the correct size and copy the current data into the new
 493:../Dave/Generated/src/LMM001/LMM001.c **** //    block before freeing the current block.
 494:../Dave/Generated/src/LMM001/LMM001.c **** //
 495:../Dave/Generated/src/LMM001/LMM001.c **** // The only one of these scenarios that involves an operation that has not
 496:../Dave/Generated/src/LMM001/LMM001.c **** // yet been described is the second one, and it's shown below:
 497:../Dave/Generated/src/LMM001/LMM001.c **** //
 498:../Dave/Generated/src/LMM001/LMM001.c **** //    BEFORE                             AFTER
 499:../Dave/Generated/src/LMM001/LMM001.c **** //
 500:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 501:../Dave/Generated/src/LMM001/LMM001.c **** //  p |  c | ?? |   ...   |            p |  c | ?? |   ...   |
 502:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 503:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 504:../Dave/Generated/src/LMM001/LMM001.c **** //  c |  n |  p |   ...   |            c |  s |  p |   ...   |
 505:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 506:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+ This is the
 507:../Dave/Generated/src/LMM001/LMM001.c **** //                                     s |  n |  c |   ..    | new block at
 508:../Dave/Generated/src/LMM001/LMM001.c **** //                                       +----+----+----+----+ c+blocks
 509:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 510:../Dave/Generated/src/LMM001/LMM001.c **** //  n | ?? |  c |   ...   |            n | ?? |  s |   ...   |
 511:../Dave/Generated/src/LMM001/LMM001.c **** //    +----+----+----+----+              +----+----+----+----+
 512:../Dave/Generated/src/LMM001/LMM001.c **** //
 513:../Dave/Generated/src/LMM001/LMM001.c **** // Then we call free() with the adress of the data portion of the new
 514:../Dave/Generated/src/LMM001/LMM001.c **** // block (s) which adds it to the free list.
 515:../Dave/Generated/src/LMM001/LMM001.c **** //
 516:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 517:../Dave/Generated/src/LMM001/LMM001.c **** *******************************************************************************
 518:../Dave/Generated/src/LMM001/LMM001.c **** **                      INCLUDE FILES                           			  **
 519:../Dave/Generated/src/LMM001/LMM001.c **** *******************************************************************************/
 520:../Dave/Generated/src/LMM001/LMM001.c **** #include <DAVE3.h>
 521:../Dave/Generated/src/LMM001/LMM001.c **** 
 522:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 523:../Dave/Generated/src/LMM001/LMM001.c **** //
 524:../Dave/Generated/src/LMM001/LMM001.c **** // There are a number of defines you can set at compile time that affect how
 525:../Dave/Generated/src/LMM001/LMM001.c **** // the memory allocator will operate. In GNU C, you set these compile time
 526:../Dave/Generated/src/LMM001/LMM001.c **** // defines like this:
 527:../Dave/Generated/src/LMM001/LMM001.c **** //
 528:../Dave/Generated/src/LMM001/LMM001.c **** // -D UMM_TEST_MAIN
 529:../Dave/Generated/src/LMM001/LMM001.c **** //
 530:../Dave/Generated/src/LMM001/LMM001.c **** // Set this if you want to compile in the test suite at the end of this file.
 531:../Dave/Generated/src/LMM001/LMM001.c **** // If you do set this variable, then the function names are left alone as
 532:../Dave/Generated/src/LMM001/LMM001.c **** // umm_malloc() umm_free() and umm_realloc() so that they cannot be confused
 533:../Dave/Generated/src/LMM001/LMM001.c **** // with the C runtime functions malloc() free() and realloc()
 534:../Dave/Generated/src/LMM001/LMM001.c **** //
 535:../Dave/Generated/src/LMM001/LMM001.c **** // If you leave this variable unset, then the function names become malloc()
 536:../Dave/Generated/src/LMM001/LMM001.c **** // free() and realloc() so that they can be used as the C runtime functions
 537:../Dave/Generated/src/LMM001/LMM001.c **** // in an embedded environment.
 538:../Dave/Generated/src/LMM001/LMM001.c **** //
 539:../Dave/Generated/src/LMM001/LMM001.c **** // -D UMM_BEST_FIT (defualt)
 540:../Dave/Generated/src/LMM001/LMM001.c **** //
 541:../Dave/Generated/src/LMM001/LMM001.c **** // Set this if you want to use a best-fit algorithm for allocating new
 542:../Dave/Generated/src/LMM001/LMM001.c **** // blocks
 543:../Dave/Generated/src/LMM001/LMM001.c **** //
 544:../Dave/Generated/src/LMM001/LMM001.c **** // -D UMM_FIRST_FIT
 545:../Dave/Generated/src/LMM001/LMM001.c **** //
 546:../Dave/Generated/src/LMM001/LMM001.c **** // Set this if you want to use a first-fit algorithm for allocating new
 547:../Dave/Generated/src/LMM001/LMM001.c **** // blocks
 548:../Dave/Generated/src/LMM001/LMM001.c **** //
 549:../Dave/Generated/src/LMM001/LMM001.c **** // -D UMM_DBG_LOG_LEVEL=n
 550:../Dave/Generated/src/LMM001/LMM001.c **** //
 551:../Dave/Generated/src/LMM001/LMM001.c **** // Set n to a value from 0 to 6 depending on how verbose you want the debug
 552:../Dave/Generated/src/LMM001/LMM001.c **** // log to be
 553:../Dave/Generated/src/LMM001/LMM001.c **** //
 554:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 555:../Dave/Generated/src/LMM001/LMM001.c **** // 
 556:../Dave/Generated/src/LMM001/LMM001.c **** // Support for this library in a multitasking environment is provided when
 557:../Dave/Generated/src/LMM001/LMM001.c **** // you add bodies to the LMM001_CRITICAL_ENTRY and LMM001_CRITICAL_EXIT macros
 558:../Dave/Generated/src/LMM001/LMM001.c **** // in umm_malloc.h
 559:../Dave/Generated/src/LMM001/LMM001.c **** //
 560:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 561:../Dave/Generated/src/LMM001/LMM001.c **** 
 562:../Dave/Generated/src/LMM001/LMM001.c **** #ifndef UMM_FIRST_FIT
 563:../Dave/Generated/src/LMM001/LMM001.c **** #  ifndef UMM_BEST_FIT
 564:../Dave/Generated/src/LMM001/LMM001.c **** #    define UMM_BEST_FIT
 565:../Dave/Generated/src/LMM001/LMM001.c **** #  endif
 566:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 567:../Dave/Generated/src/LMM001/LMM001.c **** 
 568:../Dave/Generated/src/LMM001/LMM001.c **** #ifndef UMM_DBG_LOG_LEVEL
 569:../Dave/Generated/src/LMM001/LMM001.c **** #  undef  DBG_LOG_LEVEL
 570:../Dave/Generated/src/LMM001/LMM001.c **** #  define DBG_LOG_LEVEL 0
 571:../Dave/Generated/src/LMM001/LMM001.c **** #else
 572:../Dave/Generated/src/LMM001/LMM001.c **** #  undef  DBG_LOG_LEVEL
 573:../Dave/Generated/src/LMM001/LMM001.c **** #  define DBG_LOG_LEVEL UMM_DBG_LOG_LEVEL
 574:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 575:../Dave/Generated/src/LMM001/LMM001.c **** 
 576:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 577:../Dave/Generated/src/LMM001/LMM001.c **** #define UMM_FREELIST_MASK (0x8000)
 578:../Dave/Generated/src/LMM001/LMM001.c **** #define UMM_BLOCKNO_MASK  (0x7FFF)
 579:../Dave/Generated/src/LMM001/LMM001.c **** 
 580:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 581:../Dave/Generated/src/LMM001/LMM001.c **** 
 582:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 583:../Dave/Generated/src/LMM001/LMM001.c **** 
 584:../Dave/Generated/src/LMM001/LMM001.c **** 
 585:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_BLOCK(UMMControlBlock,b)  (UMMControlBlock->umm_heap[b])
 586:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_NBLOCK(UMMControlBlock,b) (UMM_BLOCK(UMMControlBlock,b).header.used.next)
 587:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_PBLOCK(UMMControlBlock,b) (UMM_BLOCK(UMMControlBlock,b).header.used.prev)
 588:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_NFREE(UMMControlBlock,b)  (UMM_BLOCK(UMMControlBlock,b).body.free.next)
 589:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_PFREE(UMMControlBlock,b)  (UMM_BLOCK(UMMControlBlock,b).body.free.prev)
 590:../Dave/Generated/src/LMM001/LMM001.c **** 	#define UMM_DATA(UMMControlBlock,b)   (UMM_BLOCK(UMMControlBlock,b).body.data)
 591:../Dave/Generated/src/LMM001/LMM001.c **** 
 592:../Dave/Generated/src/LMM001/LMM001.c **** 
 593:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 594:../Dave/Generated/src/LMM001/LMM001.c **** // One of the coolest things about this little library is that it's VERY
 595:../Dave/Generated/src/LMM001/LMM001.c **** // easy to get debug information about the memory heap by simply iterating
 596:../Dave/Generated/src/LMM001/LMM001.c **** // through all of the memory blocks.
 597:../Dave/Generated/src/LMM001/LMM001.c **** //
 598:../Dave/Generated/src/LMM001/LMM001.c **** // As you go through all the blocks, you can check to see if it's a free
 599:../Dave/Generated/src/LMM001/LMM001.c **** // block by looking at the high order bit of the next block index. You can
 600:../Dave/Generated/src/LMM001/LMM001.c **** // also see how big the block is by subtracting the next block index from
 601:../Dave/Generated/src/LMM001/LMM001.c **** // the current block number.
 602:../Dave/Generated/src/LMM001/LMM001.c **** //
 603:../Dave/Generated/src/LMM001/LMM001.c **** // The LMM001_linfo function does all of that and makes the results available
 604:../Dave/Generated/src/LMM001/LMM001.c **** // in the heapInfo structure.
 605:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 606:../Dave/Generated/src/LMM001/LMM001.c **** 
 607:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 608:../Dave/Generated/src/LMM001/LMM001.c **** LMM001_HEAPINFOType heapInfo;
 609:../Dave/Generated/src/LMM001/LMM001.c **** void *LMM001_linfo( LMM001_HandleType *HandlePtr,void *MemPtr, int force ) {
 610:../Dave/Generated/src/LMM001/LMM001.c **** 
 611:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t blockNo = 0;
 612:../Dave/Generated/src/LMM001/LMM001.c **** 
 613:../Dave/Generated/src/LMM001/LMM001.c ****   // Protect the critical section...
 614:../Dave/Generated/src/LMM001/LMM001.c ****   //
 615:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_ENTRY();
 616:../Dave/Generated/src/LMM001/LMM001.c ****   
 617:../Dave/Generated/src/LMM001/LMM001.c ****   // Clear out all of the entries in the heapInfo structure before doing
 618:../Dave/Generated/src/LMM001/LMM001.c ****   // any calculations..
 619:../Dave/Generated/src/LMM001/LMM001.c ****   //
 620:../Dave/Generated/src/LMM001/LMM001.c ****   memset( &heapInfo, 0, sizeof( heapInfo ) );
 621:../Dave/Generated/src/LMM001/LMM001.c **** 
 622:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_FORCE( force, "\n\nDumping the umm_heap...\n" );
 623:../Dave/Generated/src/LMM001/LMM001.c **** 
 624:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_FORCE( force, "|0x%08x|B %5i|NB %5i|PB %5i|Z %5i|NF %5i|PF %5i|\n",
 625:../Dave/Generated/src/LMM001/LMM001.c ****                         &UMM_BLOCK(HandlePtr,blockNo),
 626:../Dave/Generated/src/LMM001/LMM001.c ****                         blockNo,
 627:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK,
 628:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_PBLOCK(HandlePtr,blockNo),
 629:../Dave/Generated/src/LMM001/LMM001.c ****                         (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo,
 630:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_NFREE(HandlePtr,blockNo),
 631:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_PFREE(HandlePtr,blockNo) );
 632:../Dave/Generated/src/LMM001/LMM001.c **** 
 633:../Dave/Generated/src/LMM001/LMM001.c ****   // Now loop through the block lists, and keep track of the number and size
 634:../Dave/Generated/src/LMM001/LMM001.c ****   // of used and free blocks. The terminating condition is an nb pointer with
 635:../Dave/Generated/src/LMM001/LMM001.c ****   // a value of zero...
 636:../Dave/Generated/src/LMM001/LMM001.c ****   
 637:../Dave/Generated/src/LMM001/LMM001.c ****   blockNo = UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK;
 638:../Dave/Generated/src/LMM001/LMM001.c **** 
 639:../Dave/Generated/src/LMM001/LMM001.c ****   while( UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK ) {
 640:../Dave/Generated/src/LMM001/LMM001.c ****     ++heapInfo.totalEntries;
 641:../Dave/Generated/src/LMM001/LMM001.c ****     heapInfo.totalBlocks += (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo;
 642:../Dave/Generated/src/LMM001/LMM001.c **** 
 643:../Dave/Generated/src/LMM001/LMM001.c ****     // Is this a free block?
 644:../Dave/Generated/src/LMM001/LMM001.c **** 
 645:../Dave/Generated/src/LMM001/LMM001.c ****     if( UMM_NBLOCK(HandlePtr,blockNo) & UMM_FREELIST_MASK ) {
 646:../Dave/Generated/src/LMM001/LMM001.c ****       ++heapInfo.freeEntries;
 647:../Dave/Generated/src/LMM001/LMM001.c ****       heapInfo.freeBlocks += (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo;
 648:../Dave/Generated/src/LMM001/LMM001.c **** 
 649:../Dave/Generated/src/LMM001/LMM001.c ****       DBG_LOG_FORCE( force, "|0x%08x|B %5i|NB %5i|PB %5i|Z %5i|NF %5i|PF %5i|\n",
 650:../Dave/Generated/src/LMM001/LMM001.c ****                             &UMM_BLOCK(HandlePtr,blockNo),
 651:../Dave/Generated/src/LMM001/LMM001.c ****                             blockNo,
 652:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK,
 653:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_PBLOCK(HandlePtr,blockNo),
 654:../Dave/Generated/src/LMM001/LMM001.c ****                             (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo,
 655:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_NFREE(HandlePtr,blockNo),
 656:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_PFREE(HandlePtr,blockNo) );
 657:../Dave/Generated/src/LMM001/LMM001.c ****      
 658:../Dave/Generated/src/LMM001/LMM001.c ****       // Does this block address match the MemPtr we may be trying to free?
 659:../Dave/Generated/src/LMM001/LMM001.c **** 
 660:../Dave/Generated/src/LMM001/LMM001.c ****       if( MemPtr == &UMM_BLOCK(HandlePtr,blockNo) ) {
 661:../Dave/Generated/src/LMM001/LMM001.c ****        
 662:../Dave/Generated/src/LMM001/LMM001.c ****         // Release the critical section...
 663:../Dave/Generated/src/LMM001/LMM001.c ****         //
 664:../Dave/Generated/src/LMM001/LMM001.c ****         LMM001_CRITICAL_EXIT();
 665:../Dave/Generated/src/LMM001/LMM001.c ****  
 666:../Dave/Generated/src/LMM001/LMM001.c ****         return( MemPtr );
 667:../Dave/Generated/src/LMM001/LMM001.c ****       }
 668:../Dave/Generated/src/LMM001/LMM001.c ****     } else {
 669:../Dave/Generated/src/LMM001/LMM001.c ****       ++heapInfo.usedEntries;
 670:../Dave/Generated/src/LMM001/LMM001.c ****       heapInfo.usedBlocks += (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo;
 671:../Dave/Generated/src/LMM001/LMM001.c **** 
 672:../Dave/Generated/src/LMM001/LMM001.c ****       DBG_LOG_FORCE( force, "|0x%08x|B %5i|NB %5i|PB %5i|Z %5i|\n",
 673:../Dave/Generated/src/LMM001/LMM001.c ****                             &UMM_BLOCK(HandlePtr,blockNo),
 674:../Dave/Generated/src/LMM001/LMM001.c ****                             blockNo,
 675:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK,
 676:../Dave/Generated/src/LMM001/LMM001.c ****                             UMM_PBLOCK(HandlePtr,blockNo),
 677:../Dave/Generated/src/LMM001/LMM001.c ****                             (UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK )-blockNo );
 678:../Dave/Generated/src/LMM001/LMM001.c ****     }
 679:../Dave/Generated/src/LMM001/LMM001.c **** 
 680:../Dave/Generated/src/LMM001/LMM001.c ****     blockNo = UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK;
 681:../Dave/Generated/src/LMM001/LMM001.c ****   }
 682:../Dave/Generated/src/LMM001/LMM001.c **** 
 683:../Dave/Generated/src/LMM001/LMM001.c ****   // Update the accounting totals with information from the last block, the
 684:../Dave/Generated/src/LMM001/LMM001.c ****   // rest must be free!
 685:../Dave/Generated/src/LMM001/LMM001.c **** 
 686:../Dave/Generated/src/LMM001/LMM001.c ****   //heapInfo.freeBlocks  += UMM_NUMBLOCKS-blockNo;
 687:../Dave/Generated/src/LMM001/LMM001.c ****  // heapInfo.totalBlocks += UMM_NUMBLOCKS-blockNo;
 688:../Dave/Generated/src/LMM001/LMM001.c ****   heapInfo.freeBlocks  += HandlePtr->umm_numblocks  -blockNo;
 689:../Dave/Generated/src/LMM001/LMM001.c ****   heapInfo.totalBlocks += HandlePtr->umm_numblocks       -blockNo;
 690:../Dave/Generated/src/LMM001/LMM001.c **** 
 691:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_FORCE( force, "|0x%08x|B %5i|NB %5i|PB %5i|Z %5i|NF %5i|PF %5i|\n",
 692:../Dave/Generated/src/LMM001/LMM001.c ****                         &UMM_BLOCK(HandlePtr,blockNo),
 693:../Dave/Generated/src/LMM001/LMM001.c ****                         blockNo,
 694:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_NBLOCK(HandlePtr,blockNo) & UMM_BLOCKNO_MASK,
 695:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_PBLOCK(HandlePtr,blockNo),
 696:../Dave/Generated/src/LMM001/LMM001.c ****                         HandlePtr->umm_numblocks - blockNo,
 697:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_NFREE(HandlePtr,blockNo),
 698:../Dave/Generated/src/LMM001/LMM001.c ****                         UMM_PFREE(HandlePtr,blockNo) );
 699:../Dave/Generated/src/LMM001/LMM001.c **** 
 700:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_FORCE( force, "Total Entries %5i    Used Entries %5i    Free Entries %5i\n",
 701:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.totalEntries,
 702:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.usedEntries,
 703:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.freeEntries );
 704:../Dave/Generated/src/LMM001/LMM001.c **** 
 705:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_FORCE( force, "Total Blocks  %5i    Used Blocks  %5i    Free Blocks  %5i\n",
 706:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.totalBlocks,
 707:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.usedBlocks,
 708:../Dave/Generated/src/LMM001/LMM001.c ****                         heapInfo.freeBlocks  );
 709:../Dave/Generated/src/LMM001/LMM001.c **** 
 710:../Dave/Generated/src/LMM001/LMM001.c ****   // Release the critical section...
 711:../Dave/Generated/src/LMM001/LMM001.c ****   //
 712:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_EXIT();
 713:../Dave/Generated/src/LMM001/LMM001.c ****  
 714:../Dave/Generated/src/LMM001/LMM001.c ****   return( NULL );
 715:../Dave/Generated/src/LMM001/LMM001.c **** }
 716:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 717:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 718:../Dave/Generated/src/LMM001/LMM001.c **** 
 719:../Dave/Generated/src/LMM001/LMM001.c **** static uint16_t LMM001_lblocks( uint32_t size ) {
  27              		.loc 1 719 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 1, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 80B4     		push	{r7}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 4
  35              		.cfi_offset 7, -4
  36 0002 83B0     		sub	sp, sp, #12
  37              	.LCFI1:
  38              		.cfi_def_cfa_offset 16
  39 0004 00AF     		add	r7, sp, #0
  40              	.LCFI2:
  41              		.cfi_def_cfa_register 7
  42 0006 7860     		str	r0, [r7, #4]
 720:../Dave/Generated/src/LMM001/LMM001.c **** 
 721:../Dave/Generated/src/LMM001/LMM001.c ****   // The calculation of the block size is not too difficult, but there are
 722:../Dave/Generated/src/LMM001/LMM001.c ****   // a few little things that we need to be mindful of.
 723:../Dave/Generated/src/LMM001/LMM001.c ****   //
 724:../Dave/Generated/src/LMM001/LMM001.c ****   // When a block removed from the free list, the space used by the free
 725:../Dave/Generated/src/LMM001/LMM001.c ****   // pointers is available for data. That's what the first calculation
 726:../Dave/Generated/src/LMM001/LMM001.c ****   // of size is doing.
 727:../Dave/Generated/src/LMM001/LMM001.c **** 
 728:../Dave/Generated/src/LMM001/LMM001.c ****   if( size <= (sizeof(((LMM001_BlockType *)0)->body)) )
  43              		.loc 1 728 0
  44 0008 7B68     		ldr	r3, [r7, #4]
  45 000a 042B     		cmp	r3, #4
  46 000c 02D8     		bhi	.L2
 729:../Dave/Generated/src/LMM001/LMM001.c ****     return( 1 );
  47              		.loc 1 729 0
  48 000e 4FF00103 		mov	r3, #1
  49 0012 0AE0     		b	.L3
  50              	.L2:
 730:../Dave/Generated/src/LMM001/LMM001.c **** 
 731:../Dave/Generated/src/LMM001/LMM001.c ****   // If it's for more than that, then we need to figure out the number of
 732:../Dave/Generated/src/LMM001/LMM001.c ****   // additional whole blocks the size of an LMM001_BlockType are required.
 733:../Dave/Generated/src/LMM001/LMM001.c **** 
 734:../Dave/Generated/src/LMM001/LMM001.c ****   size -= ( 1 + (sizeof(((LMM001_BlockType *)0)->body)) );
  51              		.loc 1 734 0
  52 0014 7B68     		ldr	r3, [r7, #4]
  53 0016 A3F10503 		sub	r3, r3, #5
  54 001a 7B60     		str	r3, [r7, #4]
 735:../Dave/Generated/src/LMM001/LMM001.c **** 
 736:../Dave/Generated/src/LMM001/LMM001.c ****   return( 2 + size/(sizeof(LMM001_BlockType)) );
  55              		.loc 1 736 0
  56 001c 7B68     		ldr	r3, [r7, #4]
  57 001e 4FEAD303 		lsr	r3, r3, #3
  58 0022 9BB2     		uxth	r3, r3
  59 0024 03F10203 		add	r3, r3, #2
  60 0028 9BB2     		uxth	r3, r3
  61              	.L3:
 737:../Dave/Generated/src/LMM001/LMM001.c **** }
  62              		.loc 1 737 0
  63 002a 1846     		mov	r0, r3
  64 002c 07F10C07 		add	r7, r7, #12
  65 0030 BD46     		mov	sp, r7
  66 0032 80BC     		pop	{r7}
  67 0034 7047     		bx	lr
  68              		.cfi_endproc
  69              	.LFE120:
  71 0036 00BF     		.section	.text.LMM001_lmake_new_block,"ax",%progbits
  72              		.align	2
  73              		.thumb
  74              		.thumb_func
  76              	LMM001_lmake_new_block:
  77              	.LFB121:
 738:../Dave/Generated/src/LMM001/LMM001.c **** 
 739:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 740:../Dave/Generated/src/LMM001/LMM001.c **** 
 741:../Dave/Generated/src/LMM001/LMM001.c **** static void LMM001_lmake_new_block( LMM001_HandleType *HandlePtr,
 742:../Dave/Generated/src/LMM001/LMM001.c **** 								uint16_t c,
 743:../Dave/Generated/src/LMM001/LMM001.c ****                                 uint16_t blocks,
 744:../Dave/Generated/src/LMM001/LMM001.c ****                                 uint16_t freemask ) {
  78              		.loc 1 744 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 16
  81              		@ frame_needed = 1, uses_anonymous_args = 0
  82              		@ link register save eliminated.
  83 0000 80B4     		push	{r7}
  84              	.LCFI3:
  85              		.cfi_def_cfa_offset 4
  86              		.cfi_offset 7, -4
  87 0002 85B0     		sub	sp, sp, #20
  88              	.LCFI4:
  89              		.cfi_def_cfa_offset 24
  90 0004 00AF     		add	r7, sp, #0
  91              	.LCFI5:
  92              		.cfi_def_cfa_register 7
  93 0006 F860     		str	r0, [r7, #12]
  94 0008 7981     		strh	r1, [r7, #10]	@ movhi
  95 000a 3A81     		strh	r2, [r7, #8]	@ movhi
  96 000c FB80     		strh	r3, [r7, #6]	@ movhi
 745:../Dave/Generated/src/LMM001/LMM001.c **** 
 746:../Dave/Generated/src/LMM001/LMM001.c ****      UMM_NBLOCK(HandlePtr,c+blocks) = UMM_NBLOCK(HandlePtr,c) & UMM_BLOCKNO_MASK;
  97              		.loc 1 746 0
  98 000e FB68     		ldr	r3, [r7, #12]
  99 0010 1A68     		ldr	r2, [r3, #0]	@ unaligned
 100 0012 7989     		ldrh	r1, [r7, #10]
 101 0014 3B89     		ldrh	r3, [r7, #8]
 102 0016 CB18     		adds	r3, r1, r3
 103 0018 4FEAC303 		lsl	r3, r3, #3
 104 001c D218     		adds	r2, r2, r3
 105 001e FB68     		ldr	r3, [r7, #12]
 106 0020 1968     		ldr	r1, [r3, #0]	@ unaligned
 107 0022 7B89     		ldrh	r3, [r7, #10]
 108 0024 4FEAC303 		lsl	r3, r3, #3
 109 0028 CB18     		adds	r3, r1, r3
 110 002a 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 111 002c 9BB2     		uxth	r3, r3
 112 002e 4FEA4343 		lsl	r3, r3, #17
 113 0032 4FEA5343 		lsr	r3, r3, #17
 114 0036 9BB2     		uxth	r3, r3
 115 0038 1380     		strh	r3, [r2, #0]	@ unaligned
 747:../Dave/Generated/src/LMM001/LMM001.c ****      UMM_PBLOCK(HandlePtr,c+blocks) = c;
 116              		.loc 1 747 0
 117 003a FB68     		ldr	r3, [r7, #12]
 118 003c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 119 003e 7989     		ldrh	r1, [r7, #10]
 120 0040 3B89     		ldrh	r3, [r7, #8]
 121 0042 CB18     		adds	r3, r1, r3
 122 0044 4FEAC303 		lsl	r3, r3, #3
 123 0048 D318     		adds	r3, r2, r3
 124 004a 7A89     		ldrh	r2, [r7, #10]	@ movhi
 125 004c 5A80     		strh	r2, [r3, #2]	@ unaligned
 748:../Dave/Generated/src/LMM001/LMM001.c **** 
 749:../Dave/Generated/src/LMM001/LMM001.c ****      UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c) & UMM_BLOCKNO_MASK) = c+blocks;
 126              		.loc 1 749 0
 127 004e FB68     		ldr	r3, [r7, #12]
 128 0050 1A68     		ldr	r2, [r3, #0]	@ unaligned
 129 0052 FB68     		ldr	r3, [r7, #12]
 130 0054 1968     		ldr	r1, [r3, #0]	@ unaligned
 131 0056 7B89     		ldrh	r3, [r7, #10]
 132 0058 4FEAC303 		lsl	r3, r3, #3
 133 005c CB18     		adds	r3, r1, r3
 134 005e 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 135 0060 9BB2     		uxth	r3, r3
 136 0062 4FEA4343 		lsl	r3, r3, #17
 137 0066 4FEA5343 		lsr	r3, r3, #17
 138 006a 4FEAC303 		lsl	r3, r3, #3
 139 006e D318     		adds	r3, r2, r3
 140 0070 7989     		ldrh	r1, [r7, #10]	@ movhi
 141 0072 3A89     		ldrh	r2, [r7, #8]	@ movhi
 142 0074 8A18     		adds	r2, r1, r2
 143 0076 92B2     		uxth	r2, r2
 144 0078 5A80     		strh	r2, [r3, #2]	@ unaligned
 750:../Dave/Generated/src/LMM001/LMM001.c ****      UMM_NBLOCK(HandlePtr,c)                                = (c+blocks) | freemask;
 145              		.loc 1 750 0
 146 007a FB68     		ldr	r3, [r7, #12]
 147 007c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 148 007e 7B89     		ldrh	r3, [r7, #10]
 149 0080 4FEAC303 		lsl	r3, r3, #3
 150 0084 D318     		adds	r3, r2, r3
 151 0086 7989     		ldrh	r1, [r7, #10]	@ movhi
 152 0088 3A89     		ldrh	r2, [r7, #8]	@ movhi
 153 008a 8A18     		adds	r2, r1, r2
 154 008c 92B2     		uxth	r2, r2
 155 008e 91B2     		uxth	r1, r2
 156 0090 FA88     		ldrh	r2, [r7, #6]
 157 0092 0A43     		orrs	r2, r2, r1
 158 0094 92B2     		uxth	r2, r2
 159 0096 92B2     		uxth	r2, r2
 160 0098 1A80     		strh	r2, [r3, #0]	@ unaligned
 751:../Dave/Generated/src/LMM001/LMM001.c **** }
 161              		.loc 1 751 0
 162 009a 07F11407 		add	r7, r7, #20
 163 009e BD46     		mov	sp, r7
 164 00a0 80BC     		pop	{r7}
 165 00a2 7047     		bx	lr
 166              		.cfi_endproc
 167              	.LFE121:
 169              		.section	.text.LMM001_ldisconnect_from_free_list,"ax",%progbits
 170              		.align	2
 171              		.thumb
 172              		.thumb_func
 174              	LMM001_ldisconnect_from_free_list:
 175              	.LFB122:
 752:../Dave/Generated/src/LMM001/LMM001.c **** 
 753:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 754:../Dave/Generated/src/LMM001/LMM001.c **** 
 755:../Dave/Generated/src/LMM001/LMM001.c **** static void LMM001_ldisconnect_from_free_list(LMM001_HandleType *HandlePtr, uint16_t c ) {
 176              		.loc 1 755 0
 177              		.cfi_startproc
 178              		@ args = 0, pretend = 0, frame = 8
 179              		@ frame_needed = 1, uses_anonymous_args = 0
 180              		@ link register save eliminated.
 181 0000 80B4     		push	{r7}
 182              	.LCFI6:
 183              		.cfi_def_cfa_offset 4
 184              		.cfi_offset 7, -4
 185 0002 83B0     		sub	sp, sp, #12
 186              	.LCFI7:
 187              		.cfi_def_cfa_offset 16
 188 0004 00AF     		add	r7, sp, #0
 189              	.LCFI8:
 190              		.cfi_def_cfa_register 7
 191 0006 7860     		str	r0, [r7, #4]
 192 0008 0B46     		mov	r3, r1
 193 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 756:../Dave/Generated/src/LMM001/LMM001.c ****     // Disconnect this block from the FREE list
 757:../Dave/Generated/src/LMM001/LMM001.c **** 
 758:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NFREE(HandlePtr,UMM_PFREE(HandlePtr,c)) = UMM_NFREE(HandlePtr,c);
 194              		.loc 1 758 0
 195 000c 7B68     		ldr	r3, [r7, #4]
 196 000e 1A68     		ldr	r2, [r3, #0]	@ unaligned
 197 0010 7B68     		ldr	r3, [r7, #4]
 198 0012 1968     		ldr	r1, [r3, #0]	@ unaligned
 199 0014 7B88     		ldrh	r3, [r7, #2]
 200 0016 4FEAC303 		lsl	r3, r3, #3
 201 001a CB18     		adds	r3, r1, r3
 202 001c DB88     		ldrh	r3, [r3, #6]	@ unaligned
 203 001e 9BB2     		uxth	r3, r3
 204 0020 4FEAC303 		lsl	r3, r3, #3
 205 0024 D318     		adds	r3, r2, r3
 206 0026 7A68     		ldr	r2, [r7, #4]
 207 0028 1168     		ldr	r1, [r2, #0]	@ unaligned
 208 002a 7A88     		ldrh	r2, [r7, #2]
 209 002c 4FEAC202 		lsl	r2, r2, #3
 210 0030 8A18     		adds	r2, r1, r2
 211 0032 9288     		ldrh	r2, [r2, #4]	@ unaligned
 212 0034 92B2     		uxth	r2, r2
 213 0036 9A80     		strh	r2, [r3, #4]	@ unaligned
 759:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PFREE(HandlePtr,UMM_NFREE(HandlePtr,c)) = UMM_PFREE(HandlePtr,c);
 214              		.loc 1 759 0
 215 0038 7B68     		ldr	r3, [r7, #4]
 216 003a 1A68     		ldr	r2, [r3, #0]	@ unaligned
 217 003c 7B68     		ldr	r3, [r7, #4]
 218 003e 1968     		ldr	r1, [r3, #0]	@ unaligned
 219 0040 7B88     		ldrh	r3, [r7, #2]
 220 0042 4FEAC303 		lsl	r3, r3, #3
 221 0046 CB18     		adds	r3, r1, r3
 222 0048 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 223 004a 9BB2     		uxth	r3, r3
 224 004c 4FEAC303 		lsl	r3, r3, #3
 225 0050 D318     		adds	r3, r2, r3
 226 0052 7A68     		ldr	r2, [r7, #4]
 227 0054 1168     		ldr	r1, [r2, #0]	@ unaligned
 228 0056 7A88     		ldrh	r2, [r7, #2]
 229 0058 4FEAC202 		lsl	r2, r2, #3
 230 005c 8A18     		adds	r2, r1, r2
 231 005e D288     		ldrh	r2, [r2, #6]	@ unaligned
 232 0060 92B2     		uxth	r2, r2
 233 0062 DA80     		strh	r2, [r3, #6]	@ unaligned
 760:../Dave/Generated/src/LMM001/LMM001.c **** 
 761:../Dave/Generated/src/LMM001/LMM001.c ****     // And clear the free block indicator
 762:../Dave/Generated/src/LMM001/LMM001.c **** 
 763:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NBLOCK(HandlePtr,c) &= (~UMM_FREELIST_MASK);
 234              		.loc 1 763 0
 235 0064 7B68     		ldr	r3, [r7, #4]
 236 0066 1A68     		ldr	r2, [r3, #0]	@ unaligned
 237 0068 7B88     		ldrh	r3, [r7, #2]
 238 006a 4FEAC303 		lsl	r3, r3, #3
 239 006e D218     		adds	r2, r2, r3
 240 0070 7B68     		ldr	r3, [r7, #4]
 241 0072 1968     		ldr	r1, [r3, #0]	@ unaligned
 242 0074 7B88     		ldrh	r3, [r7, #2]
 243 0076 4FEAC303 		lsl	r3, r3, #3
 244 007a CB18     		adds	r3, r1, r3
 245 007c 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 246 007e 9BB2     		uxth	r3, r3
 247 0080 4FEA4343 		lsl	r3, r3, #17
 248 0084 4FEA5343 		lsr	r3, r3, #17
 249 0088 9BB2     		uxth	r3, r3
 250 008a 1380     		strh	r3, [r2, #0]	@ unaligned
 764:../Dave/Generated/src/LMM001/LMM001.c **** }
 251              		.loc 1 764 0
 252 008c 07F10C07 		add	r7, r7, #12
 253 0090 BD46     		mov	sp, r7
 254 0092 80BC     		pop	{r7}
 255 0094 7047     		bx	lr
 256              		.cfi_endproc
 257              	.LFE122:
 259 0096 00BF     		.section	.text.LMM001_l_assimilate_up,"ax",%progbits
 260              		.align	2
 261              		.thumb
 262              		.thumb_func
 264              	LMM001_l_assimilate_up:
 265              	.LFB123:
 765:../Dave/Generated/src/LMM001/LMM001.c **** 
 766:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 767:../Dave/Generated/src/LMM001/LMM001.c **** 
 768:../Dave/Generated/src/LMM001/LMM001.c **** 
 769:../Dave/Generated/src/LMM001/LMM001.c **** 
 770:../Dave/Generated/src/LMM001/LMM001.c **** static void LMM001_l_assimilate_up(LMM001_HandleType *HandlePtr, uint16_t c ) {
 266              		.loc 1 770 0
 267              		.cfi_startproc
 268              		@ args = 0, pretend = 0, frame = 8
 269              		@ frame_needed = 1, uses_anonymous_args = 0
 270 0000 80B5     		push	{r7, lr}
 271              	.LCFI9:
 272              		.cfi_def_cfa_offset 8
 273              		.cfi_offset 7, -8
 274              		.cfi_offset 14, -4
 275 0002 82B0     		sub	sp, sp, #8
 276              	.LCFI10:
 277              		.cfi_def_cfa_offset 16
 278 0004 00AF     		add	r7, sp, #0
 279              	.LCFI11:
 280              		.cfi_def_cfa_register 7
 281 0006 7860     		str	r0, [r7, #4]
 282 0008 0B46     		mov	r3, r1
 283 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 771:../Dave/Generated/src/LMM001/LMM001.c **** 
 772:../Dave/Generated/src/LMM001/LMM001.c ****   if( UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK ) {
 284              		.loc 1 772 0
 285 000c 7B68     		ldr	r3, [r7, #4]
 286 000e 1A68     		ldr	r2, [r3, #0]	@ unaligned
 287 0010 7B68     		ldr	r3, [r7, #4]
 288 0012 1968     		ldr	r1, [r3, #0]	@ unaligned
 289 0014 7B88     		ldrh	r3, [r7, #2]
 290 0016 4FEAC303 		lsl	r3, r3, #3
 291 001a CB18     		adds	r3, r1, r3
 292 001c 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 293 001e 9BB2     		uxth	r3, r3
 294 0020 4FEAC303 		lsl	r3, r3, #3
 295 0024 D318     		adds	r3, r2, r3
 296 0026 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 297 0028 9BB2     		uxth	r3, r3
 298 002a 9BB2     		uxth	r3, r3
 299 002c 1BB2     		sxth	r3, r3
 300 002e 002B     		cmp	r3, #0
 301 0030 40DA     		bge	.L6
 773:../Dave/Generated/src/LMM001/LMM001.c ****     // The next block is a free block, so assimilate up and remove it from
 774:../Dave/Generated/src/LMM001/LMM001.c ****     // the free list
 775:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 776:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "Assimilate up to next block, which is FREE\n" );
 777:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 778:../Dave/Generated/src/LMM001/LMM001.c ****     // Disconnect the next block from the FREE list
 779:../Dave/Generated/src/LMM001/LMM001.c **** 
 780:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_ldisconnect_from_free_list( HandlePtr,UMM_NBLOCK(HandlePtr,c) );
 302              		.loc 1 780 0
 303 0032 7B68     		ldr	r3, [r7, #4]
 304 0034 1A68     		ldr	r2, [r3, #0]	@ unaligned
 305 0036 7B88     		ldrh	r3, [r7, #2]
 306 0038 4FEAC303 		lsl	r3, r3, #3
 307 003c D318     		adds	r3, r2, r3
 308 003e 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 309 0040 9BB2     		uxth	r3, r3
 310 0042 7868     		ldr	r0, [r7, #4]
 311 0044 1946     		mov	r1, r3
 312 0046 FFF7FEFF 		bl	LMM001_ldisconnect_from_free_list
 781:../Dave/Generated/src/LMM001/LMM001.c **** 
 782:../Dave/Generated/src/LMM001/LMM001.c ****     // Assimilate the next block with this one
 783:../Dave/Generated/src/LMM001/LMM001.c **** 
 784:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_BLOCKNO_MASK) = c;
 313              		.loc 1 784 0
 314 004a 7B68     		ldr	r3, [r7, #4]
 315 004c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 316 004e 7B68     		ldr	r3, [r7, #4]
 317 0050 1968     		ldr	r1, [r3, #0]	@ unaligned
 318 0052 7B68     		ldr	r3, [r7, #4]
 319 0054 1868     		ldr	r0, [r3, #0]	@ unaligned
 320 0056 7B88     		ldrh	r3, [r7, #2]
 321 0058 4FEAC303 		lsl	r3, r3, #3
 322 005c C318     		adds	r3, r0, r3
 323 005e 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 324 0060 9BB2     		uxth	r3, r3
 325 0062 4FEAC303 		lsl	r3, r3, #3
 326 0066 CB18     		adds	r3, r1, r3
 327 0068 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 328 006a 9BB2     		uxth	r3, r3
 329 006c 4FEA4343 		lsl	r3, r3, #17
 330 0070 4FEA5343 		lsr	r3, r3, #17
 331 0074 4FEAC303 		lsl	r3, r3, #3
 332 0078 D318     		adds	r3, r2, r3
 333 007a 7A88     		ldrh	r2, [r7, #2]	@ movhi
 334 007c 5A80     		strh	r2, [r3, #2]	@ unaligned
 785:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NBLOCK(HandlePtr,c) = UMM_NBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) & UMM_BLOCKNO_MASK;
 335              		.loc 1 785 0
 336 007e 7B68     		ldr	r3, [r7, #4]
 337 0080 1A68     		ldr	r2, [r3, #0]	@ unaligned
 338 0082 7B88     		ldrh	r3, [r7, #2]
 339 0084 4FEAC303 		lsl	r3, r3, #3
 340 0088 D218     		adds	r2, r2, r3
 341 008a 7B68     		ldr	r3, [r7, #4]
 342 008c 1968     		ldr	r1, [r3, #0]	@ unaligned
 343 008e 7B68     		ldr	r3, [r7, #4]
 344 0090 1868     		ldr	r0, [r3, #0]	@ unaligned
 345 0092 7B88     		ldrh	r3, [r7, #2]
 346 0094 4FEAC303 		lsl	r3, r3, #3
 347 0098 C318     		adds	r3, r0, r3
 348 009a 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 349 009c 9BB2     		uxth	r3, r3
 350 009e 4FEAC303 		lsl	r3, r3, #3
 351 00a2 CB18     		adds	r3, r1, r3
 352 00a4 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 353 00a6 9BB2     		uxth	r3, r3
 354 00a8 4FEA4343 		lsl	r3, r3, #17
 355 00ac 4FEA5343 		lsr	r3, r3, #17
 356 00b0 9BB2     		uxth	r3, r3
 357 00b2 1380     		strh	r3, [r2, #0]	@ unaligned
 358              	.L6:
 786:../Dave/Generated/src/LMM001/LMM001.c ****   } 
 787:../Dave/Generated/src/LMM001/LMM001.c **** }
 359              		.loc 1 787 0
 360 00b4 07F10807 		add	r7, r7, #8
 361 00b8 BD46     		mov	sp, r7
 362 00ba 80BD     		pop	{r7, pc}
 363              		.cfi_endproc
 364              	.LFE123:
 366              		.section	.text.LMM001_l_assimilate_down,"ax",%progbits
 367              		.align	2
 368              		.thumb
 369              		.thumb_func
 371              	LMM001_l_assimilate_down:
 372              	.LFB124:
 788:../Dave/Generated/src/LMM001/LMM001.c **** 
 789:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 790:../Dave/Generated/src/LMM001/LMM001.c **** 
 791:../Dave/Generated/src/LMM001/LMM001.c **** static uint16_t LMM001_l_assimilate_down( LMM001_HandleType *HandlePtr,uint16_t c, uint16_t freemas
 373              		.loc 1 791 0
 374              		.cfi_startproc
 375              		@ args = 0, pretend = 0, frame = 8
 376              		@ frame_needed = 1, uses_anonymous_args = 0
 377              		@ link register save eliminated.
 378 0000 80B4     		push	{r7}
 379              	.LCFI12:
 380              		.cfi_def_cfa_offset 4
 381              		.cfi_offset 7, -4
 382 0002 83B0     		sub	sp, sp, #12
 383              	.LCFI13:
 384              		.cfi_def_cfa_offset 16
 385 0004 00AF     		add	r7, sp, #0
 386              	.LCFI14:
 387              		.cfi_def_cfa_register 7
 388 0006 7860     		str	r0, [r7, #4]
 389 0008 1346     		mov	r3, r2
 390 000a 0A46     		mov	r2, r1	@ movhi
 391 000c 7A80     		strh	r2, [r7, #2]	@ movhi
 392 000e 3B80     		strh	r3, [r7, #0]	@ movhi
 792:../Dave/Generated/src/LMM001/LMM001.c **** 
 793:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) = UMM_NBLOCK(HandlePtr,c) | freemask;
 393              		.loc 1 793 0
 394 0010 7B68     		ldr	r3, [r7, #4]
 395 0012 1A68     		ldr	r2, [r3, #0]	@ unaligned
 396 0014 7B68     		ldr	r3, [r7, #4]
 397 0016 1968     		ldr	r1, [r3, #0]	@ unaligned
 398 0018 7B88     		ldrh	r3, [r7, #2]
 399 001a 4FEAC303 		lsl	r3, r3, #3
 400 001e CB18     		adds	r3, r1, r3
 401 0020 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 402 0022 9BB2     		uxth	r3, r3
 403 0024 4FEAC303 		lsl	r3, r3, #3
 404 0028 D318     		adds	r3, r2, r3
 405 002a 7A68     		ldr	r2, [r7, #4]
 406 002c 1168     		ldr	r1, [r2, #0]	@ unaligned
 407 002e 7A88     		ldrh	r2, [r7, #2]
 408 0030 4FEAC202 		lsl	r2, r2, #3
 409 0034 8A18     		adds	r2, r1, r2
 410 0036 1288     		ldrh	r2, [r2, #0]	@ unaligned
 411 0038 91B2     		uxth	r1, r2
 412 003a 3A88     		ldrh	r2, [r7, #0]	@ movhi
 413 003c 0A43     		orrs	r2, r2, r1
 414 003e 92B2     		uxth	r2, r2
 415 0040 1A80     		strh	r2, [r3, #0]	@ unaligned
 794:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PBLOCK(HandlePtr,UMM_NBLOCK(HandlePtr,c)) = UMM_PBLOCK(HandlePtr,c);
 416              		.loc 1 794 0
 417 0042 7B68     		ldr	r3, [r7, #4]
 418 0044 1A68     		ldr	r2, [r3, #0]	@ unaligned
 419 0046 7B68     		ldr	r3, [r7, #4]
 420 0048 1968     		ldr	r1, [r3, #0]	@ unaligned
 421 004a 7B88     		ldrh	r3, [r7, #2]
 422 004c 4FEAC303 		lsl	r3, r3, #3
 423 0050 CB18     		adds	r3, r1, r3
 424 0052 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 425 0054 9BB2     		uxth	r3, r3
 426 0056 4FEAC303 		lsl	r3, r3, #3
 427 005a D318     		adds	r3, r2, r3
 428 005c 7A68     		ldr	r2, [r7, #4]
 429 005e 1168     		ldr	r1, [r2, #0]	@ unaligned
 430 0060 7A88     		ldrh	r2, [r7, #2]
 431 0062 4FEAC202 		lsl	r2, r2, #3
 432 0066 8A18     		adds	r2, r1, r2
 433 0068 5288     		ldrh	r2, [r2, #2]	@ unaligned
 434 006a 92B2     		uxth	r2, r2
 435 006c 5A80     		strh	r2, [r3, #2]	@ unaligned
 795:../Dave/Generated/src/LMM001/LMM001.c **** 
 796:../Dave/Generated/src/LMM001/LMM001.c ****     return( UMM_PBLOCK(HandlePtr,c) );
 436              		.loc 1 796 0
 437 006e 7B68     		ldr	r3, [r7, #4]
 438 0070 1A68     		ldr	r2, [r3, #0]	@ unaligned
 439 0072 7B88     		ldrh	r3, [r7, #2]
 440 0074 4FEAC303 		lsl	r3, r3, #3
 441 0078 D318     		adds	r3, r2, r3
 442 007a 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 443 007c 9BB2     		uxth	r3, r3
 797:../Dave/Generated/src/LMM001/LMM001.c **** }
 444              		.loc 1 797 0
 445 007e 1846     		mov	r0, r3
 446 0080 07F10C07 		add	r7, r7, #12
 447 0084 BD46     		mov	sp, r7
 448 0086 80BC     		pop	{r7}
 449 0088 7047     		bx	lr
 450              		.cfi_endproc
 451              	.LFE124:
 453 008a 00BF     		.section	.text.LMM001_free,"ax",%progbits
 454              		.align	2
 455              		.global	LMM001_free
 456              		.thumb
 457              		.thumb_func
 459              	LMM001_free:
 460              	.LFB125:
 798:../Dave/Generated/src/LMM001/LMM001.c **** 
 799:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 800:../Dave/Generated/src/LMM001/LMM001.c **** /*******************************************************************************
 801:../Dave/Generated/src/LMM001/LMM001.c **** **                      Public Function Definitions                           **
 802:../Dave/Generated/src/LMM001/LMM001.c **** *******************************************************************************/
 803:../Dave/Generated/src/LMM001/LMM001.c **** /* The function frees the memory.*/
 804:../Dave/Generated/src/LMM001/LMM001.c **** void LMM001_free( LMM001_HandleType *HandlePtr,void *MemPtr ) {
 461              		.loc 1 804 0
 462              		.cfi_startproc
 463              		@ args = 0, pretend = 0, frame = 16
 464              		@ frame_needed = 1, uses_anonymous_args = 0
 465 0000 80B5     		push	{r7, lr}
 466              	.LCFI15:
 467              		.cfi_def_cfa_offset 8
 468              		.cfi_offset 7, -8
 469              		.cfi_offset 14, -4
 470 0002 84B0     		sub	sp, sp, #16
 471              	.LCFI16:
 472              		.cfi_def_cfa_offset 24
 473 0004 00AF     		add	r7, sp, #0
 474              	.LCFI17:
 475              		.cfi_def_cfa_register 7
 476 0006 7860     		str	r0, [r7, #4]
 477 0008 3960     		str	r1, [r7, #0]
 805:../Dave/Generated/src/LMM001/LMM001.c **** 
 806:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t c;
 807:../Dave/Generated/src/LMM001/LMM001.c **** 
 808:../Dave/Generated/src/LMM001/LMM001.c ****   // If we're being asked to free a NULL pointer, well that's just silly!
 809:../Dave/Generated/src/LMM001/LMM001.c **** 
 810:../Dave/Generated/src/LMM001/LMM001.c ****   if( (void *)0 == MemPtr ) {
 478              		.loc 1 810 0
 479 000a 3B68     		ldr	r3, [r7, #0]
 480 000c 002B     		cmp	r3, #0
 481 000e 65D0     		beq	.L15
 482              	.L11:
 483              	.LBB19:
 484              	.LBB20:
 485              		.file 2 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Include/core_cmFunc.h"
   1:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /**************************************************************************//**
   2:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  * @file     core_cmFunc.h
   3:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  * @brief    CMSIS Cortex-M Core Function Access Header File
   4:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  * @version  V3.20
   5:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  * @date     25. February 2013
   6:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  *
   7:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  * @note
   8:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  *
   9:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  ******************************************************************************/
  10:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  12:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    All rights reserved.
  13:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    Redistribution and use in source and binary forms, with or without
  14:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    modification, are permitted provided that the following conditions are met:
  15:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    - Redistributions of source code must retain the above copyright
  16:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****      notice, this list of conditions and the following disclaimer.
  17:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    - Redistributions in binary form must reproduce the above copyright
  18:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****      notice, this list of conditions and the following disclaimer in the
  19:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****      documentation and/or other materials provided with the distribution.
  20:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****      to endorse or promote products derived from this software without
  22:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****      specific prior written permission.
  23:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    *
  24:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    ---------------------------------------------------------------------------*/
  36:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  37:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  38:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #ifndef __CORE_CMFUNC_H
  39:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #define __CORE_CMFUNC_H
  40:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  41:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  42:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* ###########################  Core Function Access  ########################### */
  43:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  44:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  45:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   @{
  46:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
  47:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  48:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* ARM armcc specific functions */
  50:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  51:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if (__ARMCC_VERSION < 400677)
  52:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #endif
  54:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  55:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* intrinsic void __enable_irq();     */
  56:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* intrinsic void __disable_irq();    */
  57:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  58:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Control Register
  59:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  60:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the content of the Control Register.
  61:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  62:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               Control Register value
  63:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
  64:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_CONTROL(void)
  65:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
  66:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  67:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regControl);
  68:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
  69:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  70:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  71:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Control Register
  72:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  73:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function writes the given value to the Control Register.
  74:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  75:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    control  Control Register value to set
  76:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
  77:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_CONTROL(uint32_t control)
  78:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
  79:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regControl         __ASM("control");
  80:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regControl = control;
  81:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
  82:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  83:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  84:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get IPSR Register
  85:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  86:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the content of the IPSR Register.
  87:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  88:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               IPSR Register value
  89:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
  90:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_IPSR(void)
  91:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
  92:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regIPSR          __ASM("ipsr");
  93:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regIPSR);
  94:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
  95:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  96:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  97:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get APSR Register
  98:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
  99:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the content of the APSR Register.
 100:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 101:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               APSR Register value
 102:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 103:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_APSR(void)
 104:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 105:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regAPSR          __ASM("apsr");
 106:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regAPSR);
 107:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 108:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 109:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 110:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get xPSR Register
 111:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 112:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the content of the xPSR Register.
 113:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 114:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               xPSR Register value
 115:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 116:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_xPSR(void)
 117:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 118:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regXPSR          __ASM("xpsr");
 119:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regXPSR);
 120:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 121:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 122:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 123:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Process Stack Pointer
 124:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 125:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current value of the Process Stack Pointer (PSP).
 126:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 127:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               PSP Register value
 128:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 129:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PSP(void)
 130:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 131:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 132:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regProcessStackPointer);
 133:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 134:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 135:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 136:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Process Stack Pointer
 137:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 138:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Process Stack Pointer (PSP).
 139:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 140:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    topOfProcStack  Process Stack Pointer value to set
 141:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 142:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 143:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 144:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regProcessStackPointer  __ASM("psp");
 145:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regProcessStackPointer = topOfProcStack;
 146:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 147:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 148:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 149:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Main Stack Pointer
 150:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 151:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current value of the Main Stack Pointer (MSP).
 152:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 153:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               MSP Register value
 154:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 155:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_MSP(void)
 156:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 157:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 158:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regMainStackPointer);
 159:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 160:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 161:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 162:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Main Stack Pointer
 163:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 164:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Main Stack Pointer (MSP).
 165:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 166:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 167:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 168:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 169:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 170:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regMainStackPointer     __ASM("msp");
 171:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regMainStackPointer = topOfMainStack;
 172:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 173:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 174:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 175:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Priority Mask
 176:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 177:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current state of the priority mask bit from the Priority Mask Registe
 178:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 179:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               Priority Mask value
 180:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 181:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_PRIMASK(void)
 182:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 183:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 184:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regPriMask);
 185:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 186:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 187:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 188:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Priority Mask
 189:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 190:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Priority Mask Register.
 191:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 192:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    priMask  Priority Mask
 193:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 194:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 195:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 196:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regPriMask         __ASM("primask");
 197:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regPriMask = (priMask);
 198:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 199:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 200:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 201:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if       (__CORTEX_M >= 0x03)
 202:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 203:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Enable FIQ
 204:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 205:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function enables FIQ interrupts by clearing the F-bit in the CPSR.
 206:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     Can only be executed in Privileged modes.
 207:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 208:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #define __enable_fault_irq                __enable_fiq
 209:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 210:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 211:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Disable FIQ
 212:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 213:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function disables FIQ interrupts by setting the F-bit in the CPSR.
 214:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     Can only be executed in Privileged modes.
 215:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 216:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #define __disable_fault_irq               __disable_fiq
 217:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 218:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 219:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Base Priority
 220:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 221:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current value of the Base Priority register.
 222:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 223:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               Base Priority register value
 224:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 225:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t  __get_BASEPRI(void)
 226:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 227:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 228:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regBasePri);
 229:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 230:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 231:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 232:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Base Priority
 233:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 234:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Base Priority register.
 235:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 236:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    basePri  Base Priority value to set
 237:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 238:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
 239:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 240:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regBasePri         __ASM("basepri");
 241:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regBasePri = (basePri & 0xff);
 242:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 243:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 244:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 245:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get Fault Mask
 246:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 247:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current value of the Fault Mask register.
 248:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 249:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               Fault Mask register value
 250:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 251:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 252:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 253:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 254:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regFaultMask);
 255:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 256:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 257:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 258:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set Fault Mask
 259:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 260:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Fault Mask register.
 261:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 262:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    faultMask  Fault Mask value to set
 263:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 264:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 265:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 266:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regFaultMask       __ASM("faultmask");
 267:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regFaultMask = (faultMask & (uint32_t)1);
 268:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 269:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 270:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #endif /* (__CORTEX_M >= 0x03) */
 271:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 272:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 273:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if       (__CORTEX_M == 0x04)
 274:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 275:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Get FPSCR
 276:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 277:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function returns the current value of the Floating Point Status/Control register.
 278:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 279:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \return               Floating Point Status/Control register value
 280:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 281:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE uint32_t __get_FPSCR(void)
 282:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 283:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 284:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 285:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   return(__regfpscr);
 286:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #else
 287:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****    return(0);
 288:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #endif
 289:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 290:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 291:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 292:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Set FPSCR
 293:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 294:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     This function assigns the given value to the Floating Point Status/Control register.
 295:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 296:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****     \param [in]    fpscr  Floating Point Status/Control value to set
 297:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 298:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 299:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 300:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
 301:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   register uint32_t __regfpscr         __ASM("fpscr");
 302:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __regfpscr = (fpscr);
 303:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #endif
 304:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 305:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 306:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #endif /* (__CORTEX_M == 0x04) */
 307:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 308:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 309:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 310:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* IAR iccarm specific functions */
 311:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 312:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #include <cmsis_iar.h>
 313:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 314:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 315:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 316:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* TI CCS specific functions */
 317:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 318:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #include <cmsis_ccs.h>
 319:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 320:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 321:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 322:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /* GNU gcc specific functions */
 323:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 324:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Enable IRQ Interrupts
 325:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 326:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   This function enables IRQ interrupts by clearing the I-bit in the CPSR.
 327:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   Can only be executed in Privileged modes.
 328:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 329:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
 330:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 332:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** }
 333:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 334:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 335:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** /** \brief  Disable IRQ Interrupts
 336:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** 
 337:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   This function disables IRQ interrupts by setting the I-bit in the CPSR.
 338:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   Can only be executed in Privileged modes.
 339:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****  */
 340:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
 341:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h **** {
 342:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 486              		.loc 2 342 0
 487              	@ 342 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 488 0010 72B6     		cpsid i
 489              	@ 0 "" 2
 490              		.thumb
 491              	.LBE20:
 492              	.LBE19:
 811:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 812:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "free a null pointer -> do nothing\n" );
 813:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 814:../Dave/Generated/src/LMM001/LMM001.c **** 
 815:../Dave/Generated/src/LMM001/LMM001.c ****   return;
 816:../Dave/Generated/src/LMM001/LMM001.c ****   }
 817:../Dave/Generated/src/LMM001/LMM001.c **** 
 818:../Dave/Generated/src/LMM001/LMM001.c ****   // FIXME: At some point it might be a good idea to add a check to make sure
 819:../Dave/Generated/src/LMM001/LMM001.c ****   //        that the pointer we're being asked to free up is actually within
 820:../Dave/Generated/src/LMM001/LMM001.c ****   //        the umm_heap!
 821:../Dave/Generated/src/LMM001/LMM001.c ****   //
 822:../Dave/Generated/src/LMM001/LMM001.c ****   // NOTE:  See the new LMM001_linfo() function that you can use to see if a MemPtr is
 823:../Dave/Generated/src/LMM001/LMM001.c ****   //        on the free list!
 824:../Dave/Generated/src/LMM001/LMM001.c **** 
 825:../Dave/Generated/src/LMM001/LMM001.c ****   // Protect the critical section...
 826:../Dave/Generated/src/LMM001/LMM001.c ****   //
 827:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_ENTRY();
 828:../Dave/Generated/src/LMM001/LMM001.c **** 
 829:../Dave/Generated/src/LMM001/LMM001.c ****   // Figure out which block we're in. Note the use of truncated division...
 830:../Dave/Generated/src/LMM001/LMM001.c **** 
 831:../Dave/Generated/src/LMM001/LMM001.c **** 
 832:../Dave/Generated/src/LMM001/LMM001.c ****    c = (uint16_t)(((uint32_t)MemPtr- (uint32_t)(&(HandlePtr->umm_heap[0])))/sizeof(LMM001_BlockType
 493              		.loc 1 832 0
 494 0012 3A68     		ldr	r2, [r7, #0]
 495 0014 7B68     		ldr	r3, [r7, #4]
 496 0016 1B68     		ldr	r3, [r3, #0]	@ unaligned
 497 0018 D31A     		subs	r3, r2, r3
 498 001a 4FEAD303 		lsr	r3, r3, #3
 499 001e FB81     		strh	r3, [r7, #14]	@ movhi
 833:../Dave/Generated/src/LMM001/LMM001.c **** 
 834:../Dave/Generated/src/LMM001/LMM001.c ****   DBG_LOG_DEBUG( "Freeing block %6i\n", c );
 835:../Dave/Generated/src/LMM001/LMM001.c **** 
 836:../Dave/Generated/src/LMM001/LMM001.c ****   // Now let's assimilate this block with the next one if possible.
 837:../Dave/Generated/src/LMM001/LMM001.c **** 
 838:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_l_assimilate_up(HandlePtr,c );
 500              		.loc 1 838 0
 501 0020 FB89     		ldrh	r3, [r7, #14]
 502 0022 7868     		ldr	r0, [r7, #4]
 503 0024 1946     		mov	r1, r3
 504 0026 FFF7FEFF 		bl	LMM001_l_assimilate_up
 839:../Dave/Generated/src/LMM001/LMM001.c **** 
 840:../Dave/Generated/src/LMM001/LMM001.c ****   // Then assimilate with the previous block if possible
 841:../Dave/Generated/src/LMM001/LMM001.c **** 
 842:../Dave/Generated/src/LMM001/LMM001.c ****   if( UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK ) {
 505              		.loc 1 842 0
 506 002a 7B68     		ldr	r3, [r7, #4]
 507 002c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 508 002e 7B68     		ldr	r3, [r7, #4]
 509 0030 1968     		ldr	r1, [r3, #0]	@ unaligned
 510 0032 FB89     		ldrh	r3, [r7, #14]
 511 0034 4FEAC303 		lsl	r3, r3, #3
 512 0038 CB18     		adds	r3, r1, r3
 513 003a 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 514 003c 9BB2     		uxth	r3, r3
 515 003e 4FEAC303 		lsl	r3, r3, #3
 516 0042 D318     		adds	r3, r2, r3
 517 0044 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 518 0046 9BB2     		uxth	r3, r3
 519 0048 9BB2     		uxth	r3, r3
 520 004a 1BB2     		sxth	r3, r3
 521 004c 002B     		cmp	r3, #0
 522 004e 09DA     		bge	.L13
 843:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 844:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "Assimilate down to next block, which is FREE\n" );
 845:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 846:../Dave/Generated/src/LMM001/LMM001.c ****     c = LMM001_l_assimilate_down(HandlePtr,c, UMM_FREELIST_MASK);
 523              		.loc 1 846 0
 524 0050 FB89     		ldrh	r3, [r7, #14]
 525 0052 7868     		ldr	r0, [r7, #4]
 526 0054 1946     		mov	r1, r3
 527 0056 4FF40042 		mov	r2, #32768
 528 005a FFF7FEFF 		bl	LMM001_l_assimilate_down
 529 005e 0346     		mov	r3, r0
 530 0060 FB81     		strh	r3, [r7, #14]	@ movhi
 531 0062 39E0     		b	.L14
 532              	.L13:
 847:../Dave/Generated/src/LMM001/LMM001.c ****   } else {
 848:../Dave/Generated/src/LMM001/LMM001.c ****     // The previous block is not a free block, so add this one to the head
 849:../Dave/Generated/src/LMM001/LMM001.c ****     // of the free list
 850:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 851:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "Just add to head of free list\n" );
 852:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 853:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PFREE(HandlePtr,UMM_NFREE(HandlePtr,0)) = c;
 533              		.loc 1 853 0
 534 0064 7B68     		ldr	r3, [r7, #4]
 535 0066 1A68     		ldr	r2, [r3, #0]	@ unaligned
 536 0068 7B68     		ldr	r3, [r7, #4]
 537 006a 1B68     		ldr	r3, [r3, #0]	@ unaligned
 538 006c 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 539 006e 9BB2     		uxth	r3, r3
 540 0070 4FEAC303 		lsl	r3, r3, #3
 541 0074 D318     		adds	r3, r2, r3
 542 0076 FA89     		ldrh	r2, [r7, #14]	@ movhi
 543 0078 DA80     		strh	r2, [r3, #6]	@ unaligned
 854:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NFREE(HandlePtr,c)            = UMM_NFREE(HandlePtr,0);
 544              		.loc 1 854 0
 545 007a 7B68     		ldr	r3, [r7, #4]
 546 007c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 547 007e FB89     		ldrh	r3, [r7, #14]
 548 0080 4FEAC303 		lsl	r3, r3, #3
 549 0084 D318     		adds	r3, r2, r3
 550 0086 7A68     		ldr	r2, [r7, #4]
 551 0088 1268     		ldr	r2, [r2, #0]	@ unaligned
 552 008a 9288     		ldrh	r2, [r2, #4]	@ unaligned
 553 008c 92B2     		uxth	r2, r2
 554 008e 9A80     		strh	r2, [r3, #4]	@ unaligned
 855:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PFREE(HandlePtr,c)            = 0;
 555              		.loc 1 855 0
 556 0090 7B68     		ldr	r3, [r7, #4]
 557 0092 1A68     		ldr	r2, [r3, #0]	@ unaligned
 558 0094 FB89     		ldrh	r3, [r7, #14]
 559 0096 4FEAC303 		lsl	r3, r3, #3
 560 009a D318     		adds	r3, r2, r3
 561 009c 4FF00002 		mov	r2, #0
 562 00a0 9A71     		strb	r2, [r3, #6]
 563 00a2 4FF00002 		mov	r2, #0
 564 00a6 DA71     		strb	r2, [r3, #7]
 856:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NFREE(HandlePtr,0)            = c;
 565              		.loc 1 856 0
 566 00a8 7B68     		ldr	r3, [r7, #4]
 567 00aa 1B68     		ldr	r3, [r3, #0]	@ unaligned
 568 00ac FA89     		ldrh	r2, [r7, #14]	@ movhi
 569 00ae 9A80     		strh	r2, [r3, #4]	@ unaligned
 857:../Dave/Generated/src/LMM001/LMM001.c **** 
 858:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NBLOCK(HandlePtr,c)          |= UMM_FREELIST_MASK;
 570              		.loc 1 858 0
 571 00b0 7B68     		ldr	r3, [r7, #4]
 572 00b2 1A68     		ldr	r2, [r3, #0]	@ unaligned
 573 00b4 FB89     		ldrh	r3, [r7, #14]
 574 00b6 4FEAC303 		lsl	r3, r3, #3
 575 00ba D218     		adds	r2, r2, r3
 576 00bc 7B68     		ldr	r3, [r7, #4]
 577 00be 1968     		ldr	r1, [r3, #0]	@ unaligned
 578 00c0 FB89     		ldrh	r3, [r7, #14]
 579 00c2 4FEAC303 		lsl	r3, r3, #3
 580 00c6 CB18     		adds	r3, r1, r3
 581 00c8 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 582 00ca 9BB2     		uxth	r3, r3
 583 00cc 6FEA4343 		mvn	r3, r3, lsl #17
 584 00d0 6FEA5343 		mvn	r3, r3, lsr #17
 585 00d4 9BB2     		uxth	r3, r3
 586 00d6 1380     		strh	r3, [r2, #0]	@ unaligned
 587              	.L14:
 588              	.LBB21:
 589              	.LBB22:
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 590              		.loc 2 331 0
 591              	@ 331 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 592 00d8 62B6     		cpsie i
 593              	@ 0 "" 2
 594              		.thumb
 595 00da 00E0     		b	.L10
 596              	.L15:
 597              	.LBE22:
 598              	.LBE21:
 815:../Dave/Generated/src/LMM001/LMM001.c ****   return;
 599              		.loc 1 815 0
 600 00dc 00BF     		nop
 601              	.L10:
 859:../Dave/Generated/src/LMM001/LMM001.c ****   }
 860:../Dave/Generated/src/LMM001/LMM001.c **** 
 861:../Dave/Generated/src/LMM001/LMM001.c ****   // Release the critical section...
 862:../Dave/Generated/src/LMM001/LMM001.c ****   //
 863:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_EXIT();
 864:../Dave/Generated/src/LMM001/LMM001.c **** }
 602              		.loc 1 864 0
 603 00de 07F11007 		add	r7, r7, #16
 604 00e2 BD46     		mov	sp, r7
 605 00e4 80BD     		pop	{r7, pc}
 606              		.cfi_endproc
 607              	.LFE125:
 609 00e6 00BF     		.section	.text.LMM001_malloc,"ax",%progbits
 610              		.align	2
 611              		.global	LMM001_malloc
 612              		.thumb
 613              		.thumb_func
 615              	LMM001_malloc:
 616              	.LFB126:
 865:../Dave/Generated/src/LMM001/LMM001.c **** 
 866:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
 867:../Dave/Generated/src/LMM001/LMM001.c **** 
 868:../Dave/Generated/src/LMM001/LMM001.c **** /* The function allocates the memory.*/
 869:../Dave/Generated/src/LMM001/LMM001.c **** void *LMM001_malloc( LMM001_HandleType * HandlePtr, uint32_t size ) {
 617              		.loc 1 869 0
 618              		.cfi_startproc
 619              		@ args = 0, pretend = 0, frame = 24
 620              		@ frame_needed = 1, uses_anonymous_args = 0
 621 0000 80B5     		push	{r7, lr}
 622              	.LCFI18:
 623              		.cfi_def_cfa_offset 8
 624              		.cfi_offset 7, -8
 625              		.cfi_offset 14, -4
 626 0002 86B0     		sub	sp, sp, #24
 627              	.LCFI19:
 628              		.cfi_def_cfa_offset 32
 629 0004 00AF     		add	r7, sp, #0
 630              	.LCFI20:
 631              		.cfi_def_cfa_register 7
 632 0006 7860     		str	r0, [r7, #4]
 633 0008 3960     		str	r1, [r7, #0]
 870:../Dave/Generated/src/LMM001/LMM001.c **** 
 871:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t blocks;
 872:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t blockSize = 0;
 634              		.loc 1 872 0
 635 000a 4FF00003 		mov	r3, #0
 636 000e FB82     		strh	r3, [r7, #22]	@ movhi
 873:../Dave/Generated/src/LMM001/LMM001.c **** 
 874:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t bestSize;
 875:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t bestBlock;
 876:../Dave/Generated/src/LMM001/LMM001.c **** 
 877:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t cf;
 878:../Dave/Generated/src/LMM001/LMM001.c **** 
 879:../Dave/Generated/src/LMM001/LMM001.c ****   // the very first thing we do is figure out if we're being asked to allocate
 880:../Dave/Generated/src/LMM001/LMM001.c ****   // a size of 0 - and if we are we'll simply return a null pointer. if not
 881:../Dave/Generated/src/LMM001/LMM001.c ****   // then reduce the size by 1 byte so that the subsequent calculations on
 882:../Dave/Generated/src/LMM001/LMM001.c ****   // the number of blocks to allocate are easier...
 883:../Dave/Generated/src/LMM001/LMM001.c **** 
 884:../Dave/Generated/src/LMM001/LMM001.c ****   if( 0 == size ) {
 637              		.loc 1 884 0
 638 0010 3B68     		ldr	r3, [r7, #0]
 639 0012 002B     		cmp	r3, #0
 640 0014 02D1     		bne	.L17
 885:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 886:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "malloc a block of 0 bytes -> do nothing\n" );
 887:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 888:../Dave/Generated/src/LMM001/LMM001.c ****     return( (void *)NULL );
 641              		.loc 1 888 0
 642 0016 4FF00003 		mov	r3, #0
 643 001a EDE0     		b	.L18
 644              	.L17:
 645              	.LBB23:
 646              	.LBB24:
 647              		.loc 2 342 0
 648              	@ 342 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 649 001c 72B6     		cpsid i
 650              	@ 0 "" 2
 651              		.thumb
 652              	.LBE24:
 653              	.LBE23:
 889:../Dave/Generated/src/LMM001/LMM001.c ****   }
 890:../Dave/Generated/src/LMM001/LMM001.c **** 
 891:../Dave/Generated/src/LMM001/LMM001.c ****   // Protect the critical section...
 892:../Dave/Generated/src/LMM001/LMM001.c ****   //
 893:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_ENTRY();
 894:../Dave/Generated/src/LMM001/LMM001.c **** 
 895:../Dave/Generated/src/LMM001/LMM001.c ****   blocks = LMM001_lblocks( size );
 654              		.loc 1 895 0
 655 001e 3868     		ldr	r0, [r7, #0]
 656 0020 FFF7FEFF 		bl	LMM001_lblocks
 657 0024 0346     		mov	r3, r0
 658 0026 FB81     		strh	r3, [r7, #14]	@ movhi
 896:../Dave/Generated/src/LMM001/LMM001.c **** 
 897:../Dave/Generated/src/LMM001/LMM001.c ****   // Now we can scan through the free list until we find a space that's big
 898:../Dave/Generated/src/LMM001/LMM001.c ****   // enough to hold the number of blocks we need.
 899:../Dave/Generated/src/LMM001/LMM001.c ****   //
 900:../Dave/Generated/src/LMM001/LMM001.c ****   // This part may be customized to be a best-fit, worst-fit, or first-fit
 901:../Dave/Generated/src/LMM001/LMM001.c ****   // algorithm
 902:../Dave/Generated/src/LMM001/LMM001.c **** 
 903:../Dave/Generated/src/LMM001/LMM001.c ****   cf = UMM_NFREE(HandlePtr,0);
 659              		.loc 1 903 0
 660 0028 7B68     		ldr	r3, [r7, #4]
 661 002a 1B68     		ldr	r3, [r3, #0]	@ unaligned
 662 002c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 663 002e 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 664 0030 4FEA0323 		lsl	r3, r3, #8
 665 0034 1343     		orrs	r3, r3, r2
 666 0036 3B82     		strh	r3, [r7, #16]	@ movhi
 904:../Dave/Generated/src/LMM001/LMM001.c **** 
 905:../Dave/Generated/src/LMM001/LMM001.c ****   bestBlock = UMM_NFREE(HandlePtr,0);
 667              		.loc 1 905 0
 668 0038 7B68     		ldr	r3, [r7, #4]
 669 003a 1B68     		ldr	r3, [r3, #0]	@ unaligned
 670 003c 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 671 003e 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 672 0040 4FEA0323 		lsl	r3, r3, #8
 673 0044 1343     		orrs	r3, r3, r2
 674 0046 7B82     		strh	r3, [r7, #18]	@ movhi
 906:../Dave/Generated/src/LMM001/LMM001.c ****   bestSize  = 0x7FFF;
 675              		.loc 1 906 0
 676 0048 47F6FF73 		movw	r3, #32767
 677 004c BB82     		strh	r3, [r7, #20]	@ movhi
 907:../Dave/Generated/src/LMM001/LMM001.c **** 
 908:../Dave/Generated/src/LMM001/LMM001.c ****   while( UMM_NFREE(HandlePtr,cf) ) {
 678              		.loc 1 908 0
 679 004e 27E0     		b	.L19
 680              	.L21:
 909:../Dave/Generated/src/LMM001/LMM001.c ****     blockSize = (UMM_NBLOCK(HandlePtr,cf) & UMM_BLOCKNO_MASK) - cf;
 681              		.loc 1 909 0
 682 0050 7B68     		ldr	r3, [r7, #4]
 683 0052 1A68     		ldr	r2, [r3, #0]	@ unaligned
 684 0054 3B8A     		ldrh	r3, [r7, #16]
 685 0056 4FEAC303 		lsl	r3, r3, #3
 686 005a D318     		adds	r3, r2, r3
 687 005c 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 688 005e 9BB2     		uxth	r3, r3
 689 0060 4FEA4343 		lsl	r3, r3, #17
 690 0064 4FEA5343 		lsr	r3, r3, #17
 691 0068 9AB2     		uxth	r2, r3
 692 006a 3B8A     		ldrh	r3, [r7, #16]	@ movhi
 693 006c D31A     		subs	r3, r2, r3
 694 006e FB82     		strh	r3, [r7, #22]	@ movhi
 910:../Dave/Generated/src/LMM001/LMM001.c **** 
 911:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_TRACE( "Looking at block %6i size %6i\n", cf, blockSize );
 912:../Dave/Generated/src/LMM001/LMM001.c **** 
 913:../Dave/Generated/src/LMM001/LMM001.c **** #if defined UMM_FIRST_FIT
 914:../Dave/Generated/src/LMM001/LMM001.c ****     // This is the first block that fits!
 915:../Dave/Generated/src/LMM001/LMM001.c ****     if( (blockSize >= blocks) )
 916:../Dave/Generated/src/LMM001/LMM001.c ****         break;
 917:../Dave/Generated/src/LMM001/LMM001.c **** #elif defined UMM_BEST_FIT
 918:../Dave/Generated/src/LMM001/LMM001.c ****     if( (blockSize >= blocks) && (blockSize < bestSize) ) {
 695              		.loc 1 918 0
 696 0070 FA8A     		ldrh	r2, [r7, #22]
 697 0072 FB89     		ldrh	r3, [r7, #14]
 698 0074 9A42     		cmp	r2, r3
 699 0076 07D3     		bcc	.L20
 700              		.loc 1 918 0 is_stmt 0 discriminator 1
 701 0078 FA8A     		ldrh	r2, [r7, #22]
 702 007a BB8A     		ldrh	r3, [r7, #20]
 703 007c 9A42     		cmp	r2, r3
 704 007e 03D2     		bcs	.L20
 919:../Dave/Generated/src/LMM001/LMM001.c ****       bestBlock = cf;
 705              		.loc 1 919 0 is_stmt 1
 706 0080 3B8A     		ldrh	r3, [r7, #16]	@ movhi
 707 0082 7B82     		strh	r3, [r7, #18]	@ movhi
 920:../Dave/Generated/src/LMM001/LMM001.c ****       bestSize  = blockSize;
 708              		.loc 1 920 0
 709 0084 FB8A     		ldrh	r3, [r7, #22]	@ movhi
 710 0086 BB82     		strh	r3, [r7, #20]	@ movhi
 711              	.L20:
 921:../Dave/Generated/src/LMM001/LMM001.c ****     }
 922:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 923:../Dave/Generated/src/LMM001/LMM001.c **** 
 924:../Dave/Generated/src/LMM001/LMM001.c ****     cf = UMM_NFREE(HandlePtr,cf);
 712              		.loc 1 924 0
 713 0088 7B68     		ldr	r3, [r7, #4]
 714 008a 1A68     		ldr	r2, [r3, #0]	@ unaligned
 715 008c 3B8A     		ldrh	r3, [r7, #16]
 716 008e 4FEAC303 		lsl	r3, r3, #3
 717 0092 D318     		adds	r3, r2, r3
 718 0094 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 719 0096 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 720 0098 4FEA0323 		lsl	r3, r3, #8
 721 009c 1343     		orrs	r3, r3, r2
 722 009e 3B82     		strh	r3, [r7, #16]	@ movhi
 723              	.L19:
 908:../Dave/Generated/src/LMM001/LMM001.c ****   while( UMM_NFREE(HandlePtr,cf) ) {
 724              		.loc 1 908 0 discriminator 1
 725 00a0 7B68     		ldr	r3, [r7, #4]
 726 00a2 1A68     		ldr	r2, [r3, #0]	@ unaligned
 727 00a4 3B8A     		ldrh	r3, [r7, #16]
 728 00a6 4FEAC303 		lsl	r3, r3, #3
 729 00aa D318     		adds	r3, r2, r3
 730 00ac 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 731 00ae 9BB2     		uxth	r3, r3
 732 00b0 002B     		cmp	r3, #0
 733 00b2 CDD1     		bne	.L21
 925:../Dave/Generated/src/LMM001/LMM001.c ****   }
 926:../Dave/Generated/src/LMM001/LMM001.c **** 
 927:../Dave/Generated/src/LMM001/LMM001.c ****   if( 0x7FFF != bestSize ) {
 734              		.loc 1 927 0
 735 00b4 BA8A     		ldrh	r2, [r7, #20]
 736 00b6 47F6FF73 		movw	r3, #32767
 737 00ba 9A42     		cmp	r2, r3
 738 00bc 03D0     		beq	.L22
 928:../Dave/Generated/src/LMM001/LMM001.c ****     cf        = bestBlock;
 739              		.loc 1 928 0
 740 00be 7B8A     		ldrh	r3, [r7, #18]	@ movhi
 741 00c0 3B82     		strh	r3, [r7, #16]	@ movhi
 929:../Dave/Generated/src/LMM001/LMM001.c ****     blockSize = bestSize;
 742              		.loc 1 929 0
 743 00c2 BB8A     		ldrh	r3, [r7, #20]	@ movhi
 744 00c4 FB82     		strh	r3, [r7, #22]	@ movhi
 745              	.L22:
 930:../Dave/Generated/src/LMM001/LMM001.c ****   }
 931:../Dave/Generated/src/LMM001/LMM001.c **** 
 932:../Dave/Generated/src/LMM001/LMM001.c ****   if( UMM_NBLOCK(HandlePtr,cf) & UMM_BLOCKNO_MASK ) {
 746              		.loc 1 932 0
 747 00c6 7B68     		ldr	r3, [r7, #4]
 748 00c8 1A68     		ldr	r2, [r3, #0]	@ unaligned
 749 00ca 3B8A     		ldrh	r3, [r7, #16]
 750 00cc 4FEAC303 		lsl	r3, r3, #3
 751 00d0 D318     		adds	r3, r2, r3
 752 00d2 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 753 00d4 9BB2     		uxth	r3, r3
 754 00d6 4FEA4343 		lsl	r3, r3, #17
 755 00da 4FEA5343 		lsr	r3, r3, #17
 756 00de 002B     		cmp	r3, #0
 757 00e0 1DD0     		beq	.L23
 933:../Dave/Generated/src/LMM001/LMM001.c ****     // This is an existing block in the memory heap, we just need to split off
 934:../Dave/Generated/src/LMM001/LMM001.c ****     // what we need, unlink it from the free list and mark it as in use, and
 935:../Dave/Generated/src/LMM001/LMM001.c ****     // link the rest of the block back into the freelist as if it was a new
 936:../Dave/Generated/src/LMM001/LMM001.c ****     // block on the free list...
 937:../Dave/Generated/src/LMM001/LMM001.c **** 
 938:../Dave/Generated/src/LMM001/LMM001.c ****     if( blockSize == blocks ) {
 758              		.loc 1 938 0
 759 00e2 FA8A     		ldrh	r2, [r7, #22]
 760 00e4 FB89     		ldrh	r3, [r7, #14]
 761 00e6 9A42     		cmp	r2, r3
 762 00e8 05D1     		bne	.L24
 939:../Dave/Generated/src/LMM001/LMM001.c ****       // It's an exact fit and we don't neet to split off a block.
 940:../Dave/Generated/src/LMM001/LMM001.c ****       DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - exact\n", blocks, cf );
 941:../Dave/Generated/src/LMM001/LMM001.c **** 
 942:../Dave/Generated/src/LMM001/LMM001.c ****       // Disconnect this block from the FREE list
 943:../Dave/Generated/src/LMM001/LMM001.c **** 
 944:../Dave/Generated/src/LMM001/LMM001.c ****       LMM001_ldisconnect_from_free_list(HandlePtr, cf );
 763              		.loc 1 944 0
 764 00ea 3B8A     		ldrh	r3, [r7, #16]
 765 00ec 7868     		ldr	r0, [r7, #4]
 766 00ee 1946     		mov	r1, r3
 767 00f0 FFF7FEFF 		bl	LMM001_ldisconnect_from_free_list
 768 00f4 77E0     		b	.L25
 769              	.L24:
 945:../Dave/Generated/src/LMM001/LMM001.c **** 
 946:../Dave/Generated/src/LMM001/LMM001.c ****     } else {
 947:../Dave/Generated/src/LMM001/LMM001.c ****      // It's not an exact fit and we need to split off a block.
 948:../Dave/Generated/src/LMM001/LMM001.c ****      DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - existing\n", blocks, cf );
 949:../Dave/Generated/src/LMM001/LMM001.c **** 
 950:../Dave/Generated/src/LMM001/LMM001.c ****      LMM001_lmake_new_block( HandlePtr,cf, blockSize-blocks, UMM_FREELIST_MASK );
 770              		.loc 1 950 0
 771 00f6 FA8A     		ldrh	r2, [r7, #22]	@ movhi
 772 00f8 FB89     		ldrh	r3, [r7, #14]	@ movhi
 773 00fa D31A     		subs	r3, r2, r3
 774 00fc 9BB2     		uxth	r3, r3
 775 00fe 3A8A     		ldrh	r2, [r7, #16]
 776 0100 7868     		ldr	r0, [r7, #4]
 777 0102 1146     		mov	r1, r2
 778 0104 1A46     		mov	r2, r3
 779 0106 4FF40043 		mov	r3, #32768
 780 010a FFF7FEFF 		bl	LMM001_lmake_new_block
 951:../Dave/Generated/src/LMM001/LMM001.c **** 
 952:../Dave/Generated/src/LMM001/LMM001.c ****      cf += blockSize-blocks;
 781              		.loc 1 952 0
 782 010e FA8A     		ldrh	r2, [r7, #22]	@ movhi
 783 0110 FB89     		ldrh	r3, [r7, #14]	@ movhi
 784 0112 D31A     		subs	r3, r2, r3
 785 0114 9AB2     		uxth	r2, r3
 786 0116 3B8A     		ldrh	r3, [r7, #16]	@ movhi
 787 0118 D318     		adds	r3, r2, r3
 788 011a 3B82     		strh	r3, [r7, #16]	@ movhi
 789 011c 63E0     		b	.L25
 790              	.L23:
 953:../Dave/Generated/src/LMM001/LMM001.c ****      }
 954:../Dave/Generated/src/LMM001/LMM001.c ****   } else {
 955:../Dave/Generated/src/LMM001/LMM001.c ****     // We're at the end of the heap - allocate a new block, but check to see if
 956:../Dave/Generated/src/LMM001/LMM001.c ****     // there's enough memory left for the requested block! Actually, we may need
 957:../Dave/Generated/src/LMM001/LMM001.c ****     // one more than that if we're initializing the umm_heap for the first
 958:../Dave/Generated/src/LMM001/LMM001.c ****     // time, which happens in the next conditional...
 959:../Dave/Generated/src/LMM001/LMM001.c **** 	  if( HandlePtr->umm_numblocks <= cf+blocks+1 ) {
 791              		.loc 1 959 0
 792 011e 7B68     		ldr	r3, [r7, #4]
 793 0120 9B88     		ldrh	r3, [r3, #4]	@ unaligned
 794 0122 9BB2     		uxth	r3, r3
 795 0124 1A46     		mov	r2, r3
 796 0126 398A     		ldrh	r1, [r7, #16]
 797 0128 FB89     		ldrh	r3, [r7, #14]
 798 012a CB18     		adds	r3, r1, r3
 799 012c 03F10103 		add	r3, r3, #1
 800 0130 9A42     		cmp	r2, r3
 801 0132 03DC     		bgt	.L26
 802              	.LBB25:
 803              	.LBB26:
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 804              		.loc 2 331 0
 805              	@ 331 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 806 0134 62B6     		cpsie i
 807              	@ 0 "" 2
 808              		.thumb
 809              	.LBE26:
 810              	.LBE25:
 960:../Dave/Generated/src/LMM001/LMM001.c **** 
 961:../Dave/Generated/src/LMM001/LMM001.c ****       DBG_LOG_DEBUG(  "Can't allocate %5i blocks at %5i\n", blocks, cf );
 962:../Dave/Generated/src/LMM001/LMM001.c **** 
 963:../Dave/Generated/src/LMM001/LMM001.c ****       // Release the critical section...
 964:../Dave/Generated/src/LMM001/LMM001.c ****       //
 965:../Dave/Generated/src/LMM001/LMM001.c ****       LMM001_CRITICAL_EXIT();
 966:../Dave/Generated/src/LMM001/LMM001.c **** 
 967:../Dave/Generated/src/LMM001/LMM001.c ****       return( (void *)NULL );
 811              		.loc 1 967 0
 812 0136 4FF00003 		mov	r3, #0
 813 013a 5DE0     		b	.L18
 814              	.L26:
 968:../Dave/Generated/src/LMM001/LMM001.c ****     }
 969:../Dave/Generated/src/LMM001/LMM001.c **** 
 970:../Dave/Generated/src/LMM001/LMM001.c ****     // Now check to see if we need to initialize the free list...this assumes
 971:../Dave/Generated/src/LMM001/LMM001.c ****     // that the BSS is set to 0 on startup. We should rarely get to the end of
 972:../Dave/Generated/src/LMM001/LMM001.c ****     // the free list so this is the "cheapest" place to put the initialization!
 973:../Dave/Generated/src/LMM001/LMM001.c **** 
 974:../Dave/Generated/src/LMM001/LMM001.c ****     if( 0 == cf ) {
 815              		.loc 1 974 0
 816 013c 3B8A     		ldrh	r3, [r7, #16]
 817 013e 002B     		cmp	r3, #0
 818 0140 16D1     		bne	.L27
 975:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
 976:../Dave/Generated/src/LMM001/LMM001.c ****       DBG_LOG_DEBUG( "Initializing malloc free block pointer\n" );
 977:../Dave/Generated/src/LMM001/LMM001.c **** #endif
 978:../Dave/Generated/src/LMM001/LMM001.c ****       UMM_NBLOCK(HandlePtr,0) = 1;
 819              		.loc 1 978 0
 820 0142 7B68     		ldr	r3, [r7, #4]
 821 0144 1B68     		ldr	r3, [r3, #0]	@ unaligned
 822 0146 4FF00002 		mov	r2, #0
 823 014a 42F00102 		orr	r2, r2, #1
 824 014e 1A70     		strb	r2, [r3, #0]
 825 0150 4FF00002 		mov	r2, #0
 826 0154 5A70     		strb	r2, [r3, #1]
 979:../Dave/Generated/src/LMM001/LMM001.c ****       UMM_NFREE(HandlePtr,0)  = 1;
 827              		.loc 1 979 0
 828 0156 7B68     		ldr	r3, [r7, #4]
 829 0158 1B68     		ldr	r3, [r3, #0]	@ unaligned
 830 015a 4FF00002 		mov	r2, #0
 831 015e 42F00102 		orr	r2, r2, #1
 832 0162 1A71     		strb	r2, [r3, #4]
 833 0164 4FF00002 		mov	r2, #0
 834 0168 5A71     		strb	r2, [r3, #5]
 980:../Dave/Generated/src/LMM001/LMM001.c ****       cf            = 1;
 835              		.loc 1 980 0
 836 016a 4FF00103 		mov	r3, #1
 837 016e 3B82     		strh	r3, [r7, #16]	@ movhi
 838              	.L27:
 981:../Dave/Generated/src/LMM001/LMM001.c ****     }
 982:../Dave/Generated/src/LMM001/LMM001.c **** 
 983:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "Allocating %6i blocks starting at %6i - new     \n", blocks, cf );
 984:../Dave/Generated/src/LMM001/LMM001.c **** 
 985:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NFREE(HandlePtr,UMM_PFREE(HandlePtr,cf)) = cf+blocks;
 839              		.loc 1 985 0
 840 0170 7B68     		ldr	r3, [r7, #4]
 841 0172 1A68     		ldr	r2, [r3, #0]	@ unaligned
 842 0174 7B68     		ldr	r3, [r7, #4]
 843 0176 1968     		ldr	r1, [r3, #0]	@ unaligned
 844 0178 3B8A     		ldrh	r3, [r7, #16]
 845 017a 4FEAC303 		lsl	r3, r3, #3
 846 017e CB18     		adds	r3, r1, r3
 847 0180 DB88     		ldrh	r3, [r3, #6]	@ unaligned
 848 0182 9BB2     		uxth	r3, r3
 849 0184 4FEAC303 		lsl	r3, r3, #3
 850 0188 D318     		adds	r3, r2, r3
 851 018a 398A     		ldrh	r1, [r7, #16]	@ movhi
 852 018c FA89     		ldrh	r2, [r7, #14]	@ movhi
 853 018e 8A18     		adds	r2, r1, r2
 854 0190 92B2     		uxth	r2, r2
 855 0192 9A80     		strh	r2, [r3, #4]	@ unaligned
 986:../Dave/Generated/src/LMM001/LMM001.c **** 
 987:../Dave/Generated/src/LMM001/LMM001.c ****     memcpy( &UMM_BLOCK(HandlePtr,cf+blocks), &UMM_BLOCK(HandlePtr,cf), sizeof(LMM001_BlockType) );
 856              		.loc 1 987 0
 857 0194 7B68     		ldr	r3, [r7, #4]
 858 0196 1A68     		ldr	r2, [r3, #0]	@ unaligned
 859 0198 398A     		ldrh	r1, [r7, #16]
 860 019a FB89     		ldrh	r3, [r7, #14]
 861 019c CB18     		adds	r3, r1, r3
 862 019e 4FEAC303 		lsl	r3, r3, #3
 863 01a2 D218     		adds	r2, r2, r3
 864 01a4 7B68     		ldr	r3, [r7, #4]
 865 01a6 1968     		ldr	r1, [r3, #0]	@ unaligned
 866 01a8 3B8A     		ldrh	r3, [r7, #16]
 867 01aa 4FEAC303 		lsl	r3, r3, #3
 868 01ae CB18     		adds	r3, r1, r3
 869 01b0 1046     		mov	r0, r2
 870 01b2 1946     		mov	r1, r3
 871 01b4 4FF00802 		mov	r2, #8
 872 01b8 FFF7FEFF 		bl	memcpy
 988:../Dave/Generated/src/LMM001/LMM001.c **** 
 989:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_NBLOCK(HandlePtr,cf)           = cf+blocks;
 873              		.loc 1 989 0
 874 01bc 7B68     		ldr	r3, [r7, #4]
 875 01be 1A68     		ldr	r2, [r3, #0]	@ unaligned
 876 01c0 3B8A     		ldrh	r3, [r7, #16]
 877 01c2 4FEAC303 		lsl	r3, r3, #3
 878 01c6 D318     		adds	r3, r2, r3
 879 01c8 398A     		ldrh	r1, [r7, #16]	@ movhi
 880 01ca FA89     		ldrh	r2, [r7, #14]	@ movhi
 881 01cc 8A18     		adds	r2, r1, r2
 882 01ce 92B2     		uxth	r2, r2
 883 01d0 1A80     		strh	r2, [r3, #0]	@ unaligned
 990:../Dave/Generated/src/LMM001/LMM001.c ****     UMM_PBLOCK(HandlePtr,cf+blocks)    = cf;
 884              		.loc 1 990 0
 885 01d2 7B68     		ldr	r3, [r7, #4]
 886 01d4 1A68     		ldr	r2, [r3, #0]	@ unaligned
 887 01d6 398A     		ldrh	r1, [r7, #16]
 888 01d8 FB89     		ldrh	r3, [r7, #14]
 889 01da CB18     		adds	r3, r1, r3
 890 01dc 4FEAC303 		lsl	r3, r3, #3
 891 01e0 D318     		adds	r3, r2, r3
 892 01e2 3A8A     		ldrh	r2, [r7, #16]	@ movhi
 893 01e4 5A80     		strh	r2, [r3, #2]	@ unaligned
 894              	.L25:
 895              	.LBB27:
 896              	.LBB28:
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 897              		.loc 2 331 0
 898              	@ 331 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 899 01e6 62B6     		cpsie i
 900              	@ 0 "" 2
 901              		.thumb
 902              	.LBE28:
 903              	.LBE27:
 991:../Dave/Generated/src/LMM001/LMM001.c ****   }
 992:../Dave/Generated/src/LMM001/LMM001.c **** 
 993:../Dave/Generated/src/LMM001/LMM001.c ****   // Release the critical section...
 994:../Dave/Generated/src/LMM001/LMM001.c ****   //
 995:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_EXIT();
 996:../Dave/Generated/src/LMM001/LMM001.c **** 
 997:../Dave/Generated/src/LMM001/LMM001.c ****   return( (void *)&UMM_DATA(HandlePtr,cf) );
 904              		.loc 1 997 0
 905 01e8 7B68     		ldr	r3, [r7, #4]
 906 01ea 1A68     		ldr	r2, [r3, #0]	@ unaligned
 907 01ec 3B8A     		ldrh	r3, [r7, #16]
 908 01ee 4FEAC303 		lsl	r3, r3, #3
 909 01f2 D318     		adds	r3, r2, r3
 910 01f4 03F10403 		add	r3, r3, #4
 911              	.L18:
 998:../Dave/Generated/src/LMM001/LMM001.c **** }
 912              		.loc 1 998 0
 913 01f8 1846     		mov	r0, r3
 914 01fa 07F11807 		add	r7, r7, #24
 915 01fe BD46     		mov	sp, r7
 916 0200 80BD     		pop	{r7, pc}
 917              		.cfi_endproc
 918              	.LFE126:
 920 0202 00BF     		.section	.text.LMM001_realloc,"ax",%progbits
 921              		.align	2
 922              		.global	LMM001_realloc
 923              		.thumb
 924              		.thumb_func
 926              	LMM001_realloc:
 927              	.LFB127:
 999:../Dave/Generated/src/LMM001/LMM001.c **** 
1000:../Dave/Generated/src/LMM001/LMM001.c **** // ----------------------------------------------------------------------------
1001:../Dave/Generated/src/LMM001/LMM001.c **** 
1002:../Dave/Generated/src/LMM001/LMM001.c **** /* The function reallocates the memory.*/
1003:../Dave/Generated/src/LMM001/LMM001.c **** void *LMM001_realloc(LMM001_HandleType *HandlePtr, void *MemPtr, uint32_t size ) {
 928              		.loc 1 1003 0
 929              		.cfi_startproc
 930              		@ args = 0, pretend = 0, frame = 32
 931              		@ frame_needed = 1, uses_anonymous_args = 0
 932 0000 80B5     		push	{r7, lr}
 933              	.LCFI21:
 934              		.cfi_def_cfa_offset 8
 935              		.cfi_offset 7, -8
 936              		.cfi_offset 14, -4
 937 0002 88B0     		sub	sp, sp, #32
 938              	.LCFI22:
 939              		.cfi_def_cfa_offset 40
 940 0004 00AF     		add	r7, sp, #0
 941              	.LCFI23:
 942              		.cfi_def_cfa_register 7
 943 0006 F860     		str	r0, [r7, #12]
 944 0008 B960     		str	r1, [r7, #8]
 945 000a 7A60     		str	r2, [r7, #4]
1004:../Dave/Generated/src/LMM001/LMM001.c **** 
1005:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t blocks;
1006:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t blockSize;
1007:../Dave/Generated/src/LMM001/LMM001.c **** 
1008:../Dave/Generated/src/LMM001/LMM001.c ****   uint16_t c;
1009:../Dave/Generated/src/LMM001/LMM001.c **** 
1010:../Dave/Generated/src/LMM001/LMM001.c ****   uint32_t curSize;
1011:../Dave/Generated/src/LMM001/LMM001.c **** 
1012:../Dave/Generated/src/LMM001/LMM001.c ****   // This code looks after the case of a NULL value for MemPtr. The ANSI C
1013:../Dave/Generated/src/LMM001/LMM001.c ****   // standard says that if MemPtr is NULL and size is non-zero, then we've
1014:../Dave/Generated/src/LMM001/LMM001.c ****   // got to work the same a malloc(). If size is also 0, then our version
1015:../Dave/Generated/src/LMM001/LMM001.c ****   // of malloc() returns a NULL pointer, which is OK as far as the ANSI C
1016:../Dave/Generated/src/LMM001/LMM001.c ****   // standard is concerned.
1017:../Dave/Generated/src/LMM001/LMM001.c **** 
1018:../Dave/Generated/src/LMM001/LMM001.c ****   if( ((void *)NULL == MemPtr) ) {
 946              		.loc 1 1018 0
 947 000c BB68     		ldr	r3, [r7, #8]
 948 000e 002B     		cmp	r3, #0
 949 0010 05D1     		bne	.L29
1019:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
1020:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc the NULL pointer - call malloc()\n" );
1021:../Dave/Generated/src/LMM001/LMM001.c **** #endif
1022:../Dave/Generated/src/LMM001/LMM001.c ****     return(LMM001_malloc(HandlePtr,size));
 950              		.loc 1 1022 0
 951 0012 F868     		ldr	r0, [r7, #12]
 952 0014 7968     		ldr	r1, [r7, #4]
 953 0016 FFF7FEFF 		bl	LMM001_malloc
 954 001a 0346     		mov	r3, r0
 955 001c C6E0     		b	.L30
 956              	.L29:
1023:../Dave/Generated/src/LMM001/LMM001.c ****   }
1024:../Dave/Generated/src/LMM001/LMM001.c **** 
1025:../Dave/Generated/src/LMM001/LMM001.c ****   // Now we're sure that we have a non_NULL MemPtr, but we're not sure what
1026:../Dave/Generated/src/LMM001/LMM001.c ****   // we should do with it. If the size is 0, then the ANSI C standard says that
1027:../Dave/Generated/src/LMM001/LMM001.c ****   // we should operate the same as free.
1028:../Dave/Generated/src/LMM001/LMM001.c **** 
1029:../Dave/Generated/src/LMM001/LMM001.c ****   if( 0 == size ) {
 957              		.loc 1 1029 0
 958 001e 7B68     		ldr	r3, [r7, #4]
 959 0020 002B     		cmp	r3, #0
 960 0022 06D1     		bne	.L31
1030:../Dave/Generated/src/LMM001/LMM001.c **** #ifdef LMM001_DEBUG
1031:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc to 0 size, just free the block\n" );
1032:../Dave/Generated/src/LMM001/LMM001.c **** #endif
1033:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_free(HandlePtr, MemPtr );
 961              		.loc 1 1033 0
 962 0024 F868     		ldr	r0, [r7, #12]
 963 0026 B968     		ldr	r1, [r7, #8]
 964 0028 FFF7FEFF 		bl	LMM001_free
1034:../Dave/Generated/src/LMM001/LMM001.c ****     
1035:../Dave/Generated/src/LMM001/LMM001.c ****     return( (void *)NULL );
 965              		.loc 1 1035 0
 966 002c 4FF00003 		mov	r3, #0
 967 0030 BCE0     		b	.L30
 968              	.L31:
 969              	.LBB29:
 970              	.LBB30:
 971              		.loc 2 342 0
 972              	@ 342 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 973 0032 72B6     		cpsid i
 974              	@ 0 "" 2
 975              		.thumb
 976              	.LBE30:
 977              	.LBE29:
1036:../Dave/Generated/src/LMM001/LMM001.c ****   }
1037:../Dave/Generated/src/LMM001/LMM001.c **** 
1038:../Dave/Generated/src/LMM001/LMM001.c ****   // Protect the critical section...
1039:../Dave/Generated/src/LMM001/LMM001.c ****   //
1040:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_ENTRY();
1041:../Dave/Generated/src/LMM001/LMM001.c **** 
1042:../Dave/Generated/src/LMM001/LMM001.c ****   // Otherwise we need to actually do a reallocation. A naiive approach
1043:../Dave/Generated/src/LMM001/LMM001.c ****   // would be to malloc() a new block of the correct size, copy the old data
1044:../Dave/Generated/src/LMM001/LMM001.c ****   // to the new block, and then free the old block.
1045:../Dave/Generated/src/LMM001/LMM001.c ****   //
1046:../Dave/Generated/src/LMM001/LMM001.c ****   // While this will work, we end up doing a lot of possibly unnecessary
1047:../Dave/Generated/src/LMM001/LMM001.c ****   // copying. So first, let's figure out how many blocks we'll need.
1048:../Dave/Generated/src/LMM001/LMM001.c **** 
1049:../Dave/Generated/src/LMM001/LMM001.c ****   blocks = LMM001_lblocks( size );
 978              		.loc 1 1049 0
 979 0034 7868     		ldr	r0, [r7, #4]
 980 0036 FFF7FEFF 		bl	LMM001_lblocks
 981 003a 0346     		mov	r3, r0
 982 003c BB83     		strh	r3, [r7, #28]	@ movhi
1050:../Dave/Generated/src/LMM001/LMM001.c **** 
1051:../Dave/Generated/src/LMM001/LMM001.c ****   // Figure out which block we're in. Note the use of truncated division...
1052:../Dave/Generated/src/LMM001/LMM001.c **** 
1053:../Dave/Generated/src/LMM001/LMM001.c **** 
1054:../Dave/Generated/src/LMM001/LMM001.c ****   c = (uint16_t)(((uint32_t)MemPtr- (uint32_t)(&(HandlePtr->umm_heap[0])))/sizeof(LMM001_BlockType)
 983              		.loc 1 1054 0
 984 003e BA68     		ldr	r2, [r7, #8]
 985 0040 FB68     		ldr	r3, [r7, #12]
 986 0042 1B68     		ldr	r3, [r3, #0]	@ unaligned
 987 0044 D31A     		subs	r3, r2, r3
 988 0046 4FEAD303 		lsr	r3, r3, #3
 989 004a FB83     		strh	r3, [r7, #30]	@ movhi
1055:../Dave/Generated/src/LMM001/LMM001.c **** 					  
1056:../Dave/Generated/src/LMM001/LMM001.c ****   // Figure out how big this block is...
1057:../Dave/Generated/src/LMM001/LMM001.c **** 
1058:../Dave/Generated/src/LMM001/LMM001.c ****   blockSize = (UMM_NBLOCK(HandlePtr,c) - c);
 990              		.loc 1 1058 0
 991 004c FB68     		ldr	r3, [r7, #12]
 992 004e 1A68     		ldr	r2, [r3, #0]	@ unaligned
 993 0050 FB8B     		ldrh	r3, [r7, #30]
 994 0052 4FEAC303 		lsl	r3, r3, #3
 995 0056 D318     		adds	r3, r2, r3
 996 0058 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 997 005a 9AB2     		uxth	r2, r3
 998 005c FB8B     		ldrh	r3, [r7, #30]	@ movhi
 999 005e D31A     		subs	r3, r2, r3
 1000 0060 7B83     		strh	r3, [r7, #26]	@ movhi
1059:../Dave/Generated/src/LMM001/LMM001.c **** 
1060:../Dave/Generated/src/LMM001/LMM001.c ****   // Figure out how many bytes are in this block
1061:../Dave/Generated/src/LMM001/LMM001.c ****     
1062:../Dave/Generated/src/LMM001/LMM001.c ****   curSize   = (blockSize*sizeof(LMM001_BlockType))-(sizeof(((LMM001_BlockType *)0)->header));
 1001              		.loc 1 1062 0
 1002 0062 7B8B     		ldrh	r3, [r7, #26]
 1003 0064 4FEAC303 		lsl	r3, r3, #3
 1004 0068 A3F10403 		sub	r3, r3, #4
 1005 006c 7B61     		str	r3, [r7, #20]
1063:../Dave/Generated/src/LMM001/LMM001.c **** 
1064:../Dave/Generated/src/LMM001/LMM001.c ****   // Ok, now that we're here, we know the block number of the original chunk
1065:../Dave/Generated/src/LMM001/LMM001.c ****   // of memory, and we know how much new memory we want, and we know the original
1066:../Dave/Generated/src/LMM001/LMM001.c ****   // block size...
1067:../Dave/Generated/src/LMM001/LMM001.c **** 
1068:../Dave/Generated/src/LMM001/LMM001.c ****   if( blockSize == blocks ) {
 1006              		.loc 1 1068 0
 1007 006e 7A8B     		ldrh	r2, [r7, #26]
 1008 0070 BB8B     		ldrh	r3, [r7, #28]
 1009 0072 9A42     		cmp	r2, r3
 1010 0074 02D1     		bne	.L32
 1011              	.LBB31:
 1012              	.LBB32:
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 1013              		.loc 2 331 0
 1014              	@ 331 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 1015 0076 62B6     		cpsie i
 1016              	@ 0 "" 2
 1017              		.thumb
 1018              	.LBE32:
 1019              	.LBE31:
1069:../Dave/Generated/src/LMM001/LMM001.c ****     // This space intentionally left blank - return the original pointer!
1070:../Dave/Generated/src/LMM001/LMM001.c **** 
1071:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc the same size block - %i, do nothing\n", blocks );
1072:../Dave/Generated/src/LMM001/LMM001.c **** 
1073:../Dave/Generated/src/LMM001/LMM001.c ****     // Release the critical section...
1074:../Dave/Generated/src/LMM001/LMM001.c ****     //
1075:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_CRITICAL_EXIT();
1076:../Dave/Generated/src/LMM001/LMM001.c **** 
1077:../Dave/Generated/src/LMM001/LMM001.c ****     return( MemPtr );
 1020              		.loc 1 1077 0
 1021 0078 BB68     		ldr	r3, [r7, #8]
 1022 007a 97E0     		b	.L30
 1023              	.L32:
1078:../Dave/Generated/src/LMM001/LMM001.c ****   }
1079:../Dave/Generated/src/LMM001/LMM001.c **** 
1080:../Dave/Generated/src/LMM001/LMM001.c ****   // Now we have a block size that could be bigger or smaller. Either
1081:../Dave/Generated/src/LMM001/LMM001.c ****   // way, try to assimilate up to the next block before doing anything...
1082:../Dave/Generated/src/LMM001/LMM001.c ****   //
1083:../Dave/Generated/src/LMM001/LMM001.c ****   // If it's still too small, we have to free it anyways and it will save the
1084:../Dave/Generated/src/LMM001/LMM001.c ****   // assimilation step later in free :-)
1085:../Dave/Generated/src/LMM001/LMM001.c **** 
1086:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_l_assimilate_up(HandlePtr, c );
 1024              		.loc 1 1086 0
 1025 007c FB8B     		ldrh	r3, [r7, #30]
 1026 007e F868     		ldr	r0, [r7, #12]
 1027 0080 1946     		mov	r1, r3
 1028 0082 FFF7FEFF 		bl	LMM001_l_assimilate_up
1087:../Dave/Generated/src/LMM001/LMM001.c **** 
1088:../Dave/Generated/src/LMM001/LMM001.c ****   // Now check if it might help to assimilate down, but don't actually
1089:../Dave/Generated/src/LMM001/LMM001.c ****   // do the downward assimilation unless the resulting block will hold the
1090:../Dave/Generated/src/LMM001/LMM001.c ****   // new request! If this block of code runs, then the new block will
1091:../Dave/Generated/src/LMM001/LMM001.c ****   // either fit the request exactly, or be larger than the request.
1092:../Dave/Generated/src/LMM001/LMM001.c **** 
1093:../Dave/Generated/src/LMM001/LMM001.c ****   if( (UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK) &&
 1029              		.loc 1 1093 0
 1030 0086 FB68     		ldr	r3, [r7, #12]
 1031 0088 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1032 008a FB68     		ldr	r3, [r7, #12]
 1033 008c 1968     		ldr	r1, [r3, #0]	@ unaligned
 1034 008e FB8B     		ldrh	r3, [r7, #30]
 1035 0090 4FEAC303 		lsl	r3, r3, #3
 1036 0094 CB18     		adds	r3, r1, r3
 1037 0096 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 1038 0098 9BB2     		uxth	r3, r3
 1039 009a 4FEAC303 		lsl	r3, r3, #3
 1040 009e D318     		adds	r3, r2, r3
 1041 00a0 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 1042 00a2 9BB2     		uxth	r3, r3
 1043 00a4 9BB2     		uxth	r3, r3
 1044 00a6 1BB2     		sxth	r3, r3
 1045 00a8 002B     		cmp	r3, #0
 1046 00aa 3FDA     		bge	.L33
1094:../Dave/Generated/src/LMM001/LMM001.c ****       (blocks <= (UMM_NBLOCK(HandlePtr,c)-UMM_PBLOCK(HandlePtr,c)))    ) {
 1047              		.loc 1 1094 0 discriminator 1
 1048 00ac BA8B     		ldrh	r2, [r7, #28]
 1049 00ae FB68     		ldr	r3, [r7, #12]
 1050 00b0 1968     		ldr	r1, [r3, #0]	@ unaligned
 1051 00b2 FB8B     		ldrh	r3, [r7, #30]
 1052 00b4 4FEAC303 		lsl	r3, r3, #3
 1053 00b8 CB18     		adds	r3, r1, r3
 1054 00ba 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 1055 00bc 9BB2     		uxth	r3, r3
 1056 00be 1946     		mov	r1, r3
 1057 00c0 FB68     		ldr	r3, [r7, #12]
 1058 00c2 1868     		ldr	r0, [r3, #0]	@ unaligned
 1059 00c4 FB8B     		ldrh	r3, [r7, #30]
 1060 00c6 4FEAC303 		lsl	r3, r3, #3
 1061 00ca C318     		adds	r3, r0, r3
 1062 00cc 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 1063 00ce 9BB2     		uxth	r3, r3
 1064 00d0 CB1A     		subs	r3, r1, r3
1093:../Dave/Generated/src/LMM001/LMM001.c ****   if( (UMM_NBLOCK(HandlePtr,UMM_PBLOCK(HandlePtr,c)) & UMM_FREELIST_MASK) &&
 1065              		.loc 1 1093 0 discriminator 1
 1066 00d2 9A42     		cmp	r2, r3
 1067 00d4 2ADC     		bgt	.L33
1095:../Dave/Generated/src/LMM001/LMM001.c ****   
1096:../Dave/Generated/src/LMM001/LMM001.c ****     // Check if the resulting block would be big enough...
1097:../Dave/Generated/src/LMM001/LMM001.c **** 
1098:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc() could assimilate down %i blocks - fits!\n\r", c-UMM_PBLOCK(c) );
1099:../Dave/Generated/src/LMM001/LMM001.c **** 
1100:../Dave/Generated/src/LMM001/LMM001.c ****     // Disconnect the previous block from the FREE list
1101:../Dave/Generated/src/LMM001/LMM001.c **** 
1102:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_ldisconnect_from_free_list(HandlePtr, UMM_PBLOCK(HandlePtr,c) );
 1068              		.loc 1 1102 0
 1069 00d6 FB68     		ldr	r3, [r7, #12]
 1070 00d8 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1071 00da FB8B     		ldrh	r3, [r7, #30]
 1072 00dc 4FEAC303 		lsl	r3, r3, #3
 1073 00e0 D318     		adds	r3, r2, r3
 1074 00e2 5B88     		ldrh	r3, [r3, #2]	@ unaligned
 1075 00e4 9BB2     		uxth	r3, r3
 1076 00e6 F868     		ldr	r0, [r7, #12]
 1077 00e8 1946     		mov	r1, r3
 1078 00ea FFF7FEFF 		bl	LMM001_ldisconnect_from_free_list
1103:../Dave/Generated/src/LMM001/LMM001.c **** 
1104:../Dave/Generated/src/LMM001/LMM001.c ****     // Connect the previous block to the next block ... and then
1105:../Dave/Generated/src/LMM001/LMM001.c ****     // realign the current block pointer
1106:../Dave/Generated/src/LMM001/LMM001.c **** 
1107:../Dave/Generated/src/LMM001/LMM001.c ****     c = LMM001_l_assimilate_down(HandlePtr,c, 0);
 1079              		.loc 1 1107 0
 1080 00ee FB8B     		ldrh	r3, [r7, #30]
 1081 00f0 F868     		ldr	r0, [r7, #12]
 1082 00f2 1946     		mov	r1, r3
 1083 00f4 4FF00002 		mov	r2, #0
 1084 00f8 FFF7FEFF 		bl	LMM001_l_assimilate_down
 1085 00fc 0346     		mov	r3, r0
 1086 00fe FB83     		strh	r3, [r7, #30]	@ movhi
1108:../Dave/Generated/src/LMM001/LMM001.c **** 
1109:../Dave/Generated/src/LMM001/LMM001.c ****     // Move the bytes down to the new block we just created, but be sure to move
1110:../Dave/Generated/src/LMM001/LMM001.c ****     // only the original bytes.
1111:../Dave/Generated/src/LMM001/LMM001.c **** 
1112:../Dave/Generated/src/LMM001/LMM001.c ****     memmove( (void *)&UMM_DATA(HandlePtr,c), MemPtr, curSize );
 1087              		.loc 1 1112 0
 1088 0100 FB68     		ldr	r3, [r7, #12]
 1089 0102 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1090 0104 FB8B     		ldrh	r3, [r7, #30]
 1091 0106 4FEAC303 		lsl	r3, r3, #3
 1092 010a D318     		adds	r3, r2, r3
 1093 010c 03F10403 		add	r3, r3, #4
 1094 0110 1846     		mov	r0, r3
 1095 0112 B968     		ldr	r1, [r7, #8]
 1096 0114 7A69     		ldr	r2, [r7, #20]
 1097 0116 FFF7FEFF 		bl	memmove
1113:../Dave/Generated/src/LMM001/LMM001.c ****  
1114:../Dave/Generated/src/LMM001/LMM001.c ****     // And don't forget to adjust the pointer to the new block location!
1115:../Dave/Generated/src/LMM001/LMM001.c **** 
1116:../Dave/Generated/src/LMM001/LMM001.c ****     MemPtr    = (void *)&UMM_DATA(HandlePtr,c);
 1098              		.loc 1 1116 0
 1099 011a FB68     		ldr	r3, [r7, #12]
 1100 011c 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1101 011e FB8B     		ldrh	r3, [r7, #30]
 1102 0120 4FEAC303 		lsl	r3, r3, #3
 1103 0124 D318     		adds	r3, r2, r3
 1104 0126 03F10403 		add	r3, r3, #4
 1105 012a BB60     		str	r3, [r7, #8]
 1106              	.L33:
1117:../Dave/Generated/src/LMM001/LMM001.c ****   }
1118:../Dave/Generated/src/LMM001/LMM001.c **** 
1119:../Dave/Generated/src/LMM001/LMM001.c ****   // Now calculate the block size again...and we'll have three cases
1120:../Dave/Generated/src/LMM001/LMM001.c **** 
1121:../Dave/Generated/src/LMM001/LMM001.c ****   blockSize = (UMM_NBLOCK(HandlePtr,c) - c);
 1107              		.loc 1 1121 0
 1108 012c FB68     		ldr	r3, [r7, #12]
 1109 012e 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1110 0130 FB8B     		ldrh	r3, [r7, #30]
 1111 0132 4FEAC303 		lsl	r3, r3, #3
 1112 0136 D318     		adds	r3, r2, r3
 1113 0138 1B88     		ldrh	r3, [r3, #0]	@ unaligned
 1114 013a 9AB2     		uxth	r2, r3
 1115 013c FB8B     		ldrh	r3, [r7, #30]	@ movhi
 1116 013e D31A     		subs	r3, r2, r3
 1117 0140 7B83     		strh	r3, [r7, #26]	@ movhi
1122:../Dave/Generated/src/LMM001/LMM001.c **** 
1123:../Dave/Generated/src/LMM001/LMM001.c ****   if( blockSize == blocks ) {
 1118              		.loc 1 1123 0
 1119 0142 7A8B     		ldrh	r2, [r7, #26]
 1120 0144 BB8B     		ldrh	r3, [r7, #28]
 1121 0146 9A42     		cmp	r2, r3
 1122 0148 2ED0     		beq	.L34
1124:../Dave/Generated/src/LMM001/LMM001.c ****     // This space intentionally left blank - return the original pointer!
1125:../Dave/Generated/src/LMM001/LMM001.c **** 
1126:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc the same size block - %i, do nothing\n", blocks );
1127:../Dave/Generated/src/LMM001/LMM001.c **** 
1128:../Dave/Generated/src/LMM001/LMM001.c ****   } else if (blockSize > blocks ) {
 1123              		.loc 1 1128 0
 1124 014a 7A8B     		ldrh	r2, [r7, #26]
 1125 014c BB8B     		ldrh	r3, [r7, #28]
 1126 014e 9A42     		cmp	r2, r3
 1127 0150 17D9     		bls	.L35
1129:../Dave/Generated/src/LMM001/LMM001.c ****     // New block is smaller than the old block, so just make a new block
1130:../Dave/Generated/src/LMM001/LMM001.c ****     // at the end of this one and put it up on the free list...
1131:../Dave/Generated/src/LMM001/LMM001.c **** 
1132:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc %i to a smaller block %i, shrink and free the leftover bits\n", blockSi
1133:../Dave/Generated/src/LMM001/LMM001.c **** 
1134:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_lmake_new_block(HandlePtr, c, blocks, 0 );
 1128              		.loc 1 1134 0
 1129 0152 FA8B     		ldrh	r2, [r7, #30]
 1130 0154 BB8B     		ldrh	r3, [r7, #28]
 1131 0156 F868     		ldr	r0, [r7, #12]
 1132 0158 1146     		mov	r1, r2
 1133 015a 1A46     		mov	r2, r3
 1134 015c 4FF00003 		mov	r3, #0
 1135 0160 FFF7FEFF 		bl	LMM001_lmake_new_block
1135:../Dave/Generated/src/LMM001/LMM001.c ****     
1136:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_free( HandlePtr,(void *)&UMM_DATA(HandlePtr,c+blocks) );
 1136              		.loc 1 1136 0
 1137 0164 FB68     		ldr	r3, [r7, #12]
 1138 0166 1A68     		ldr	r2, [r3, #0]	@ unaligned
 1139 0168 F98B     		ldrh	r1, [r7, #30]
 1140 016a BB8B     		ldrh	r3, [r7, #28]
 1141 016c CB18     		adds	r3, r1, r3
 1142 016e 4FEAC303 		lsl	r3, r3, #3
 1143 0172 D318     		adds	r3, r2, r3
 1144 0174 03F10403 		add	r3, r3, #4
 1145 0178 F868     		ldr	r0, [r7, #12]
 1146 017a 1946     		mov	r1, r3
 1147 017c FFF7FEFF 		bl	LMM001_free
 1148 0180 12E0     		b	.L34
 1149              	.L35:
 1150              	.LBB33:
1137:../Dave/Generated/src/LMM001/LMM001.c ****   } else {
1138:../Dave/Generated/src/LMM001/LMM001.c ****     // New block is bigger than the old block...
1139:../Dave/Generated/src/LMM001/LMM001.c ****     
1140:../Dave/Generated/src/LMM001/LMM001.c ****     void *oldptr = MemPtr;
 1151              		.loc 1 1140 0
 1152 0182 BB68     		ldr	r3, [r7, #8]
 1153 0184 3B61     		str	r3, [r7, #16]
1141:../Dave/Generated/src/LMM001/LMM001.c **** 
1142:../Dave/Generated/src/LMM001/LMM001.c ****     DBG_LOG_DEBUG( "realloc %i to a bigger block %i, make new, copy, and free the old\n", blockSize
1143:../Dave/Generated/src/LMM001/LMM001.c **** 
1144:../Dave/Generated/src/LMM001/LMM001.c ****     // Now umm_malloc() a new/ one, copy the old data to the new block, and
1145:../Dave/Generated/src/LMM001/LMM001.c ****     // free up the old block, but only if the malloc was sucessful!
1146:../Dave/Generated/src/LMM001/LMM001.c **** 
1147:../Dave/Generated/src/LMM001/LMM001.c ****     MemPtr = LMM001_malloc( HandlePtr,size );
 1154              		.loc 1 1147 0
 1155 0186 F868     		ldr	r0, [r7, #12]
 1156 0188 7968     		ldr	r1, [r7, #4]
 1157 018a FFF7FEFF 		bl	LMM001_malloc
 1158 018e B860     		str	r0, [r7, #8]
1148:../Dave/Generated/src/LMM001/LMM001.c **** 	if(MemPtr != NULL) {
 1159              		.loc 1 1148 0
 1160 0190 BB68     		ldr	r3, [r7, #8]
 1161 0192 002B     		cmp	r3, #0
 1162 0194 04D0     		beq	.L36
1149:../Dave/Generated/src/LMM001/LMM001.c ****        memcpy( MemPtr, oldptr, curSize );
 1163              		.loc 1 1149 0
 1164 0196 B868     		ldr	r0, [r7, #8]
 1165 0198 3969     		ldr	r1, [r7, #16]
 1166 019a 7A69     		ldr	r2, [r7, #20]
 1167 019c FFF7FEFF 		bl	memcpy
 1168              	.L36:
1150:../Dave/Generated/src/LMM001/LMM001.c ****     }
1151:../Dave/Generated/src/LMM001/LMM001.c **** 
1152:../Dave/Generated/src/LMM001/LMM001.c ****     LMM001_free( HandlePtr,oldptr );
 1169              		.loc 1 1152 0
 1170 01a0 F868     		ldr	r0, [r7, #12]
 1171 01a2 3969     		ldr	r1, [r7, #16]
 1172 01a4 FFF7FEFF 		bl	LMM001_free
 1173              	.L34:
 1174              	.LBE33:
 1175              	.LBB34:
 1176              	.LBB35:
 331:C:\DAVE-3.1.10\eclipse\/../CMSIS/Include\core_cmFunc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 1177              		.loc 2 331 0
 1178              	@ 331 "C:\DAVE-3.1.10\eclipse\/../CMSIS/Include/core_cmFunc.h" 1
 1179 01a8 62B6     		cpsie i
 1180              	@ 0 "" 2
 1181              		.thumb
 1182              	.LBE35:
 1183              	.LBE34:
1153:../Dave/Generated/src/LMM001/LMM001.c ****   }
1154:../Dave/Generated/src/LMM001/LMM001.c **** 
1155:../Dave/Generated/src/LMM001/LMM001.c ****   // Release the critical section...
1156:../Dave/Generated/src/LMM001/LMM001.c ****   //
1157:../Dave/Generated/src/LMM001/LMM001.c ****   LMM001_CRITICAL_EXIT();
1158:../Dave/Generated/src/LMM001/LMM001.c **** 
1159:../Dave/Generated/src/LMM001/LMM001.c ****   return( MemPtr );
 1184              		.loc 1 1159 0
 1185 01aa BB68     		ldr	r3, [r7, #8]
 1186              	.L30:
1160:../Dave/Generated/src/LMM001/LMM001.c **** }
 1187              		.loc 1 1160 0
 1188 01ac 1846     		mov	r0, r3
 1189 01ae 07F12007 		add	r7, r7, #32
 1190 01b2 BD46     		mov	sp, r7
 1191 01b4 80BD     		pop	{r7, pc}
 1192              		.cfi_endproc
 1193              	.LFE127:
 1195 01b6 00BF     		.text
 1196              	.Letext0:
 1197              		.file 3 "c:\\dave-3.1.10\\arm-gcc\\bin\\../lib/gcc/arm-none-eabi/4.7.4/../../../../arm-none-eabi/i
 1198              		.file 4 "C:\\DAVE_WorkSpace\\20\\CORE_Larix_V1.0\\Dave\\Generated\\inc\\DAVESupport/../../inc/LMM0
 1199              		.file 5 "C:\\DAVE-3.1.10\\eclipse\\/../CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 LMM001.c
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:20     .text.LMM001_lblocks:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:24     .text.LMM001_lblocks:00000000 LMM001_lblocks
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:72     .text.LMM001_lmake_new_block:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:76     .text.LMM001_lmake_new_block:00000000 LMM001_lmake_new_block
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:170    .text.LMM001_ldisconnect_from_free_list:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:174    .text.LMM001_ldisconnect_from_free_list:00000000 LMM001_ldisconnect_from_free_list
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:260    .text.LMM001_l_assimilate_up:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:264    .text.LMM001_l_assimilate_up:00000000 LMM001_l_assimilate_up
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:367    .text.LMM001_l_assimilate_down:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:371    .text.LMM001_l_assimilate_down:00000000 LMM001_l_assimilate_down
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:454    .text.LMM001_free:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:459    .text.LMM001_free:00000000 LMM001_free
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:610    .text.LMM001_malloc:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:615    .text.LMM001_malloc:00000000 LMM001_malloc
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:921    .text.LMM001_realloc:00000000 $t
C:\Users\Andreas\AppData\Local\Temp\cc7i2pCh.s:926    .text.LMM001_realloc:00000000 LMM001_realloc
                     .debug_frame:00000010 $d
                           .group:00000000 wm4.1.84cfd71c6d2dc0bd4021712beaa9efd8
                           .group:00000000 wm4.XMC4500.h.45.215f4b8c79f46c7645c15373868d08c0
                           .group:00000000 wm4.core_cm4.h.47.41af406cb4cda82c972f112a9cd0a024
                           .group:00000000 wm4.newlib.h.8.a9901dc52d1357e3e94003403d43f8b5
                           .group:00000000 wm4.features.h.22.b72b3baab2bb2eab3661375590100b6b
                           .group:00000000 wm4.config.h.193.5fb8ef056cdff92dec3dee9552839d8c
                           .group:00000000 wm4._ansi.h.23.7aefdac4826acebbfc9f3822a0aeb14c
                           .group:00000000 wm4.stdint.h.20.54ad762faa59e3c05491630641c8d8bf
                           .group:00000000 wm4.core_cmInstr.h.39.3d3d1b4a79aef37532666dc6ee87c6ac
                           .group:00000000 wm4.core_cm4_simd.h.43.b5d1d38735af6366227b4256d330cf13
                           .group:00000000 wm4.core_cm4.h.178.e5ef5ce66d198d7f00f9d0076e267c41
                           .group:00000000 wm4.system_XMC4500.h.29.827f68baa362c84f2abae4ab67dde7c9
                           .group:00000000 wm4.XMC4500.h.198.8e022f279ff353ed081df898dc7b9cf3
                           .group:00000000 wm4.stddef.h.40.50cf36416e06376af8a9dca28536f2e4
                           .group:00000000 wm4.types.h.60.e75c47576398c648cdcf9000ace5e3d8
                           .group:00000000 wm4.MULTIPLEXER.h.46.4a863fbae1c79f0db26da3ce2dc30d02
                           .group:00000000 wm4.CCU8PWMLIB.h.74.725ec81203769525cc7a424597055f47
                           .group:00000000 wm4.MOTORLIB.h.62.951091d95913dd2ff36d761323a1771d
                           .group:00000000 wm4.DBG001.h.116.d6d9e7459a0faa3905c97c1d2edb339d
                           .group:00000000 wm4.uc_id.h.35.fa57ecd9f559d2767f56c96da2848c12
                           .group:00000000 wm4.CLK001_Const.h.50.e5e9c2ddc89f4cc9e7b93e9648fa94e4
                           .group:00000000 wm4.CLK001_Conf.h.81.851ac7a1268528f4d6739384c2f248a5
                           .group:00000000 wm4._default_types.h.6.5e12cd604db8ce00b62bb2f02708eaf3
                           .group:00000000 wm4.lock.h.2.9bc98482741e5e2a9450b12934a684ea
                           .group:00000000 wm4.stddef.h.161.c6104a0666cf681b6269ddc9b4f516d4
                           .group:00000000 wm4.types.h.2.e9cec8c90ab35f77d9f499e06ae02400
                           .group:00000000 wm4.types.h.80.1f2c84c0d57dd52dd9936095d9ac218e
                           .group:00000000 wm4.time.h.16.a4579e68956d2601c6113814b546764b
                           .group:00000000 wm4.RTC001.h.113.715d6fcab1863c6656b238bddd304166
                           .group:00000000 wm4.lmm001_debuglog.h.40.8031299705ecf04ad726bd19baff976d
                           .group:00000000 wm4.reent.h.11.a39e4126dcf3c6afd3054e0622577bae
                           .group:00000000 wm4.stddef.h.161.e50ff8a9d5d1abbc15641da28ac571bf
                           .group:00000000 wm4.string.h.86.d5c872ff52e2712c985b588a0ef39f3c
                           .group:00000000 wm4.LMM001.h.45.fa2df8bae969f45df5071221ac433ffa
                           .group:00000000 wm4.stdio.h.27.f2ac352bab34f31f9f478442827b2ba6
                           .group:00000000 wm4.stdarg.h.34.3a23a216c0c293b3d2ea2e89281481e6
                           .group:00000000 wm4.stdio.h.2.4aa87247282eca6c8f36f9de33d8df1a
                           .group:00000000 wm4.stdio.h.63.dfdea6580b080784d08faace69b6ed76
                           .group:00000000 wm4.stdlib.h.13.603ed7eb09a1561ab06840b7c0fcff58
                           .group:00000000 wm4.alloca.h.8.dfc0c703c47ec3e69746825b17d9e66d
                           .group:00000000 wm4.stdlib.h.53.c69c7609933ff56d59c757cec2d13230
                           .group:00000000 wm4.time.h.2.9857e62ad6ac99431e29d58067232314
                           .group:00000000 wm4.time.h.24.c499d4c1915694df17abb795fd34b719
                           .group:00000000 wm4.time.h.124.10ced469f846269cafc58b59c853e1bb
                           .group:00000000 wm4.errno.h.2.ba016d646105af6cad23be83630b6a3f
                           .group:00000000 wm4.errno.h.9.65044c2b5d8494e43f5986ab0a1d770f
                           .group:00000000 wm4.unistd.h.2.6ce1b91c4223f6078c1b210c7538c1d2
                           .group:00000000 wm4.unistd.h.251.605bc560cdc6c3b07b599bb71ac4e425
                           .group:00000000 wm4.malloc.h.4.62bd13b8107d5245f60bd92bb5994838
                           .group:00000000 wm4.malloc.h.148.73b7de3bd065dafbd594b04197a9466e
                           .group:00000000 wm4.reent.h.91.faac4d0ac97c0fcf23d10d0786197642
                           .group:00000000 wm4.SLTHA003.h.104.05371e300b30617373255b3cdb4765a2
                           .group:00000000 wm4.SYSTM001.h.64.6ecb31c49bc3e7691644fdcdfc11b5cd
                           .group:00000000 wm4.stdarg.h.31.fa591a4b1df9e413e9f5b8097f9ae89d
                           .group:00000000 wm4.Type_CM.h.61.3660c940695d7d5fef91de9c4081d0f0
                           .group:00000000 wm4.dwc_os.h.82.db2ca40c41e2f648d146b8942e5157d9
                           .group:00000000 wm4.dwc_otg_core_if.h.95.37e41eee47e9a4502e4044edf60ea92d
                           .group:00000000 wm4.usbcore001_device.h.107.6c032c9c28ac6c3f4e5e24a068720cd7
                           .group:00000000 wm4.USB.h.399.44a2bec94122294f06c4d854450494d3
                           .group:00000000 wm4.Common.h.102.bc881ac788d1d7ce84e651cbaa40f2c2
                           .group:00000000 wm4.Common.h.134.5069b632a0407201156f18fde915b80c
                           .group:00000000 wm4.USBMode.h.234.0cc9e23131c025605bb7c0db3ebb8ac9
                           .group:00000000 wm4.StdRequestType.h.93.4e19c7c655f990c2abedbb76a546fcde
                           .group:00000000 wm4.Endpoint.h.116.4ef46b127c9047ed49fe1e0df19e09b8
                           .group:00000000 wm4.StdDescriptors.h.120.0ce817e16dcc91b8cf4a79ba0e0e19b6
                           .group:00000000 wm4.CDC.h.103.7ce3e4692dde29e827f8736493eef7ef
                           .group:00000000 wm4.CDC.h.115.c83a7d6c5b6c8644b3dec6212d4ced09
                           .group:00000000 wm4.Descriptors.h.91.5cf84c2489ee54d154cabfe9e14b5c19
                           .group:00000000 wm4.Usic.h.54.8af9f733ba5771eeb374435d205ea54b
                           .group:00000000 wm4.UART001_Conf.h.53.fce01a2aa073e958cae0b1cc894db26c
                           .group:00000000 wm4.UART001.h.109.3e835815a7a59791d8bd39655f4d4cc9
                           .group:00000000 wm4.CCU4Global_Conf.h.63.a52fac0daa39b5f58343578312b4eb54
                           .group:00000000 wm4.PWMSP001.h.57.29b732b86baf3e81f49153f5f495912e
                           .group:00000000 wm4.NVIC002_Conf.h.63.2cf6f4b7cf62c0c8f8d5baa4db880def
                           .group:00000000 wm4.I2C001.h.97.5277d52889d6c741e048ea45ee1277b5
                           .group:00000000 wm4.I2C001_Conf.h.58.e471e519f7471a50493b6f4fe912ee0d
                           .group:00000000 wm4.ERU001_Conf.h.69.6d7c31a774e428b1dc8770c7c31047dd
                           .group:00000000 wm4.ERU002_Conf.h.49.47045c766c6d22ab1185285e9d568758
                           .group:00000000 wm4.IO002_Conf.h.51.be0baad511cf66771895fab0bf90f390

UNDEFINED SYMBOLS
memcpy
memmove
