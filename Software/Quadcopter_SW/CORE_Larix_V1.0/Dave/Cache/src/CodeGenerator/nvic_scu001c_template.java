package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class nvic_scu001c_template
{
  protected static String nl;
  public static synchronized nvic_scu001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    nvic_scu001c_template result = new nvic_scu001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = NL + "/*CODE_BLOCK_BEGIN[NVIC_SCU001.c]*/";
  protected final String TEXT_2 = NL + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Jan 21, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @file   NVIC_SCU001.c" + NL + " * " + NL + " * @brief  NVIC_SCU001 App" + NL + " */" + NL + "/* Revision History" + NL + " * " + NL + " * 21 Jan 2013  v1.0.10   Removed DBG002_FUNCTION_ENTRY &  DBG002_FUNCTION_EXIT" + NL + " *                        invocation from IRQ handler." + NL + " * " + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** PAE        App Developer                                                   **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "/** Inclusion of header file */" + NL + "" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_3 = NL;
  protected final String TEXT_4 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_5 = "                  " + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_NVIC_SCU001" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "void SCU_0_IRQHandler(void);" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "NVIC_SCU001_HandleType NVIC_SCU001_Handle0;" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*  Function to configure SCU Interrupts based on  user configuration." + NL + " * " + NL + " */" + NL + "void NVIC_SCU001_Init()" + NL + "{" + NL + " DBG002_FUNCTION_ENTRY(APP_GID,NVIC_SCU001_FUNC_ENTRY);";
  protected final String TEXT_6 = NL + "  NVIC_SetPriority((IRQn_Type)";
  protected final String TEXT_7 = ", NVIC_EncodePriority(NVIC_GetPriorityGrouping(),";
  protected final String TEXT_8 = ",";
  protected final String TEXT_9 = "));" + NL + "  /* Enable Interrupt */" + NL + "  NVIC_EnableIRQ((IRQn_Type)";
  protected final String TEXT_10 = "); ";
  protected final String TEXT_11 = NL + " " + NL + "  DBG002_FUNCTION_EXIT(APP_GID,NVIC_SCU001_FUNC_EXIT);" + NL + "}" + NL + "" + NL + "/*  Utility function to register Event Handler for a given event." + NL + " * " + NL + " */" + NL + "void NVIC_SCU001_RegisterCallback" + NL + "(" + NL + "  NVIC_SCU001_InterruptType IntID," + NL + "  NVIC_SCU001_CallbackType userFunction," + NL + "  uint32_t CbArgs" + NL + " )" + NL + "{" + NL + "  /*<<<DD_NVIC_SCU001_API_2>>>*/" + NL + "  NVIC_SCU001_HandleType* Handle = &NVIC_SCU001_Handle0;" + NL + "  DBG002_FUNCTION_ENTRY(APP_GID,NVIC_SCU001_FUNC_ENTRY);" + NL + "  Handle->SCU[IntID].CbListener = userFunction;" + NL + "  Handle->SCU[IntID].CbArg = CbArgs;" + NL + "   DBG002_FUNCTION_EXIT(APP_GID,NVIC_SCU001_FUNC_EXIT);" + NL + "}" + NL + "" + NL + "" + NL + "/*  SCU Interrupt Handler." + NL + " * " + NL + " */" + NL + "void SCU_0_IRQHandler(void)" + NL + "{" + NL + "  NVIC_SCU001_CallbackType UserCallback;" + NL + "  NVIC_SCU001_HandleType* Handle = &NVIC_SCU001_Handle0;" + NL + "  uint32_t callbackArg = 0;" + NL + "  uint32_t IrqActive= 0;" + NL + "  /* read the interrupt status Register */" + NL + "  IrqActive = SCU_INTERRUPT->SRSTAT;" + NL + "  " + NL + "  " + NL + "  /* WDT pre-warning Interrupt */" + NL + "  if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_PRWARN_Msk, SCU_INTERRUPT_SRSTAT_PRWARN_Pos))" + NL + "  {" + NL + "    /* run the listener function */" + NL + "    if(Handle->SCU[NVIC_SCU001_PRWARN].CbListener != NULL)" + NL + "    {" + NL + "      UserCallback = Handle->SCU[NVIC_SCU001_PRWARN].CbListener;" + NL + "      callbackArg = Handle->SCU[NVIC_SCU001_PRWARN].CbArg;" + NL + "      UserCallback(callbackArg);" + NL + "    }" + NL + "    /* clear the interrupt */" + NL + "    SCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_PRWARN_Msk;" + NL + "  }" + NL + "  /* RTC Periodic Interrupt */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_PI_Msk, SCU_INTERRUPT_SRSTAT_PI_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_PI].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_PI].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_PI].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_PI_Msk;" + NL + "  }" + NL + "  /* RTC Alarm Interrupt  */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_AI_Msk, SCU_INTERRUPT_SRSTAT_AI_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_AI].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_AI].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_AI].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_AI_Msk;" + NL + "  }" + NL + "  /* DLR Request Overrun Interrupt  */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_DLROVR_Msk, SCU_INTERRUPT_SRSTAT_DLROVR_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_DLROVR].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_DLROVR].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_DLROVR].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_DLROVR_Msk;" + NL + "  }" + NL + "  /* HDSTAT Mirror Register Update Status  */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDSTAT_Msk, SCU_INTERRUPT_SRSTAT_HDSTAT_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_HDSTAT].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_HDSTAT].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_HDSTAT].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDSTAT_Msk;" + NL + "  }" + NL + "  /* HDCLR Mirror Register Update  */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDCLR_Msk, SCU_INTERRUPT_SRSTAT_HDCLR_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_HDCLR].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_HDCLR].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_HDCLR].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDCLR_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* HDSET Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDSET_Msk, SCU_INTERRUPT_SRSTAT_HDSET_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_HDSET].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_HDSET].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_HDSET].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDSET_Msk;" + NL + "\t" + NL + "  } " + NL + "  /* HDCR Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_HDCR_Msk, SCU_INTERRUPT_SRSTAT_HDCR_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_HDCR].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_HDCR].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_HDCR].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_HDCR_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* OSCSICTRL Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCSICTRL_Msk, SCU_INTERRUPT_SRSTAT_OSCSICTRL_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_OSCSICTRL].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_OSCSICTRL].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_OSCSICTRL].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCSICTRL_Msk;" + NL + "\t" + NL + "  } " + NL + "  /* OSCULSTAT Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCULSTAT_Msk, SCU_INTERRUPT_SRSTAT_OSCULSTAT_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_OSCULSTAT].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_OSCULSTAT].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_OSCULSTAT].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCULSTAT_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* OSCULCTRL Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_OSCULCTRL_Msk, SCU_INTERRUPT_SRSTAT_OSCULCTRL_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_OSCULCTRL].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_OSCULCTRL].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_OSCULCTRL].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_OSCULCTRL_Msk;" + NL + "\t" + NL + "  } " + NL + "  /* RTC_CTR Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_CTR_Msk, SCU_INTERRUPT_SRSTAT_RTC_CTR_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RTC_CTR].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RTC_CTR].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RTC_CTR].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_CTR_Msk;" + NL + "\t" + NL + "  } " + NL + "  /* RTC_ATIM0 Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Msk, SCU_INTERRUPT_SRSTAT_RTC_ATIM0_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RTC_ATIM0].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_ATIM0_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* RTC_ATIM1 Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Msk, SCU_INTERRUPT_SRSTAT_RTC_ATIM1_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RTC_ATIM1].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_ATIM1_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* RTC_TIM0 Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_TIM0_Msk, SCU_INTERRUPT_SRSTAT_RTC_TIM0_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RTC_TIM0].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RTC_TIM0].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RTC_TIM0].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_TIM0_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* RTC_TIM1 Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RTC_TIM1_Msk, SCU_INTERRUPT_SRSTAT_RTC_TIM1_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RTC_TIM1].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RTC_TIM1].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RTC_TIM1].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RTC_TIM1_Msk;" + NL + "\t" + NL + "  }" + NL + "  /* Retention Memory Mirror Register Update Status */" + NL + "  else if(RD_REG(IrqActive,SCU_INTERRUPT_SRSTAT_RMX_Msk, SCU_INTERRUPT_SRSTAT_RMX_Pos))" + NL + "  {" + NL + "\t/* run the listener function */" + NL + "\tif(Handle->SCU[NVIC_SCU001_RMX].CbListener != NULL)" + NL + "\t{" + NL + "\t  UserCallback = Handle->SCU[NVIC_SCU001_RMX].CbListener;" + NL + "\t  callbackArg = Handle->SCU[NVIC_SCU001_RMX].CbArg;" + NL + "\t  UserCallback(callbackArg);" + NL + "\t}" + NL + "\t/* clear the interrupt */" + NL + "\tSCU_INTERRUPT->SRCLR |= SCU_INTERRUPT_SRCLR_RMX_Msk;" + NL + "\t" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    /* If we've reached this point, either the enabling and" + NL + "     * disabling of SCU interrupts is not being handled" + NL + "     * properly or this function is being called unnecessarily." + NL + "     */" + NL + "  }" + NL + "  " + NL + "  " + NL + "}" + NL + "" + NL + "" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_12 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     String AppBaseuri = "app/nvic_scu001/";
     String MappedUri = null; 
     String NodeID = null; 
    stringBuffer.append(TEXT_2);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_3);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_4);
     } 
    stringBuffer.append(TEXT_5);
     String appInst  = null; 
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/nvic_scu001/"));
  for (String appIns : appsList ) {
  appInst = appIns.substring(appIns.lastIndexOf("/")+1);
  MappedUri = app.getMappedUri(AppBaseuri + appInst + "/scunode"); 
  if((MappedUri != null) && (MappedUri != "")) { 
  NodeID = MappedUri.substring(MappedUri.lastIndexOf('/')+ 1 );
  int Priority = app.getIntegerValue(AppBaseuri + appInst +"/NVIC_SCU001_irwInterruptPriority");
  int SubPriority = app.getIntegerValue(AppBaseuri + appInst +"/NVIC_SCU001_irwInterruptSubPriority"); 
    stringBuffer.append(TEXT_6);
    stringBuffer.append(NodeID);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(Priority);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(SubPriority);
    stringBuffer.append(TEXT_9);
    stringBuffer.append(NodeID);
    stringBuffer.append(TEXT_10);
     }}
    stringBuffer.append(TEXT_11);
    stringBuffer.append(TEXT_12);
    return stringBuffer.toString();
  }
}
