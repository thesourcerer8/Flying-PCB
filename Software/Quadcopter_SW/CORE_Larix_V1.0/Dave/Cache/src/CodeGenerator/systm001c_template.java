package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class systm001c_template
{
  protected static String nl;
  public static synchronized systm001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    systm001c_template result = new systm001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[SYSTM001.c]*/" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2014, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000/XMC1xxx Series                                 **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Jan 29, 2014                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** Yogesh       App Developer                                                 **" + NL + "*******************************************************************************/" + NL + "/* Revision History" + NL + " *****************************************************************************" + NL + " *Date           Version     Remarks" + NL + " *13/1/2013       1.0.10      XMC1xxx device support added" + NL + " *" + NL + " *29/1/2014       1.0.16      DBG app changes are taken care." + NL + "*/" + NL + "/**" + NL + " * @file   SYSTM001.c" + NL + " *" + NL + " * @App Version SYSTM001 <";
  protected final String TEXT_2 = ">" + NL + " *" + NL + " * @brief  SCU_SystemTimer_SYSTM001 App implementation file. This App provides" + NL + " * API's for create, start, stop and delete software timers." + NL + " *" + NL + " */" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "" + NL + "/* Inclusion of header file */" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_3 = NL;
  protected final String TEXT_4 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_MESSAGEID_LITERAL" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_5 = "                  " + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_SYSTM001" + NL + "#define HW_TIMER_ADDITIONAL_CNT (1U)" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "" + NL + " " + NL + "/**" + NL + " * @brief      This function is called to insert a timer into the timer list.  " + NL + " *        " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM001_lInsertTimerList (uint32_t Index);" + NL + "" + NL + "" + NL + "/*" + NL + " * @brief      This function is called to remove a timer from the timer list. " + NL + " *              " + NL + " * @param[in]  Index Timer ID" + NL + " * @return     none" + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM001_lRemoveTimerList(uint32_t Index);" + NL + "" + NL + "/*" + NL + " * @brief      Handler function  called from Systick event handler. " + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void  SYSTM001_lTimerHandler (void);" + NL + "" + NL + "/*" + NL + " * @brief      Systick  handler" + NL + " *              " + NL + " * @return     void " + NL + " *      " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "void  SysTick_Handler (void);" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** Table which save timer control block. */" + NL + "SYSTM001_TimerObject TimerTbl[SYSTM001_CFG_MAX_TMR];" + NL + "" + NL + "/** The header of the Timer Control list.      */" + NL + "SYSTM001_TimerObject*  TimerList = 0;" + NL + "" + NL + " /**   Timer ID Tracker  */" + NL + "uint32_t TimerTracker = 0UL;" + NL + "" + NL + "/** SysTick Counter */" + NL + "uint32_t SysTickCount = 0UL;" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*" + NL + " * This function is called to insert a timer into the timer list." + NL + " */" + NL + "static void  SYSTM001_lInsertTimerList (uint32_t Index)" + NL + "{" + NL + "  SYSTM001_TimerObject* TmrObjPtr;" + NL + "  int32_t DeltaTicks;" + NL + "  uint32_t TempTmrCnt;" + NL + "   /* Get timer time */" + NL + "  TempTmrCnt = TimerTbl[Index].TimerCount;" + NL + "  /* Check if timer count is zero */" + NL + "  /* <<<DD_SYSTM001_PRIV _API_1>>> */" + NL + "" + NL + "  /* Check if Timer list is NULL */" + NL + "  if(TimerList == NULL)" + NL + "  {" + NL + "      /* Set this as first Timer */" + NL + "      TimerList = &TimerTbl[Index];" + NL + "  }" + NL + "  /* IF Not, find the correct place ,and insert the specified timer */" + NL + "  else" + NL + "  {" + NL + "    TmrObjPtr = TimerList;" + NL + "    /* Get timer tick */" + NL + "    DeltaTicks = (int32_t)TempTmrCnt;" + NL + "    /* Find correct place for inserting the timer */" + NL + "    while(TmrObjPtr != NULL)" + NL + "    {" + NL + "      /* Get timer Count Difference  */" + NL + "      DeltaTicks -= (int32_t)TmrObjPtr->TimerCount;" + NL + "      /* Is delta ticks<0? */" + NL + "      if(DeltaTicks < 0)" + NL + "      {" + NL + "        /*  Check If head item */" + NL + "        if(TmrObjPtr->TimerPrev!= NULL)" + NL + "        {" + NL + "          /* If Insert to list */" + NL + "          TmrObjPtr->TimerPrev->TimerNext = &TimerTbl[Index];" + NL + "          TimerTbl[Index].TimerPrev = TmrObjPtr->TimerPrev;" + NL + "          TimerTbl[Index].TimerNext = TmrObjPtr;" + NL + "          TmrObjPtr->TimerPrev = &TimerTbl[Index];" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          /* Set Timer as first item */" + NL + "          TimerTbl[Index].TimerNext = TimerList;" + NL + "          TimerList->TimerPrev = &TimerTbl[Index];" + NL + "          TimerList = &TimerTbl[Index];" + NL + "        }" + NL + "        TimerTbl[Index].TimerCount = \\" + NL + "                TimerTbl[Index].TimerNext->TimerCount + (uint32_t)DeltaTicks;" + NL + "        TimerTbl[Index].TimerNext->TimerCount  -= TimerTbl[Index].TimerCount;" + NL + "        break;" + NL + "      }" + NL + "      /* Is last item in list? */" + NL + "      else" + NL + "      {" + NL + "        if((DeltaTicks >= 0) && (TmrObjPtr->TimerNext == NULL))" + NL + "        {" + NL + "          /* Yes,insert into */" + NL + "          TimerTbl[Index].TimerPrev = TmrObjPtr;" + NL + "          TmrObjPtr->TimerNext = &TimerTbl[Index];" + NL + "          TimerTbl[Index].TimerCount = (uint32_t)DeltaTicks;" + NL + "          break;" + NL + "        }" + NL + "      }" + NL + "      /* Get the next item in timer list    */" + NL + "      TmrObjPtr = TmrObjPtr->TimerNext;" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " * This function is called to remove a timer from the timer list. " + NL + " */" + NL + "static void  SYSTM001_lRemoveTimerList(uint32_t Index)" + NL + "{" + NL + "  SYSTM001_TimerObject* TmrObjPtr;" + NL + "  TmrObjPtr = &TimerTbl[Index];" + NL + "  /* Check whether only one timer available */" + NL + "  /* <<<DD_SYSTM001_PRIV _API_2>>> */" + NL + "  if((TmrObjPtr->TimerPrev == NULL) && (TmrObjPtr->TimerNext == NULL))" + NL + "  {" + NL + "    /* set timer list as NULL */ " + NL + "    TimerList = NULL;                 \t" + NL + "  }" + NL + "   /* Check if the first item in timer list   */" + NL + "  else if(TmrObjPtr->TimerPrev == NULL)     " + NL + "  {   " + NL + "    /* Remove timer from list,and reset timer list */" + NL + "    TimerList  = TmrObjPtr->TimerNext;" + NL + "    TimerList->TimerPrev = NULL;" + NL + "    TmrObjPtr->TimerNext->TimerCount += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext    = NULL;  " + NL + "  }" + NL + "  /* Check if the last item in timer list   */" + NL + "  else if(TmrObjPtr->TimerNext == NULL)      " + NL + "  {" + NL + "    /* Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext = NULL;\t" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "  else                                /*  remove timer from list         */" + NL + "  {" + NL + "    /*  Remove timer from list */" + NL + "    TmrObjPtr->TimerPrev->TimerNext  =  TmrObjPtr->TimerNext;" + NL + "    TmrObjPtr->TimerNext->TimerPrev  =  TmrObjPtr->TimerPrev;" + NL + "    TmrObjPtr->TimerNext->TimerCount  += TmrObjPtr->TimerCount;" + NL + "    TmrObjPtr->TimerNext = NULL;" + NL + "    TmrObjPtr->TimerPrev = NULL;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " * Handler function  called from Systick event handler. " + NL + " */" + NL + "static void  SYSTM001_lTimerHandler (void)" + NL + "{" + NL + "  SYSTM001_TimerObject* TmrObjPtr;" + NL + "   /* Get first item of timer list       */" + NL + "  TmrObjPtr = TimerList;         " + NL + "  /* <<<DD_SYSTM001_PRIV _API_3>>> */  " + NL + "  while((TmrObjPtr != NULL) && (TmrObjPtr->TimerCount == 0UL) )" + NL + "  {\t" + NL + "    /* Check whether timer is a one shot timer */" + NL + "    if(TmrObjPtr->TimerType == SYSTM001_ONE_SHOT)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      SYSTM001_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Set timer status as SYSTM001_STATE_STOPPED */" + NL + "      TmrObjPtr->TimerState = SYSTM001_STATE_STOPPED;" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    /* Check whether timer is SYSTM001_PERIODIC */" + NL + "    else if(TmrObjPtr->TimerType == SYSTM001_PERIODIC)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list */" + NL + "      SYSTM001_lRemoveTimerList(TmrObjPtr->TimerID);" + NL + "      /* Reset timer tick             */" + NL + "      TmrObjPtr->TimerCount = TmrObjPtr->TimerReload;" + NL + "        /* Insert timer into timer list */" + NL + "      SYSTM001_lInsertTimerList(TmrObjPtr->TimerID);" + NL + "      /* Call timer callback function */" + NL + "      (TmrObjPtr->TimerCallBack)(TmrObjPtr->ParamToCallBack);" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      break;" + NL + "    }" + NL + "    /* Get first item of timer list */" + NL + "    TmrObjPtr = TimerList;" + NL + "  }" + NL + "}" + NL + "" + NL + "/*" + NL + " *  SysTick Event Handler " + NL + " */" + NL + "void  SysTick_Handler(void)" + NL + "{ " + NL + "  SYSTM001_TimerObject* TmrObjPtr;" + NL + "  TmrObjPtr = TimerList;" + NL + "  /* <<<DD_SYSTM001_PRIV _API_4>>> */" + NL + "  SysTickCount++;" + NL + "  if(TmrObjPtr == NULL)" + NL + "  {" + NL + "    /* Not supposed to be here */" + NL + "   ;  " + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    if(TmrObjPtr->TimerCount > 1UL)" + NL + "    {" + NL + "      TmrObjPtr->TimerCount--;" + NL + "    }" + NL + "    else" + NL + "    { " + NL + "      TmrObjPtr->TimerCount = 0;" + NL + "      SYSTM001_lTimerHandler();" + NL + "    }" + NL + "  }" + NL + "}" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** @ingroup Simple_System_Timer_App PublicFunc" + NL + " * @{" + NL + " */" + NL + " " + NL + "/*" + NL + " *  Initialization function which initializes the App internal data" + NL + " *  structures to default values. " + NL + " */" + NL + "void  SYSTM001_Init( void)" + NL + "{" + NL + "    uint32_t Status = 0UL;";
  protected final String TEXT_6 = NL + NL + "  /** Initialize the header of the list */" + NL + "  TimerList = NULL;" + NL + "  /* Clock Initialization */";
  protected final String TEXT_7 = NL + "  CLK002_Init();";
  protected final String TEXT_8 = NL + "  CLK001_Init();     ";
  protected final String TEXT_9 = NL + "  /**   Initialize timer tracker  */" + NL + "  Status = SysTick_Config((uint32_t)(SYSTM001_SYSTICK_INTERVAL * SYSTM001_SYS_CORE_CLOCK * 1000U));" + NL + "  if(Status == 1U)" + NL + "  {" + NL + "        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Status), &Status);" + NL + "  }";
  protected final String TEXT_10 = NL + "    NVIC_SetPriority(SysTick_IRQn, ";
  protected final String TEXT_11 = ");";
  protected final String TEXT_12 = NL + "    NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),";
  protected final String TEXT_13 = ",";
  protected final String TEXT_14 = "));";
  protected final String TEXT_15 = NL + "  TimerTracker = 0UL;" + NL + "" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Interface for creating a new software Timer instance." + NL + " *  Note: Because of invocation of SYSTM001_Init() : Timer reload value " + NL + " *  programmed, Hardware System Timer started. Software Timer will be created" + NL + " *  using SYSTM001_CreateTimer(). Due to time at which SW timer creation asked" + NL + " *  by user will not be in sync with HW timer, the count value used below with" + NL + " *  SW Timer, will not create starting/initial period same as expected value." + NL + " *  To SW timer period (Initial one) equal to more than expected, it is decided" + NL + " *  to add one extra count(HW_TIMER_ADDITIONAL_CNT) with Software timer." + NL + " *" + NL + " *  Impact: Impact of this additional count(HW_TIMER_ADDITIONAL_CNT) is," + NL + " *  First SW Timer period is always equal to or more than expected/configured. " + NL + " */" + NL + "handle_t SYSTM001_CreateTimer" + NL + "(" + NL + "  uint32_t Period," + NL + "  SYSTM001_TimerType TimerType, " + NL + "  SYSTM001_TimerCallBackPtr TimerCallBack, " + NL + "  void  * pCallBackArgPtr" + NL + ")" + NL + "{" + NL + "  uint32_t TimerID = 0UL;" + NL + "  uint32_t Count = 0UL;" + NL + "  uint32_t Error = 0UL;  " + NL + "" + NL + "  /* Check for input parameter */" + NL + "    if((TimerType != SYSTM001_ONE_SHOT) && (TimerType != SYSTM001_PERIODIC))" + NL + "    {" + NL + "      Error=(uint32_t)1UL;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "      " + NL + "    }" + NL + "    if(Period < (uint32_t)SYSTM001_SYSTICK_INTERVAL)" + NL + "    {" + NL + "      Error=(uint32_t)1UL;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "    }" + NL + "    if(Period == 0)          /* Timer with '0' time is not allowed. */" + NL + "    {" + NL + "      Error=(uint32_t)1UL;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "    }" + NL + "" + NL + "    if(TimerCallBack == NULL)" + NL + "    {" + NL + "      Error=(uint32_t)1UL;" + NL + "      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "    }" + NL + "    if (!Error)\t" + NL + "    {" + NL + "       for(Count = 0UL; Count < SYSTM001_CFG_MAX_TMR; Count++)" + NL + "       {" + NL + "           /* Check for free timer ID */" + NL + "           if((TimerTracker & ((uint32_t)1U << Count)) == 0U)" + NL + "           {" + NL + "               /* If yes,assign ID to this timer      */" + NL + "               TimerTracker |= ((uint32_t)1U << Count);" + NL + "               /* Initialize timer as per input values */" + NL + "               TimerTbl[Count].TimerID     = Count;" + NL + "               TimerTbl[Count].TimerType   = TimerType;" + NL + "               TimerTbl[Count].TimerState  = SYSTM001_STATE_STOPPED;" + NL + "             TimerTbl[Count].TimerCount  = ((Period / SYSTM001_SYSTICK_INTERVAL)\\" + NL + "                                                    +HW_TIMER_ADDITIONAL_CNT);" + NL + "               TimerTbl[Count].TimerReload\t= (Period / SYSTM001_SYSTICK_INTERVAL);" + NL + "               TimerTbl[Count].TimerCallBack = TimerCallBack;" + NL + "               TimerTbl[Count].ParamToCallBack = pCallBackArgPtr;" + NL + "               TimerTbl[Count].TimerPrev   = NULL;" + NL + "               TimerTbl[Count].TimerNext   = NULL;" + NL + "               TimerID = Count + 1U;" + NL + "               break;" + NL + "            }" + NL + "        }" + NL + "    }" + NL + "" + NL + "  return (handle_t)TimerID;" + NL + "}  " + NL + "" + NL + "/*" + NL + " *  Interface to start the software timer ." + NL + " */" + NL + "status_t SYSTM001_StartTimer(handle_t  Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "" + NL + "" + NL + "  /* Check validity of parameter */" + NL + "  if(Handle > SYSTM001_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t)SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "  /* Any timer with time '0', can't start again. */" + NL + "  if(TimerTbl[Handle - 1U].TimerCount == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "  " + NL + "  " + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check if timer is running */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM001_STATE_RUNNING)" + NL + "    {" + NL + "      /* set timer status as SYSTM001_STATE_RUNNING */" + NL + "      TimerTbl[(Handle - 1U)].TimerState = SYSTM001_STATE_RUNNING;" + NL + "      /* Insert this timer into timer list  */" + NL + "      SYSTM001_lInsertTimerList((Handle - 1U));" + NL + "    }" + NL + "  }" + NL + "" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "" + NL + "/*" + NL + " *  Interface to stop the software timer." + NL + " */" + NL + "status_t SYSTM001_StopTimer(handle_t Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "" + NL + "" + NL + "  /* Check validity of parameter        */" + NL + "  if(Handle > SYSTM001_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "" + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check whether Timer is in Stop state */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState != SYSTM001_STATE_STOPPED)" + NL + "    {" + NL + "      /* remove Timer from node list */" + NL + "      SYSTM001_lRemoveTimerList((Handle - 1U));" + NL + "" + NL + "      /* Set timer status as SYSTM001_STATE_STOPPED  */" + NL + "      TimerTbl[(Handle - 1U)].TimerState = SYSTM001_STATE_STOPPED;" + NL + "    }" + NL + "  }" + NL + "" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Function to delete the Timer instance." + NL + " */" + NL + "status_t SYSTM001_DeleteTimer(handle_t Handle) " + NL + "{" + NL + "  status_t Error = (status_t )DAVEApp_SUCCESS;" + NL + "" + NL + "  /* Check validity of parameter        */" + NL + "  if(Handle > SYSTM001_CFG_MAX_TMR)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "  if( (TimerTracker & (1UL << (uint32_t)(Handle - 1U))) == 0UL)" + NL + "  {" + NL + "    Error = (status_t) SYSTM001_INVALID_HANDLE_ERROR;" + NL + "    DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, sizeof(Error), &Error);" + NL + "  }" + NL + "" + NL + "  if(Error == (status_t)DAVEApp_SUCCESS)" + NL + "  {" + NL + "    /* Check if timer is running */" + NL + "    if(TimerTbl[(Handle - 1U)].TimerState == SYSTM001_STATE_RUNNING)" + NL + "    {" + NL + "      /* Yes,remove this timer from timer list*/" + NL + "      SYSTM001_lRemoveTimerList((Handle - 1U));" + NL + "    }" + NL + "" + NL + "    /* Release resource that this timer hold*/" + NL + "    TimerTracker &=~((uint32_t)1U << (Handle - 1U));" + NL + "  }" + NL + "" + NL + "  return Error;" + NL + "" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Interface to get the current system time." + NL + " */" + NL + "uint32_t  SYSTM001_GetTime(void)" + NL + "{" + NL + "  /* <<<DD_SYSTM001 _API_6>>> */" + NL + "  return CONVERT_SYSTICK_COUNT_TO_MSEC(SysTickCount);" + NL + "}" + NL + "" + NL + "/*" + NL + " *  Utility function to get the no of system ticks for the " + NL + " *  specified period." + NL + " */" + NL + "uint32_t  SYSTM001_GetSysTickCount(uint32_t Period ) " + NL + "{" + NL + "  /* <<<DD_SYSTM001 _API_7>>> */" + NL + "  uint32_t\tCount  = CONVERT_MSEC_TO_SYSICK_COUNT(Period);" + NL + "  return Count;" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "/*CODE_BLOCK_END*/" + NL;
  protected final String TEXT_16 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     String AppBaseuri = "app/systm001/0";
    stringBuffer.append(TEXT_1);
    stringBuffer.append( app.getAppVersion(AppBaseuri));
    stringBuffer.append(TEXT_2);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_3);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_4);
     } 
    stringBuffer.append(TEXT_5);
    int XMC1xxx=-1;
    int Priority=0;
    int SubPriority=0;
    XMC1xxx=app.getSoftwareId().substring(0,1).compareTo("1");
    if(XMC1xxx!=0)
    {
     Priority = app.getIntegerValue(AppBaseuri + "/systm001_irwInterruptPriority"); 
     SubPriority = app.getIntegerValue(AppBaseuri + "/systm001_irwInterruptSubPriority"); 
    }
    else {
     Priority = app.getIntegerValue(AppBaseuri + "/systm001_irwInterruptPrio_timm"); 
    }
    stringBuffer.append(TEXT_6);
     if(XMC1xxx==0) { 
    stringBuffer.append(TEXT_7);
     } else { 
    stringBuffer.append(TEXT_8);
    } 
    stringBuffer.append(TEXT_9);
     if(XMC1xxx==0) { 
    stringBuffer.append(TEXT_10);
    stringBuffer.append( Priority );
    stringBuffer.append(TEXT_11);
     } else { 
    stringBuffer.append(TEXT_12);
    stringBuffer.append( Priority );
    stringBuffer.append(TEXT_13);
    stringBuffer.append( SubPriority );
    stringBuffer.append(TEXT_14);
    } 
    stringBuffer.append(TEXT_15);
    stringBuffer.append(TEXT_16);
    return stringBuffer.toString();
  }
}
