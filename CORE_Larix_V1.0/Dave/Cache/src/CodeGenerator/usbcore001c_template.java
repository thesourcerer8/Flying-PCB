package CodeGenerator;

import com.ifx.davex.appjetinteract.App2JetInterface;

public class usbcore001c_template
{
  protected static String nl;
  public static synchronized usbcore001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    usbcore001c_template result = new usbcore001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "";
  protected final String TEXT_2 = NL + NL + NL + NL + "/* CODE_BLOCK_BEGIN[USBCORE001.c] */" + NL + "" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2012, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series                                         **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR : App Developer                                                     **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Aug 20, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                       Author(s) Identity                                   **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials    Name                                                           **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** CM          App Developer                                                  **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** Version   App Developer Name    Comments                                   **" + NL + "**                                                                            **" + NL + "**           NSND         : Updated for usb soft disconnect                   **" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/* ==========================================================================" + NL + " *" + NL + " * Synopsys HS OTG Linux Software Driver and documentation (hereinafter," + NL + " * \"Software\") is an Unsupported proprietary work of Synopsys, Inc. unless" + NL + " * otherwise expressly agreed to in writing between Synopsys and you." + NL + " *" + NL + " * The Software IS NOT an item of Licensed Software or Licensed Product under" + NL + " * any End User Software License Agreement or Agreement for Licensed Product" + NL + " * with Synopsys or any supplement thereto. You are permitted to use and" + NL + " * redistribute this Software in source and binary forms, with or without" + NL + " * modification, provided that redistributions of source code must retain this" + NL + " * notice. You may not view, use, disclose, copy or distribute this file or" + NL + " * any information contained herein except pursuant to this license grant from" + NL + " * Synopsys. If you do not agree with this notice, including the disclaimer" + NL + " * below, then you are not authorized to use the Software." + NL + " *" + NL + " * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN \"AS IS\" BASIS" + NL + " * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE" + NL + " * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE" + NL + " * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT," + NL + " * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES" + NL + " * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR" + NL + " * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER" + NL + " * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT" + NL + " * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY" + NL + " * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH" + NL + " * DAMAGE." + NL + " * ========================================================================== */" + NL + "" + NL + "/*" + NL + "  Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)" + NL + "" + NL + "  Permission to use, copy, modify, distribute, and sell this" + NL + "  software and its documentation for any purpose is hereby granted" + NL + "  without fee, provided that the above copyright notice appear in" + NL + "  all copies and that both that the copyright notice and this" + NL + "  permission notice and warranty disclaimer appear in supporting" + NL + "  documentation, and that the name of the author not be used in" + NL + "  advertising or publicity pertaining to distribution of the" + NL + "  software without specific, written prior permission." + NL + "" + NL + "  The author disclaim all warranties with regard to this" + NL + "  software, including all implied warranties of merchantability" + NL + "  and fitness.  In no event shall the author be liable for any" + NL + "  special, indirect or consequential damages or any damages" + NL + "  whatsoever resulting from loss of use, data or profits, whether" + NL + "  in an action of contract, negligence or other tortious action," + NL + "  arising out of or in connection with the use or performance of" + NL + "  this software." + NL + "*/" + NL + "/**" + NL + " * @file  USBCORE001.c" + NL + " *" + NL + " * @brief This file contains functions related to USB Core Layer." + NL + " *" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Include Files                                         **" + NL + "*******************************************************************************/" + NL + "#include <Dave3.h>" + NL + "#include \"../../src/USBLD001/driver/dwc_otg_hcd_if.h\"" + NL + "#include \"../../src/USBLD001/driver/dwc_otg_pcd_if.h\"" + NL + "#include \"../../src/USBLD001/driver/dwc_otg_adp.h\"" + NL + "#include \"../USBLD001/usbld001_delay.h\"" + NL + "" + NL + "/**" + NL + " * @cond INTERNAL_DOCS" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup USBCORE001_privateparam" + NL + " * @{" + NL + " */" + NL;
  protected final String TEXT_3 = NL + NL;
  protected final String TEXT_4 = NL + NL + NL + "/** Defines USB interrupt priority */" + NL + "#define USBCORE001_Host_PREEMPTION_PRIORITY          ";
  protected final String TEXT_5 = NL + NL + "/** Defines USB interrupt sub priority */" + NL + "#define USBCORE001_Host_SUB_PRIORITY                 ";
  protected final String TEXT_6 = NL + NL + "/*!" + NL + "*@note preserved to limit changes to the HCD part" + NL + "*/" + NL + "/**Data structures*/" + NL + "" + NL + "/** Instance to manage USBCORE001_OtgDevice*/" + NL + "USBCORE001_OtgDevice *USBCORE001_OtgDevPtr = NULL;" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "/**" + NL + " * @ingroup USBCORE001_privatefunc" + NL + " * @{" + NL + " */" + NL + "/*******************************************************************************" + NL + "**                     Private Function Declarations                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/**" + NL + " * @brief This function sets the driver parameters based on the global " + NL + " *        structure.  " + NL + " * @param [IN] CoreIfPtr    Pointer to the core interface structure" + NL + " * @return int 0 if success \\n" + NL + " */" + NL + "static int USBCORE001_SetParameters(dwc_otg_core_if_t * CoreIfPtr);" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief This function sets the interrupt priority and enable the interrupt for  " + NL + " *        USB." + NL + " * @param void" + NL + " * @return void \\n" + NL + " */" + NL + "static void USBCORE001_EnableUSBInterrupt(void);" + NL + "" + NL + "/**" + NL + " * @}" + NL + " */" + NL + "" + NL + "static struct USBCORE001_OTGDriverParam USBCORE001_DriverParams = {" + NL + "  -1,      /** opt*/" + NL + "  2,      /** otg_cap*/";
  protected final String TEXT_7 = NL + "  ";
  protected final String TEXT_8 = ",      /** dma_enable*/";
  protected final String TEXT_9 = NL + "  ";
  protected final String TEXT_10 = ",      /** dma_desc_enable */" + NL + "  -1,      /** dma_burst_size */" + NL + "  DWC_SPEED_PARAM_FULL,      /** speed */" + NL + "  1,      /** host_support_fs_ls_low_power*/" + NL + "  1,      /** host_ls_low_power_phy_clk */" + NL + "  -1,      /** enable_dynamic_fifo */" + NL + "  -1,      /** data_fifo_size */ " + NL + "  -1,      /** dev_rx_fifo_size */" + NL + "  -1,      /** dev_nperio_tx_fifo_size*/" + NL + "  {" + NL + "    /* dev_perio_tx_fifo_size_1 */" + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1," + NL + "    -1" + NL + "    /* 15 */" + NL + "  },";
  protected final String TEXT_11 = NL + "  ";
  protected final String TEXT_12 = ",    /** host_rx_fifo_size */" + NL + "  -1,    /** host_nperio_tx_fifo_size */" + NL + "  -1,    /** host_perio_tx_fifo_size */" + NL + "  -1,    /** max_transfer_size */" + NL + "  -1,    /** max_packet_count */" + NL + "  8,    /** host_channels */" + NL + "  -1,    /** dev_endpoints */" + NL + "  DWC_PHY_TYPE_PARAM_FS,    /** phy_type */" + NL + "  -1,    /** phy_utmi_width */" + NL + "  -1,    /** phy_ulpi_ddr */" + NL + "  -1,    /** phy_ulpi_ext_vbus */" + NL + "  -1,    /** i2c_enable */" + NL + "  -1,    /** ulpi_fs_ls */" + NL + "  -1,    /** ts_dline */" + NL + "  -1,    /** en_multiple_tx_fifo */" + NL + "  {" + NL + "     /* dev_tx_fifo_size */" + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1," + NL + "     -1" + NL + "    /* 15 */" + NL + "  }," + NL + "  -1,    /** thr_ctl */" + NL + "  -1,    /** tx_thr_length */" + NL + "  -1,    /** rx_thr_length */" + NL + "  -1,    /** pti_enable */" + NL + "  -1,    /** mpi_enable */" + NL + "  -1,    /** lpm_enable */" + NL + "  -1,    /** ic_usb_cap */" + NL + "  -1,    /** ahb_thr_ratio */" + NL + "  -1,    /** power_down */" + NL + "  -1,    /** reload_ctl */" + NL + "  -1,    /** otg_ver */" + NL + "  -1,    /** adp_enable */" + NL + "};" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     Private Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "static int USBCORE001_SetParameters(dwc_otg_core_if_t * CoreIfPtr)" + NL + "{" + NL + "  int RetVal = 0;";
  protected final String TEXT_13 = " " + NL + "  int Count;";
  protected final String TEXT_14 = " " + NL + "  if (USBCORE001_DriverParams.otg_cap != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_otg_cap(CoreIfPtr," + NL + "                USBCORE001_DriverParams.otg_cap);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dma_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dma_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             dma_enable);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dma_desc_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dma_desc_enable(CoreIfPtr," + NL + "                  USBCORE001_DriverParams." + NL + "                  dma_desc_enable);" + NL + "  }";
  protected final String TEXT_15 = "  " + NL + "  if (USBCORE001_DriverParams.opt != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_opt(CoreIfPtr, " + NL + "                              USBCORE001_DriverParams.opt);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dma_burst_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dma_burst_size(CoreIfPtr," + NL + "                 USBCORE001_DriverParams." + NL + "                 dma_burst_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.host_support_fs_ls_low_power != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_support_fs_ls_low_power(CoreIfPtr," + NL + "                   USBCORE001_DriverParams." + NL + "                   host_support_fs_ls_low_power);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.enable_dynamic_fifo != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_enable_dynamic_fifo(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                enable_dynamic_fifo);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.data_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_data_fifo_size(CoreIfPtr," + NL + "                 USBCORE001_DriverParams." + NL + "                 data_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dev_rx_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dev_rx_fifo_size(CoreIfPtr," + NL + "                   USBCORE001_DriverParams." + NL + "                   dev_rx_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dev_nperio_tx_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dev_nperio_tx_fifo_size(CoreIfPtr," + NL + "                    USBCORE001_DriverParams." + NL + "                    dev_nperio_tx_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.host_rx_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_rx_fifo_size(CoreIfPtr," + NL + "              USBCORE001_DriverParams.host_rx_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.host_nperio_tx_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_nperio_tx_fifo_size(CoreIfPtr," + NL + "                     USBCORE001_DriverParams." + NL + "                     host_nperio_tx_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.host_perio_tx_fifo_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_perio_tx_fifo_size(CoreIfPtr," + NL + "                    USBCORE001_DriverParams." + NL + "                    host_perio_tx_fifo_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.max_transfer_size != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_max_transfer_size(CoreIfPtr," + NL + "              USBCORE001_DriverParams." + NL + "              max_transfer_size);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.max_packet_count != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_max_packet_count(CoreIfPtr," + NL + "                   USBCORE001_DriverParams." + NL + "                   max_packet_count);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.host_channels != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_channels(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                host_channels);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.dev_endpoints != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_dev_endpoints(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                dev_endpoints);" + NL + "  }";
  protected final String TEXT_16 = "  " + NL + "  if (USBCORE001_DriverParams.phy_type != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_phy_type(CoreIfPtr," + NL + "                 USBCORE001_DriverParams.phy_type);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.speed != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_speed(CoreIfPtr," + NL + "              USBCORE001_DriverParams.speed);" + NL + "  }  ";
  protected final String TEXT_17 = "  " + NL + "  if (USBCORE001_DriverParams.host_ls_low_power_phy_clk != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_host_ls_low_power_phy_clk(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                host_ls_low_power_phy_clk);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.phy_ulpi_ddr != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_phy_ulpi_ddr(CoreIfPtr," + NL + "               USBCORE001_DriverParams." + NL + "               phy_ulpi_ddr);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.phy_ulpi_ext_vbus != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_phy_ulpi_ext_vbus(CoreIfPtr," + NL + "              USBCORE001_DriverParams." + NL + "              phy_ulpi_ext_vbus);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.phy_utmi_width != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_phy_utmi_width(CoreIfPtr," + NL + "                 USBCORE001_DriverParams." + NL + "                 phy_utmi_width);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.ulpi_fs_ls != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_ulpi_fs_ls(CoreIfPtr," + NL + "             USBCORE001_DriverParams.ulpi_fs_ls);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.ts_dline != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_ts_dline(CoreIfPtr," + NL + "                 USBCORE001_DriverParams.ts_dline);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.i2c_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_i2c_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             i2c_enable);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.en_multiple_tx_fifo != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_en_multiple_tx_fifo(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                en_multiple_tx_fifo);" + NL + "  }" + NL + "  for (Count = 0; Count < 15; Count++) {" + NL + "    if (USBCORE001_DriverParams.dev_perio_tx_fifo_size[Count] != -1) {" + NL + "      RetVal +=" + NL + "          dwc_otg_set_param_dev_perio_tx_fifo_size(CoreIfPtr," + NL + "                     USBCORE001_DriverParams." + NL + "                     dev_perio_tx_fifo_size[Count], Count);" + NL + "    }" + NL + "  }" + NL + "" + NL + "  for (Count = 0; Count < 15; Count++) {" + NL + "    if (USBCORE001_DriverParams.dev_tx_fifo_size[Count] != -1) {" + NL + "      RetVal += dwc_otg_set_param_dev_tx_fifo_size(CoreIfPtr," + NL + "                     USBCORE001_DriverParams." + NL + "                     dev_tx_fifo_size" + NL + "                     [Count], Count);" + NL + "    }" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.thr_ctl != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_thr_ctl(CoreIfPtr," + NL + "                USBCORE001_DriverParams.thr_ctl);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.mpi_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_mpi_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams.mpi_enable);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.pti_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_pti_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             pti_enable);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.lpm_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_lpm_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             lpm_enable);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.ic_usb_cap != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_ic_usb_cap(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             ic_usb_cap);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.tx_thr_length != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_tx_thr_length(CoreIfPtr," + NL + "                USBCORE001_DriverParams.tx_thr_length);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.rx_thr_length != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_rx_thr_length(CoreIfPtr," + NL + "                USBCORE001_DriverParams." + NL + "                rx_thr_length);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.ahb_thr_ratio != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_ahb_thr_ratio(CoreIfPtr," + NL + "                USBCORE001_DriverParams.ahb_thr_ratio);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.power_down != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_power_down(CoreIfPtr," + NL + "             USBCORE001_DriverParams.power_down);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.reload_ctl != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_reload_ctl(CoreIfPtr," + NL + "             USBCORE001_DriverParams.reload_ctl);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.otg_ver != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_otg_ver(CoreIfPtr," + NL + "                USBCORE001_DriverParams.otg_ver);" + NL + "  }" + NL + "  if (USBCORE001_DriverParams.adp_enable != -1) {" + NL + "    RetVal +=" + NL + "        dwc_otg_set_param_adp_enable(CoreIfPtr," + NL + "             USBCORE001_DriverParams." + NL + "             adp_enable);" + NL + "  }";
  protected final String TEXT_18 = "  " + NL + "  return RetVal;" + NL + "}" + NL + "" + NL + "" + NL + "/** This Enables and sets the priority of USB Interrupt */" + NL + "static void USBCORE001_EnableUSBInterrupt(void)" + NL + "{" + NL + "  NVIC_SetPriority(USB0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),\\" + NL + "                                           USBCORE001_Host_PREEMPTION_PRIORITY,\\" + NL + "                                           USBCORE001_Host_SUB_PRIORITY));" + NL + "  NVIC_ClearPendingIRQ(USB0_0_IRQn);" + NL + "  NVIC_EnableIRQ(USB0_0_IRQn);" + NL + "}" + NL + "" + NL + "/**" + NL + " * @endcond" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                     Public Function Definitions                            **" + NL + "*******************************************************************************/" + NL + "" + NL + "/** This is Module init function. */" + NL + "void USBCORE001_Init(void)" + NL + "{";
  protected final String TEXT_19 = NL + "\t  /* Deassert the clock gating under SCU module to enable the USB peripheral" + NL + "\t  */" + NL + "\t  " + NL + "\t  WR_REG(SCU_CLK->CGATCLR2, SCU_CLK_CGATCLR2_USB_Msk, SCU_CLK_CGATCLR2_USB_Pos, 1U);";
  protected final String TEXT_20 = NL + "  RESET001_DeassertReset(PER2_USB);" + NL + "  USB0->DCTL |= USB_DCTL_SftDiscon_Msk; " + NL + "  /* Disconnect device, so that we have time to initialize. */" + NL + "}" + NL + "" + NL + "" + NL + "/** Core initialization function. */" + NL + "int USBCORE001_Initialize(USBCORE001_OtgDevice **OtgDevPtr)" + NL + "{" + NL + "  int RetVal = 0;" + NL + "" + NL + "  *OtgDevPtr = NULL;" + NL + "                 ";
  protected final String TEXT_21 = NL + "  SCU_POWER->PWRSET |= " + NL + "               SCU_POWER_PWRSTAT_USBOTGEN_Msk | SCU_POWER_PWRSTAT_USBPHYPDQ_Msk;";
  protected final String TEXT_22 = " ";
  protected final String TEXT_23 = NL + "  SCU_POWER->PWRSET |= SCU_POWER_PWRSTAT_USBPHYPDQ_Msk;      ";
  protected final String TEXT_24 = NL + "  #ifdef DWC_DEVICE_ONLY" + NL + "   SET_BIT(USB0->GUSBCFG,USB_GUSBCFG_ForceDevMode_Pos);" + NL + "  #endif" + NL + "  #ifdef DWC_HOST_ONLY" + NL + "   SET_BIT(USB0->GUSBCFG,USB_GUSBCFG_ForceHstMode_Pos);" + NL + "  #endif" + NL + "    " + NL + "    " + NL + "  USBCORE001_EnableUSBInterrupt();" + NL + "" + NL + "  if(!USBCORE001_OtgDevPtr)" + NL + "  {" + NL + "    /**Allocate memory to hold the global data*/" + NL + "    USBCORE001_OtgDevPtr = DWC_ALLOC(sizeof(USBCORE001_OtgDevice));" + NL + "" + NL + "    if(!USBCORE001_OtgDevPtr)" + NL + "    {" + NL + "      RetVal = -DWC_E_NO_MEMORY;" + NL + "      goto end;" + NL + "    }" + NL + "    DWC_MEMSET(USBCORE001_OtgDevPtr,0,sizeof(USBCORE001_OtgDevice));" + NL + "  }" + NL + "" + NL + "  /** Step 1: Initialize the base address */" + NL + "  USBCORE001_OtgDevPtr->RegBasePtr = (void *)USBCORE001_USB_OTG_BASE_ADDRESS;" + NL + "" + NL + "  /**Step 2: Initialize core interface layer of the otg */" + NL + "  USBCORE001_OtgDevPtr->CoreIfPtr = " + NL + "                             dwc_otg_cil_init(USBCORE001_OtgDevPtr->RegBasePtr);" + NL + "" + NL + "  if(!USBCORE001_OtgDevPtr->CoreIfPtr)" + NL + "  {" + NL + "    RetVal = -DWC_E_UNKNOWN;" + NL + "    goto end;" + NL + "  }" + NL + "" + NL + "  /*" + NL + "   * Step 3: Attempt to ensure this device is really a DWC_otg Controller." + NL + "   * Read and verify the SNPSID register contents. The value should be" + NL + "   * 0x45F42XXX, which corresponds to \"OT2\", as in \"OTG version 2.XX\"." + NL + "   */" + NL + "  if ((dwc_otg_get_gsnpsid(USBCORE001_OtgDevPtr->CoreIfPtr) & 0xFFFFF000) !=" + NL + "      0x4F542000) {" + NL + "    RetVal = -EINVAL;" + NL + "    goto end;" + NL + "  }" + NL + "" + NL + "  /**Step 4:  Initialize the params*/" + NL + "  RetVal = USBCORE001_SetParameters(USBCORE001_OtgDevPtr->CoreIfPtr);" + NL + "  if(0 != RetVal)" + NL + "  {" + NL + "    RetVal = -EINVAL;" + NL + "    goto end;" + NL + "  }" + NL + "" + NL + "  /*" + NL + "   * Step 5: Disable the global interrupts until all interrupt routines" + NL + "   * are installed" + NL + "  */" + NL + "  dwc_otg_disable_global_interrupts(USBCORE001_OtgDevPtr->CoreIfPtr);" + NL + "" + NL + "  /**Step 5: Enable else init HCD/PCD */" + NL + "  /** Initialize the DWC_otg core.*/" + NL + "    dwc_otg_core_init(USBCORE001_OtgDevPtr->CoreIfPtr);" + NL + "" + NL + "#ifndef DWC_HOST_ONLY" + NL + "    if (RetVal != 0) {" + NL + "      USBCORE001_OtgDevPtr->PcdData.PCDPtr = NULL;" + NL + "      goto end;" + NL + "    }" + NL + "#endif" + NL + "  " + NL + "  dwc_otg_enable_global_interrupts(USBCORE001_OtgDevPtr->CoreIfPtr);" + NL + "  " + NL + "  *OtgDevPtr = USBCORE001_OtgDevPtr;" + NL + "" + NL + "end:" + NL + "  if(0 != RetVal)" + NL + "  {" + NL + "    /**Perform appropriate cleanup*/" + NL + "    if(USBCORE001_OtgDevPtr)" + NL + "    {" + NL + "      if(USBCORE001_OtgDevPtr->CoreIfPtr)" + NL + "      {" + NL + "        dwc_otg_cil_remove(USBCORE001_OtgDevPtr->CoreIfPtr);" + NL + "        USBCORE001_OtgDevPtr->CoreIfPtr = NULL;" + NL + "      }" + NL + "      DWC_FREE(USBCORE001_OtgDevPtr);" + NL + "      USBCORE001_OtgDevPtr = NULL;" + NL + "    }" + NL + "  }" + NL + "  return RetVal;" + NL + "}" + NL + "" + NL + "" + NL + "/** Global interrupt routine */" + NL + "void USBCORE001_Intr(void)" + NL + "{" + NL + "  if(NULL != USBCORE001_OtgDevPtr)" + NL + "  {" + NL + "#ifdef DWC_DEVICE_ONLY" + NL + "    dwc_otg_pcd_handle_intr(USBCORE001_OtgDevPtr->PcdData.PCDPtr);" + NL + "#endif" + NL + "#ifdef DWC_HOST_ONLY" + NL + "    dwc_otg_hcd_handle_intr(USBCORE001_OtgDevPtr->HCDPtr);" + NL + "#endif" + NL + "  }" + NL + "}" + NL + "" + NL + "/** USB interrupt Handler  */" + NL + "void USB0_0_IRQHandler()" + NL + "{" + NL + "  USBCORE001_Intr();" + NL + "}" + NL + "" + NL + "/*CODE_BLOCK_END*/";
  protected final String TEXT_25 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
    stringBuffer.append(TEXT_1);
     int Is44Device = -1; 
     int Is42Device = -1; 
     int Is45Device = -1; 
     Is44Device = ((app.getSoftwareId().substring(0,2).compareTo("44")==0)?1:0); 
     Is42Device = ((app.getSoftwareId().substring(0,2).compareTo("42")==0)?1:0); 
     Is45Device = ((app.getSoftwareId().substring(0,2).compareTo("45")==0)?1:0); 
    stringBuffer.append(TEXT_2);
     String AppBaseuri = "app/USBCore001/";
     int appInst = 0;
 int DMA_Mode = 0;
 int DMA_DescMode = 0;
 int HostRxFIFO_Size = 0;
 int Priority = app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwInterruptPriority");
 int SubPriority = app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwInterruptSubPriority");

    stringBuffer.append(TEXT_3);
    

if(app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwusbop") == 1)
{
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/0") == 1)
	{
	  DMA_Mode = 0;
	  DMA_DescMode = -1;
	  HostRxFIFO_Size = -1;
	}
	
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/1") == 1)
	{
	  DMA_Mode = 1;
	  DMA_DescMode = 0;
	  HostRxFIFO_Size = app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwhost_rxfifo_sz/");
	}
	
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/2") == 1)
	{
	  DMA_Mode = 1;
	  DMA_DescMode = 1;
	  HostRxFIFO_Size = app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwhost_rxfifo_sz/");
	}

}

if(app.getIntegerValue(AppBaseuri + appInst +"/usbcore001_irwusbop") == 2)
{
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/0") == 1)
	{
	  DMA_Mode = 0;
	  DMA_DescMode = -1;
	  HostRxFIFO_Size = -1;
	}
	
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/1") == 1)
	{
	  DMA_Mode = 1;
	  DMA_DescMode = 0;
	  HostRxFIFO_Size = -1;
	}
	
	if(app.getIntegerValue(AppBaseuri + appInst +"/usbore001_erwusbmode/2") == 1)
	{
	  DMA_Mode = 1;
	  DMA_DescMode = 1;
	  HostRxFIFO_Size = -1;
	}
}


    stringBuffer.append(TEXT_4);
    stringBuffer.append( Priority);
    stringBuffer.append(TEXT_5);
    stringBuffer.append( SubPriority);
    stringBuffer.append(TEXT_6);
    stringBuffer.append(TEXT_7);
    stringBuffer.append(DMA_Mode);
    stringBuffer.append(TEXT_8);
    stringBuffer.append(TEXT_9);
    stringBuffer.append(DMA_DescMode);
    stringBuffer.append(TEXT_10);
    stringBuffer.append(TEXT_11);
    stringBuffer.append(HostRxFIFO_Size);
    stringBuffer.append(TEXT_12);
    if ((Is44Device==1)||(Is45Device==1))
  {
    stringBuffer.append(TEXT_13);
    }
    stringBuffer.append(TEXT_14);
    if ((Is44Device==1)||(Is45Device==1))
  {
    stringBuffer.append(TEXT_15);
    }
    stringBuffer.append(TEXT_16);
    if ((Is44Device==1)||(Is45Device==1))
{
    stringBuffer.append(TEXT_17);
    }
    stringBuffer.append(TEXT_18);
    if ((Is44Device==1)||(Is42Device==1))
  {
    stringBuffer.append(TEXT_19);
    }
    stringBuffer.append(TEXT_20);
    if ((Is44Device==1)||(Is45Device==1))
  {
    stringBuffer.append(TEXT_21);
    }
    stringBuffer.append(TEXT_22);
    if (Is42Device == 1)
  {
    stringBuffer.append(TEXT_23);
    }
    stringBuffer.append(TEXT_24);
    stringBuffer.append(TEXT_25);
    return stringBuffer.toString();
  }
}
