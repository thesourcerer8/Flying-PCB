/*******************************************************************************
**  DAVE App Name : ADCGLOB001       App Version: 1.0.26               
**  This file is generated by DAVE, User modification to this file will be    **
**  overwritten at the next code generation.                                  **
*******************************************************************************/


/*******************************************************************************
 Copyright (c) 2013, Infineon Technologies AG                                 **
 All rights reserved.                                                         **
                                                                              **
 Redistribution and use in source and binary forms, with or without           **
 modification,are permitted provided that the following conditions are met:   **
                                                                              **
 *Redistributions of source code must retain the above copyright notice,      **
 this list of conditions and the following disclaimer.                        **
 *Redistributions in binary form must reproduce the above copyright notice,   **
 this list of conditions and the following disclaimer in the documentation    **
 and/or other materials provided with the distribution.                       **
 *Neither the name of the copyright holders nor the names of its contributors **
 may be used to endorse or promote products derived from this software without**
 specific prior written permission.                                           **
                                                                              **
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  **
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **
 ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **
 LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **
 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **
 SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **
 CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **
 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **
 POSSIBILITY OF SUCH DAMAGE.                                                  **
                                                                              **
 To improve the quality of the software, users are encouraged to share        **
 modifications, enhancements or bug fixes with Infineon Technologies AG       **
 dave@infineon.com).                                                          **
                                                                              **
 *******************************************************************************
 **                                                                           **
 **                                                                           **
 ** PLATFORM : Infineon XMC4000/XMC1000 Series                                **
 **                                                                           **
 ** COMPILER : Compiler Independent                                           **
 **                                                                           **
 ** AUTHOR : App Developer                                                    **
 **                                                                           **
 ** MAY BE CHANGED BY USER [yes/no]: Yes                                      **
 **                                                                           **
 ** MODIFICATION DATE : Jan 29, 2014                                          **
 **                                                                           **
 ******************************************************************************/

/*******************************************************************************
 **                       Author(s) Identity                                  **
 *******************************************************************************
 **                                                                           **
 ** Initials           Name                                                   **
 ** --------------------------------------------------------------------------**
 ** Neelakanta        App Developer                                           **
 ** SSAM              Sridhar Sampath                                         **
 ******************************************************************************/

/**
 * @file ADCGLOB001.c
 *
 * @brief
 * This is global ADC App which allows the sharing of global ADC resources.
 *
 * Change History:
 * Date       version       Details
 * 12-Dec-2012   1.0.5    Initial code added for XMC1000
 * 18-Jan-2013   1.0.6    Merging with XMC1000 done
 * 24-Apr-2013   1.0.12   Ported to XMC4500 step AB and
 *                        Source Result selection Feature added
 * 10-Jun-2013   1.0.14   1. Supported for XMC1100 device,
 *                        2. Comment in header section - the Device series name is
 *                           made as XMC1000
 * 27-Jun-2013   1.0.16   Global limits made unavailable for adc004 app
 * 29-Aug-2013   1.0.18   XMC1200/XMC1300 New Sofware IDS added.
 *                        Unused code removed
 * 31-Oct-2013   1.0.20   1. The macro name ADCGLOB001_DBG002_FUNCTION_ENTRY is
 *                        corrected as ADCGLOB001_FUNCTION_ENTRY
 *                        2. Analog Clock divider value minimum 1 was generated
 *                        and now it is made as 0 for XMC1000 devices.
 * 14-Nov-2013   1.0.22   CLK001_Init() for XMC4000 devices CLK002_Init() for
 *                        XMC1000 devices is removed in ADCGLOB001_Init()
 *                        function, since this CLK00x_Init() function is called
 *                        at the beginning  of the DAVE_Init() function.
 * 29-Jan-2014   1.0.24   Error codes are added in various functions, that can
 *                        be logged with DBG002 App.
 */

/*******************************************************************************
 ** INCLUDE FILES                                                             **
 ******************************************************************************/

#include <DAVE3.h>


/*****************************************************************************
              DUMMY DEFINTIONS OF DEBUG LOG MACROS
*****************************************************************************/
/*These definitions are included here to avoid compilation errors,
 since the DBG002 app is not part of the project. All the macros are defined
 as empty*/
#ifndef _DBG002_H_

#define DBG002_RegisterCallBack(A,B,C)
#define DBG002_I(e)
#define DBG002_IG(e,g)
#define DBG002_IH(e,h)
#define DBG002_IP(e,p)
#define DBG002_IGH(e,g,h)
#define DBG002_IGP(e,g,p)
#define DBG002_IHP(e,h,p)
#define DBG002_IGHP(e,g,h,p)
#define DBG002_N(e)
#define DBG002_NG(e,g)
#define DBG002_NH(e,h)
#define DBG002_NP(e,p)
#define DBG002_NGH(e,g,h)
#define DBG002_NGP(e,g,p)
#define DBG002_NHP(e,h,p)
#define DBG002_NGHP(e,g,h,p)
#define DBG002_ID(e)
#define DBG002_IS(e)
#define DBG002_ISG(e,g)
#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)
#define DBG002_CRITICAL(groupid,messageid,length,value)
#define DBG002_ERROR(groupid,messageid,length,value)
#define DBG002_WARNING(groupid,messageid,length,value)
#define DBG002_INFO(groupid,messageid,length,value)
#define DBG002_TRACE(groupid,messageid,length,value)
#define DBG002_FUNCTION_ENTRY(GID, Status)
#define DBG002_FUNCTION_EXIT(GID, Status)

#define DBG002_MESSAGEID_LITERAL

#endif/* End of defintions of dummy Debug Log macros*/


/*******************************************************************************
**                      Private Macro Definitions                             **
*******************************************************************************/
#define APP_GID DBG002_GID_ADCGLOB001
/**
 * @cond INTERNAL_DOCS
 */
/*******************************************************************************
 **                              API DEFINITION
 *******************************************************************************/

/**
 *This function initialize all VADC Global registers based on GUI configuration.
 */
void ADCGLOB001_Init(void)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if(ADCGLOB001_Handle0.kDynamicDataPtr->StateType == ADCGLOB001_UNINITIALIZED )
    {    
        WR_REG(SCU_CLK->CLKCR, SCU_CLK_CLKCR_CNTADJ_Msk, SCU_CLK_CLKCR_CNTADJ_Pos,CLK002_DELAYCNT);
        SCU_GENERAL->PASSWD = 0x000000C0U;
        /* Disables the gating for VADC kernel This line of code is not applicable for XMC4500. */
        SET_BIT(SCU_CLK->CGATCLR0, SCU_CLK_CGATCLR0_VADC_Pos);
        SCU_GENERAL->PASSWD = 0x000000C3UL;
        while (SCU_CLK->CLKCR&(SCU_CLK_CLKCR_VDDC2LOW_Msk))
        {};     
        /* Enable Out of range Comparator for ADC channels pins P2.2to P2.9,
         * this code is applicable only for XMC1xxx devices  */
            COMPARATOR->ORCCTRL = 0XFFU;
        /* Bring the module out of disabled state.*/
        CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->CLC, VADC_CLC_DISR_Pos);
        /**
         * Make divider bit fields writable.
         * Configure Divider Factor for the Analog Internal Clock.
         * Configure Divider Factor for the Arbiter Clock.
         * Configure Double Clock for the MSB Conversion.
         */
        ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG = \
                (uint32_t)(((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)| \
                        (((uint32_t)ADCGLOB001_Handle0.kArbiterClkDivider <<VADC_GLOBCFG_DIVD_Pos) & VADC_GLOBCFG_DIVD_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.keDoubleClkMSBConver <<VADC_GLOBCFG_DCMSB_Pos)&VADC_GLOBCFG_DCMSB_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kAnalogClkDivider <<VADC_GLOBCFG_DIVA_Pos)&VADC_GLOBCFG_DIVA_Msk));
        /* Make the divider bit fields write protected */
        CLR_BIT( ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG, VADC_GLOBCFG_DIVWC_Pos);

        /**
         * Configure Class0 Sample Time Control for Standard Conversion.
         * Configure Class0 Sample Time Control for EMUX Conversion.
         * Configure Class0 Conversion Mode for Standard Conversion.
         * Configure Class0 Conversion Mode for EMUX Conversion.
         */
        ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[0] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass0 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass0 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass0 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass0 <<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));
        /**
         * Configure Class1 Sample Time Control for Standard Conversion.
         * Configure Class1 Sample Time Control for EMUX Conversion.
         * Configure Class1 Conversion Mode for Standard Conversion.
         * Configure Class1 Conversion Mode for EMUX Conversion.
         */
        ADCGLOB001_Handle0.kGlobalPtr->GLOBICLASS[1] = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.kEMUXConversionModeClass1 << VADC_GLOBICLASS_CME_Pos)&VADC_GLOBICLASS_CME_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kEMUXSampleTimeControlClass1 <<VADC_GLOBICLASS_STCE_Pos)&VADC_GLOBICLASS_STCE_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kConversionModeClass1 <<VADC_GLOBICLASS_CMS_Pos)&VADC_GLOBICLASS_CMS_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.kSampleTimeControlClass1<<VADC_GLOBICLASS_STCS_Pos)&VADC_GLOBICLASS_STCS_Msk));

        /* Configure the lower and upper boundary based on the GUI configuration.*/
        ADCGLOB001_Handle0.kGlobalPtr->GLOBBOUND = \
                (uint32_t)((((uint32_t)ADCGLOB001_Handle0.KGlobBoundary1 <<VADC_GLOBBOUND_BOUNDARY1_Pos)&VADC_GLOBBOUND_BOUNDARY1_Msk)| \
                        (((uint32_t)ADCGLOB001_Handle0.KGlobBoundary0 <<VADC_GLOBBOUND_BOUNDARY0_Pos)&VADC_GLOBBOUND_BOUNDARY0_Msk));
        ADCGLOB001_Handle0.kDynamicDataPtr->StateType = ADCGLOB001_INITIALIZED;
        Status &= (uint32_t)DAVEApp_SUCCESS;
    } else {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

}

/**
 * This function will de-initialize VADC Global registers.
 */
status_t ADCGLOB001_DeInit(const ADCGLOB001_HandleType * HandlePtr)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if(HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED )
    {
        /* Enable the VADC clock gating
         * This line of code is not applicable for XMC4500.
         */

        SET_BIT(SCU_CLK->CGATSET0, SCU_CLK_CGATSET0_VADC_Pos);
        /* Bring the module out of disabled state */
        CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);

        /* Make divider bit fields writable and deconfigure Analog Internal Clock,
     Arbiter Clock & MSB Conversion bits.*/
        HandlePtr->kGlobalPtr->GLOBCFG = \
                (((uint32_t)1<<VADC_GLOBCFG_DIVWC_Pos)|((~(VADC_GLOBCFG_DIVD_Msk))& \
                        (~(VADC_GLOBCFG_DCMSB_Msk)) & (~(VADC_GLOBCFG_DIVA_Msk))));

        /* Again make the divider bit fields write protected */
        CLR_BIT( HandlePtr->kGlobalPtr->GLOBCFG, VADC_GLOBCFG_DIVWC_Pos);

        /*
         * Configure Class0 Sample Time Control for Standard Conversion into default
         *  mode.
         * Configure Class0 Conversion Mode for Standard Conversion into default mode.
         * Configure Class0 Sample Time Control for EMUX Conversion into default mode.
         * Configure Class0  Conversion Mode for EMUX Conversion into default mode.
         */
        HandlePtr->kGlobalPtr->GLOBICLASS[0] = \
                ((~(VADC_GLOBICLASS_CME_Msk))&(~(VADC_GLOBICLASS_STCE_Msk))& \
                        (~(VADC_GLOBICLASS_CMS_Msk))&(~(VADC_GLOBICLASS_STCS_Msk)));
        /*
         * Configure Class1 Sample Time Control for Standard Conversion into default
         *  mode.
         * Configure Class1 Conversion Mode for Standard Conversion into default mode.
         * Configure Class1 Sample Time Control for EMUX Conversion into default mode.
         * Configure Class1  Conversion Mode for EMUX Conversion into default mode.
         */
        HandlePtr->kGlobalPtr->GLOBICLASS[1] = \
                ((~(VADC_GLOBICLASS_CME_Msk))&(~(VADC_GLOBICLASS_STCE_Msk))& \
                        (~(VADC_GLOBICLASS_CMS_Msk))&(~(VADC_GLOBICLASS_STCS_Msk)));

        /* Configure global lower and upper boundary value into default value.*/
        HandlePtr->kGlobalPtr->GLOBBOUND = \
                ((~(VADC_GLOBBOUND_BOUNDARY1_Msk))&(~(VADC_GLOBBOUND_BOUNDARY0_Msk)));

        HandlePtr->kDynamicDataPtr->StateType = ADCGLOB001_UNINITIALIZED;
        Status = (uint32_t)DAVEApp_SUCCESS;
    } else {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}

/**
 * This function disable the control of the module.
 */
status_t ADCGLOB001_CLKRequestDisable(const ADCGLOB001_HandleType * HandlePtr)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {

        /* Bring the module in disabled state
         * Module Disable Request Bit
         * 0 : enable the module clock
         * 1 : stop the module clock */

        SET_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);

        Status = (uint32_t)DAVEApp_SUCCESS;

    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function enable the control of the module.
 */
status_t ADCGLOB001_CLKRequestEnable(const ADCGLOB001_HandleType * HandlePtr)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /* Bring the module out of disabled state */

        CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_DISR_Pos);

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function Initiate the start-up calibration phase.
 */

status_t ADCGLOB001_SetStartUpCalibration(
        const ADCGLOB001_HandleType *HandlePtr
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /* Initiate Start-Up Calibration */

        SET_BIT( HandlePtr->kGlobalPtr->GLOBCFG, VADC_GLOBCFG_SUCAL_Pos);

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function Initialise the calibration based on GUI configuration.
 */
status_t ADCGLOB001_StartUpCalibrationInit(void)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if(ADCGLOB001_Handle0.kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED )
    {
        /* Initialise Calibration */

        if(ADCGLOB001_Handle0.keStartCalib == (uint8_t)1)
        {
            /* Initiate Start-Up Calibration */
            SET_BIT( ADCGLOB001_Handle0.kGlobalPtr->GLOBCFG, VADC_GLOBCFG_SUCAL_Pos);
        }

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}

/**
 * This function Enables Sleep Mode Control.Which is used to control module?s
 * reaction to sleep mode.
 */
status_t ADCGLOB001_EnableSleepModeControl(
        const ADCGLOB001_HandleType * HandlePtr
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /* Reset  Sleep Mode Enable Control bit*/
        CLR_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_EDIS_Pos);

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
      DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function disregards Sleep Mode Control.
 */
status_t ADCGLOB001_DisregardSleepModeControl(
        const ADCGLOB001_HandleType * HandlePtr
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /* set  Sleep Mode Enable Control bit*/
        SET_BIT( HandlePtr->kGlobalPtr->CLC, VADC_CLC_EDIS_Pos);

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}

/**
 * This function configure the class 0 conversion mode for standard conversions.
 */
status_t ADCGLOB001_SetGlobClass0ConvMode(
        const ADCGLOB001_HandleType * HandlePtr,
        ADCGLOB001_ConversionMode ConversionModeVal
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
                (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) {
            /* Set the global class0 conversion mode */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
                    VADC_GLOBICLASS_CMS_Msk,
                    VADC_GLOBICLASS_CMS_Pos,
                    (uint32_t)ConversionModeVal
            );

            Status = (uint32_t)DAVEApp_SUCCESS;
        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function configure the class 0 Sample Time Control for Standard
 * Conversions.
 */

status_t ADCGLOB001_SetGlobClass0SampleTime(
        const ADCGLOB001_HandleType * HandlePtr,
        uint8_t SampleTime
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if(SampleTime < (uint8_t)32){
            /* Set the global class0 Sample Time */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
                    VADC_GLOBICLASS_STCS_Msk,
                    VADC_GLOBICLASS_STCS_Pos,
                    (uint32_t)SampleTime
            );

            Status = (uint32_t)DAVEApp_SUCCESS;
        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;

}
/**
 * This function configure the class 0 Conversion Mode for EMUX Conversions.
 */
status_t ADCGLOB001_SetGlobClass0EmuxConvMode(
        const ADCGLOB001_HandleType * HandlePtr,
        ADCGLOB001_ConversionMode ConversionModeVal
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
                (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) {
            /* Set the global class0 External Multiplexer conversion mode*/
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
                    VADC_GLOBICLASS_CME_Msk,
                    VADC_GLOBICLASS_CME_Pos,
                    (uint32_t)ConversionModeVal
            );
            Status = (uint32_t)DAVEApp_SUCCESS;

        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;

}

/**
 * This function configure the class 0 Sample Time Control for EMUX Conversions.
 */
status_t ADCGLOB001_SetGlobClass0EmuxSampleTime(
        const ADCGLOB001_HandleType * HandlePtr,
        uint8_t SampleTime
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if(SampleTime < (uint8_t)32){

            /* Set the global class0 External Multiplexer Sample Time */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[0],
                    VADC_GLOBICLASS_STCE_Msk,
                    VADC_GLOBICLASS_STCE_Pos,
                    (uint32_t)SampleTime
            );

            Status = (uint32_t)DAVEApp_SUCCESS;

        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function configure the class 1 conversion mode for standard conversions.
 */
status_t ADCGLOB001_SetGlobClass1ConvMode(
        const ADCGLOB001_HandleType * HandlePtr,
        ADCGLOB001_ConversionMode ConversionModeVal
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
                (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) {
            /* Set the global class 1 conversion mode */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
                    VADC_GLOBICLASS_CMS_Msk,
                    VADC_GLOBICLASS_CMS_Pos,
                    (uint32_t)ConversionModeVal
            );

            Status = (uint32_t)DAVEApp_SUCCESS;

        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function configure the class 1 Sample Time Control for Standard
 * Conversions.
 */
status_t ADCGLOB001_SetGlobClass1SampleTime(
        const ADCGLOB001_HandleType * HandlePtr,
        uint8_t SampleTime
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {

        if(SampleTime < (uint8_t)32){
            /* Write the global class 1 Sample Time */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
                    VADC_GLOBICLASS_STCS_Msk,
                    VADC_GLOBICLASS_STCS_Pos,
                    (uint32_t)SampleTime
            );

            Status = (uint32_t)DAVEApp_SUCCESS;

        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}

/**
 * This function configure the class 1 Conversion Mode for EMUX Conversions.
 */
status_t ADCGLOB001_SetGlobClass1EmuxConvMode(
        const ADCGLOB001_HandleType * HandlePtr,
        ADCGLOB001_ConversionMode ConversionModeVal
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if((ConversionModeVal < (ADCGLOB001_ConversionMode)3) ||
                (ConversionModeVal ==(ADCGLOB001_ConversionMode)5)) {
            /* Write the global class1 External Multiplexer conversion mode */

            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
                    VADC_GLOBICLASS_CME_Msk,
                    VADC_GLOBICLASS_CME_Pos,
                    (uint32_t)ConversionModeVal
            );
            Status = (uint32_t)DAVEApp_SUCCESS;
        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}

/**
 * This function configure the class 1 Sample Time Control for EMUX Conversions.
 */
status_t ADCGLOB001_SetGlobClass1EmuxSampleTime(
        const ADCGLOB001_HandleType * HandlePtr,
        uint8_t SampleTime
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        if(SampleTime < (uint8_t)32){
            /* Write the global class1 External Multiplexer Sample Time */
            WR_REG( HandlePtr->kGlobalPtr->GLOBICLASS[1],
                    VADC_GLOBICLASS_STCE_Msk,
                    VADC_GLOBICLASS_STCE_Pos,
                    (uint32_t)SampleTime
            );
            Status = (uint32_t)DAVEApp_SUCCESS;

        }
        else
        {
            Status = (uint32_t)ADCGLOB001_INVALID_PARAM_ERROR;
            DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
        }
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function gives the status of Module Disable bit.
 */
status_t ADCGLOB001_GetDisableBitStatus(
        const ADCGLOB001_HandleType * HandlePtr,
        uint8_t *StatusValue
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /*Read the status value */

        *StatusValue = (uint8_t) RD_REG( HandlePtr->kGlobalPtr->CLC,
                VADC_CLC_DISS_Msk,
                VADC_CLC_DISS_Pos
        );
        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/**
 * This function gives the Id Value.
 */

status_t ADCGLOB001_GetIdValue(
        const ADCGLOB001_HandleType * HandlePtr,
        uint32_t *IDValue
)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    if (HandlePtr->kDynamicDataPtr->StateType == ADCGLOB001_INITIALIZED)
    {
        /*Read the ID value */
        *IDValue =(uint32_t)HandlePtr->kGlobalPtr->ID;

        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

    return Status;
}
/* By default all Vadc registers are writable.
 * EnableWritetoVadcRegisters function is called to write to registers, this function can be called
 * only if the vadc registers disabled for writing by calling the function DisableWritetoVadcRegisters() */

void EnableWritetoVadcRegisters(void)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    SCU_GENERAL->PASSWD = 0x000000C0U;
    if (((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk)==0)
    {
        /*Channel control registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APC0_Msk, VADC_ACCPROT0_APC0_Pos, 0U);
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APC1_Msk, VADC_ACCPROT0_APC1_Pos, 0U);

        /*    Enable write to External multiplexer control registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APEM_Msk, VADC_ACCPROT0_APEM_Pos, 0U);

        /*    Initialization control registers */
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_API0_Msk, VADC_ACCPROT0_API0_Pos, 0U);
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_API1_Msk, VADC_ACCPROT0_API1_Pos, 0U);

        /*    Enable write to Gobal configuration registers */
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APGC_Msk, VADC_ACCPROT0_APGC_Pos, 0U);

        /*    Enable write to Service request control registers*/
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APS1_Msk, VADC_ACCPROT1_APS0_Pos, 0U);
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APS1_Msk, VADC_ACCPROT1_APS1_Pos, 0U);

        /*Enable write to Result control registers*/
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APR0_Msk, VADC_ACCPROT1_APR0_Pos, 0U);
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APR1_Msk, VADC_ACCPROT1_APR1_Pos, 0U);
        Status = (uint32_t)DAVEApp_SUCCESS;
    }
    SCU_GENERAL->PASSWD = 0x000000C3UL;

    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

}

/* DisableWritetoVadcRegisters function is called to disable write to vadc registers, this function can
 * be called only if the user wants to disable writing to vadc registers. To enable writing to registers
 * EnableWritetoVadcRegisters() function needs to be called. */


void DisableWritetoVadcRegisters(void)
{
    status_t Status = (uint32_t)ADCGLOB001_OPER_NOT_ALLOWED;

    SCU_GENERAL->PASSWD = 0x000000C0U;
    if (((SCU_GENERAL->PASSWD)&SCU_GENERAL_PASSWD_PROTS_Msk)==0)
    {
        /*Channel control registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APC0_Msk, VADC_ACCPROT0_APC0_Pos, 1U);
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APC1_Msk, VADC_ACCPROT0_APC1_Pos, 1U);

        /*Enable write to External multiplexer control registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APEM_Msk, VADC_ACCPROT0_APEM_Pos, 1U);

        /*Initialization control registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_API0_Msk, VADC_ACCPROT0_API0_Pos, 1U);
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_API1_Msk, VADC_ACCPROT0_API1_Pos, 1U);

        /*Enable write to Gobal configuration registers*/
        WR_REG( VADC->ACCPROT0, VADC_ACCPROT0_APGC_Msk, VADC_ACCPROT0_APGC_Pos, 1U);

        /*Enable write to Service request control registers*/
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APS0_Msk, VADC_ACCPROT1_APS0_Pos, 1U);
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APS1_Msk, VADC_ACCPROT1_APS1_Pos, 1U);

        /*Enable write to Result control registers*/
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APR0_Msk, VADC_ACCPROT1_APR0_Pos, 1U);
        WR_REG( VADC->ACCPROT1, VADC_ACCPROT1_APR1_Msk, VADC_ACCPROT1_APR1_Pos, 1U);
        Status = (uint32_t)DAVEApp_SUCCESS;
    }

    SCU_GENERAL->PASSWD = 0x000000C3UL;
    if (Status != (uint32_t)DAVEApp_SUCCESS)
    {
        DBG002_ERROR(APP_GID, DBG002_MESSAGEID_LITERAL, 1, &Status);
    }

}
/**
 * @endcond
 */

